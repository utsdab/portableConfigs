// --------------------------------------------------------------------------------------------------
//
// SHAPES
//
// blend shape editing tool for Maya
//
// required plugins:
//   SHAPESTools
//
// Ingo Clemens
// www.braverabbit.com
//
// copyright brave rabbit, Ingo Clemens 2014-2016
//
// --------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------
//
// THE SOFTWARE PRODUCT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
// IMPLIED, INCLUDING, BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NON-INFRINGEMENT OF THIRD-PARTY RIGHTS. THE ENTIRE RISK AS TO THE QUALITY AND
// PERFORMANCE OF THE SOFTWARE PRODUCT IS WITH YOU.
// NEITHER BRAVE RABBIT NOR ITS SUPPLIERS WARRANT THAT THE FUNCTIONS CONTAINED IN THE SOFTWARE
// PRODUCT WILL MEET YOUR REQUIREMENTS OR THAT THE OPERATION OF THE SOFTWARE PRODUCT WILL BE
// UNINTERRUPTED OR ERROR-FREE. BRAVE RABBIT IS NOT OBLIGATED TO PROVIDE ANY UPDATES TO THE
// SOFTWARE.
// IN NO EVENT SHALL THE AUTHOR OF THIS SOFTWARE PRODUCT BE LIABLE FOR ANY SPECIAL, CONSEQUENTIAL,
// INCIDENTAL, DIRECT OR INDIRECT DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
// LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, FOR PERSONAL INJURY, LOSS OF BUSINESS
// INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THIS
// PRODUCT, EVEN IF THE AUTHOR OF THIS SOFTWARE PRODUCT IS AWARE OF THE POSSIBILITY OF SUCH
// DAMAGES AND KNOWN DEFECTS, ANY CLAIM BY A THIRD PARTY AND EVEN IF THE REMEDY FAILS OF ITS
// ESSENTIAL PURPOSE.
//
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
// weight maps
// --------------------------------------------------------------------------------------------------

global proc shapesWeights_paintShapeWeights()
{
	global int $gShapes_index;
	global int $gShapes_paintWeightsProcess;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_selectedTarget;
	global string $gShapes_skinMesh;
	global string $gShapes_bsData[];
	
	//
	// start to paint weights for the current shape
	//
	if ($gShapes_skinMesh == "")
		return;
	
	if ($gShapes_selectedTarget == "")
		return;
	
	if (dict_getBoolValue($gShapes_bsData[$gShapes_index], "set"))
		return;
	
	select -r $gShapes_skinMesh;
	
	// toggle the ui elements
	shapesWeights_paintWeightsToggleUI 0;
	
	$gShapes_paintWeightsProcess = 1;
	
	shapesWeights_activatePaintBlendShapeWeightsTool $gShapes_bsNode $gShapes_selectedTarget $gShapes_targetIndex 0;
}


global proc shapesWeights_activatePaintBlendShapeWeightsTool( string $node, string $target, int $index, int $base )
{
	//
	// activate the paint blend shape weights tool
	//
	string $attr = "paintTargetWeights";
	if ($base)
		$attr = "baseWeights";
	
	// hide the tool settings so that the target selection doesn't get overridden
	if (`optionVar -q SHAPESHidePaintWeightsToolSettings`)
		setToolSettingsVisible false;
	
	// the following command must be used in order to be able to paint
	// on the right blend shape node if there is more than one;
	// simply using the paint blend shapes tool still has a bug, where only one blend shape node
	// will be respected and listed in the tool options window
	artSetToolAndSelectAttr("artAttrCtx", ("blendShape." + $node + "." + $attr));
	
	if ($base)
		return;
	
	// make sure the target is also selected in the tool settings
	source artAttrBlendShapeCallback;
	catchQuiet(`artBlendShapeSelectTarget artAttrCtx $target`);
	// sets the paintable index of the blend shape node
	shapesWeights_setBlendShapePaintTargetIndex $node $index;
}


global proc shapesWeights_setBlendShapePaintTargetIndex( string $node, int $index )
{
	//
	// set the paint target index for the blend shape node
	//
	string $attr = ".inputTarget[0]";
	if (`shapesGlobal_getMayaVersion` < 2013)
		$attr = "";
	setAttr ($node + $attr + ".pti") $index;
}


global proc shapesWeights_exitPaintShapeWeights()
{
	//
	// finish painting weights for the current shape
	//
	global int $gShapes_index;
	global int $gShapes_paintWeightsProcess;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	global string $gShapes_bsData[];
	
	// toggle the ui elements
	shapesWeights_paintWeightsToggleUI 1;
	
	$gShapes_paintWeightsProcess = 0;
	
	// indicate the weights on the target
	int $indices[] = `br_blendShapeEditWeights -getIndices -n $gShapes_bsNode -i $gShapes_targetIndex`;
	if (size($indices))
		dict_setValue($gShapes_bsData, $gShapes_index, "weights", "true");
	else
		dict_setValue($gShapes_bsData, $gShapes_index, "weights", "false");
	shapesMain_refreshTargetList;
	
	setToolTo selectSuperContext;
	
	// Maya 2016 has a viewport 2.0 refresh bug which still shows the weights
	// after switching to another tool; reselecting the mesh forces a redraw
	if (`shapesGlobal_getMayaVersion` >= 2016)
	{
		select -cl;
		select -r $gShapes_skinMesh;
	}
}


global proc shapesWeights_paintWeightsToggleUI( int $enable )
{
	//
	// disables/enables ui elements
	// based on entering/exiting the paint weights mode
	//
	// set the sculpt mode options enable state
	shapesUI_manageUIModeDependencies 1 1 $enable;
	
	if (!$enable)
	{
		iconTextButton 	-e 
						-i "SHAPES_weightPaintActive.png" 
						-c shapesWeights_exitPaintShapeWeights 
						-ann "Exit paint weights mode" 
						shpUI_paintWeightsButton;
		// disable the target list
		treeView -e -en 0 shpUI_targetTree;
		
		menuItem -l "Set Brush Color To White" -p shpUI_paintWeightsPopup -c "artAttrCtx -e -value 1 `currentCtx`";
		menuItem -l "Set Brush Color To Black" -p shpUI_paintWeightsPopup -c "artAttrCtx -e -value 0 `currentCtx`";
		menuItem -d 1 -p shpUI_paintWeightsPopup;
		menuItem -l "Flush Vertices With White" -p shpUI_paintWeightsPopup -c ("shapesWeights_shapeWeightsFlush -1");
		menuItem -l "Flush Vertices With Black" -p shpUI_paintWeightsPopup -c ("shapesWeights_shapeWeightsFlush 0");
	}
	else
	{
		iconTextButton 	-e 
						-i "SHAPES_weightPaint.png" 
						-c shapesWeights_paintShapeWeights 
						-ann "Paint weights for the selected shape" 
						shpUI_paintWeightsButton;
		
		// if there are targets in the list enable the list
		string $items[] = `treeView -q -ch "" shpUI_targetTree`;
		if ($items[0] != "No shapes")
			treeView -e -en 1 shpUI_targetTree;
		
		$items = `popupMenu -q -ia shpUI_paintWeightsPopup`;
		for ($i in $items)
			deleteUI $i;
	}
}


global proc shapesWeights_setWeightButtonsState( int $state )
{
	//
	// enable/disable the weight buttons when entering/leaving paint mode
	//
	string $items[] = `rowLayout -q -ca shpUI_shapeWeightsLayout`;
	stringArrayRemoveAtIndex(0, $items);
	for ($i in $items)
	{
		if (`gmatch $i "*iconTextButton*"`)
			iconTextButton -e -en $state $i;
	}
}


global proc shapesWeights_shapeWeightsFlush( int $value )
{
	//
	// flush all weights with the given value
	//
	global int $gShapes_regionProcess;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_regionBS;
	global string $gShapes_regionTarget;
	global string $gShapes_skinMesh;
	
	string $bsNode = $gShapes_bsNode;
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	int $index = $gShapes_targetIndex;
	
	if ($gShapes_regionProcess)
	{
		$bsNode = $gShapes_regionBS;
		$intermediate = shapesMain_getOriginalMesh($gShapes_regionTarget, 0);
		$index = -1;
	}
	
	string $context = `currentCtx`;
	setToolTo selectSuperContext;
	br_blendShapeEditWeights -flush $value -n $bsNode -om $intermediate -i $index;
	setToolTo $context;
}


global proc shapesWeights_copyShapeWeights()
{
	//
	// copy the weights of the current shape
	//
	global int $gShapes_targetIndex;
	global int $gShapes_weightsDataIndices[];
	global float $gShapes_weightsDataValues[];
	global string $gShapes_bsNode;
	
	int $indices[] = `br_blendShapeEditWeights -getIndices -n $gShapes_bsNode -i $gShapes_targetIndex`;
	float $weights[] = `br_blendShapeEditWeights -getWeights -n $gShapes_bsNode -i $gShapes_targetIndex`;
	if (!size($indices))
	{
		warning "No weights to copy";
		return;
	}
	
	$gShapes_weightsDataIndices = $indices;
	$gShapes_weightsDataValues = $weights;
}


global proc shapesWeights_setShapeWeights( int $indices[], float $values[] )
{
	//
	// sets the given weights for the current target
	//
	global string $gShapes_bsNode;
	global string $gShapes_bsData[];
	
	int $nIds[] = shapesMain_getShapeIds(1, {});
	int $ids[] = shapesMain_getShapeIds(0, {});
	
	for ($n = 0; $n < size($nIds); $n ++)
	{
		// check if one of the selected targets is a helper attribute
		// might be possible through multi selection
		if (!dict_getBoolValue($gShapes_bsData[$ids[$n]], "helper"))
		{
			br_blendShapeEditWeights -set -n $gShapes_bsNode -i $nIds[$n] -ids $indices -w $values;
			
			// indicate the weights on the target
			dict_setValue($gShapes_bsData, $ids[$n], "weights", "true");
		}
	}
}


global proc shapesWeights_removeShapeWeights( int $paste, string $shapes[] )
{
	//
	// deletes all weights from the current shape
	// and optionally paste the stored weights to the current shape
	//
	global int $gShapes_targetIndex;
	global int $gShapes_weightsDataIndices[];
	global float $gShapes_weightsDataValues[];
	global string $gShapes_bsNode;
	global string $gShapes_bsData[];
	
	int $nIds[] = shapesMain_getShapeIds(1, $shapes);
	int $ids[] = shapesMain_getShapeIds(0, $shapes);
	
	for ($n = 0; $n < size($nIds); $n ++)
	{
		// check if one of the selected targets is a helper attribute
		// might be possible through multi selection
		if (!dict_getBoolValue($gShapes_bsData[$ids[$n]], "helper"))
		{
			br_blendShapeEditWeights -delete -n $gShapes_bsNode -i $nIds[$n];
			
			// indicate no weights on the target
			dict_setValue($gShapes_bsData, $ids[$n], "weights", "false");
		}
	}
	
	if ($paste)
		shapesWeights_setShapeWeights $gShapes_weightsDataIndices $gShapes_weightsDataValues;
		
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_setBlendShapePaintTargetIndex $gShapes_bsNode $gShapes_targetIndex;
	
	shapesMain_refreshTargetList;
}


global proc shapesWeights_exportShapeWeights( string $mapName, int $freeze, int $overwrite, int $base )
{
	//
	// export the weights of the current shape
	// the mapName is given when exporting the entire setup
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	
	string $shape[];
	
	if ($freeze)
	{
		string $sel[] = `ls -sl -tr`;
		if (!size($sel))
			return;
	
		$shape = `listRelatives -s -ni $sel[0]`;
		if (!size($shape))
			error ($sel[0] + " has no shape node");
		if (`nodeType $shape[0]` != "mesh")
			error ($shape[0] + " is not a mesh object");
	}
	
	string $exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 1);
	if ($exportPath == "")
		return;
	
	if ($mapName == "")
	{
		string $selMap[] = `textScrollList -q -si shpUI_shapeWeightsList`;
		string $prompt = `promptDialog 	-t "Export Weights" 
										-m "Set Weight Map Name" 
										-tx $selMap 
										-b "OK" 
										-b "Cancel" 
										-db "Cancel" 
										-cb "Cancel" 
										-ds "Cancel"`;
		if ($prompt == "Cancel")
			return;
	
		$mapName = `promptDialog -q -tx`;
	}
	
	string $fileName = $exportPath + "/" + $mapName + ".bsw";
	
	if (!$overwrite)
	{
		if (`file -q -ex $fileName`)
		{
			string $msg = "Weight map \"" + $mapName + "\" already exists.\n\nDo you want to replace it?";
			if (!shapesGlobal_confirmWindow($msg, "OK"))
				return;
		}
	}
	
	int $result;
	if (!$freeze)
	{
		int $index = $gShapes_targetIndex;
		if ($base)
			$index = -1;
		$result = `br_blendShapeEditWeights -ex -fn $fileName -n $gShapes_bsNode -i $index`;
	}
	else
		$result = `br_blendShapeEditWeights -ex -fn $fileName -fp -om $shape[0]`;
	
	if ($mapName != "" && $result)
	{
		print ("// Exported weights to \"" + $fileName + "\" //\n");
		
		shapesUI_toggleWeightsContextMenu 0;
		shapesUtil_buildImportMenu "shpUI_shapeWeightsList";
	}
}


global proc int shapesWeights_importShapeWeights( int $freeze )
{
	//
	// import the weights to the current shape
	//
	global int $gShapes_index;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_bsData[];
	
	int $return = 0;
	
	string $exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return $return;
	
	string $mapName[] = `textScrollList -q -si shpUI_shapeWeightsList`;
	if (!size($mapName))
		return $return;
	string $fileName = $exportPath + "/" + $mapName[0] + ".bsw";
	
	if ($freeze)
	{
		$return = shapesWeights_setPaintFreezeWeights($fileName);
		return 1;
	}
	
	// read the weights from the file and apply them
	$return = `br_blendShapeEditWeights -im -fn $fileName -n $gShapes_bsNode -i $gShapes_targetIndex`;
	
	if ($return)
	{
		dict_setValue($gShapes_bsData, $gShapes_index, "weights", "true");
		print ("// Imported weight map \"" + $fileName + "\" //\n");
	}
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_setBlendShapePaintTargetIndex $gShapes_bsNode $gShapes_targetIndex;
	
	shapesMain_refreshTargetList;
	
	return $return;
}


global proc shapesWeights_invertShapeWeights()
{
	//
	// inverts the weight map of the current shape
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	global string $gShapes_bsData[];
	
	if ($gShapes_skinMesh == "")
		return;
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	
	int $nIds[] = shapesMain_getShapeIds(1, {});
	int $ids[] = shapesMain_getShapeIds(0, {});
	
	for ($n = 0; $n < size($nIds); $n ++)
	{
		int $result = `br_blendShapeEditWeights -invert -n $gShapes_bsNode -i $nIds[$n] -om $intermediate`;
		// indicate the weights on the target
		if ($result)
			dict_setValue($gShapes_bsData, $ids[$n], "weights", "true");
	}
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_setBlendShapePaintTargetIndex $gShapes_bsNode $gShapes_targetIndex;
	
	shapesMain_refreshTargetList;
}


global proc shapesWeights_mirrorShapeWeights()
{
	//
	// mirrors the weight map of the current shape
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	global string $gShapes_bsData[];
	
	// change the tool to avoid any warnings
	// duplicating the mesh with the paint tool active results in
	// // Warning: Invalid UV map on mesh.
	string $lastTool = `currentCtx`;
	setToolTo selectSuperContext;
	
	string $axis = shapesMirror_mirrorAxisString();
	int $dir = `optionVar -q SHAPESMirrorDirection`;
	
	float $tolerance = `optionVar -q SHAPESMirrorToleranceValue`;
	
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	string $mirrorShape;
	
	if (`optionVar -q SHAPESOrderBasedMirror`)
	{
		// duplicate the original mesh
		string $original = shapesAction_duplicateOrginalMesh("shp_originalMesh_copy");
		string $originalShape[] = `listRelatives -s $original`;
		string $originalRev[] = `duplicate $original`;
		$originalRev[0] = `rename $originalRev[0] "shp_originalMesh_reverseOrder"`;
		string $originalRevShape[] = `listRelatives -s $originalRev[0]`;
		string $compString = shapesMirror_getShapeSymmetryComponents(0);
		// reverse the vertex order
		br_vertexReorder -o $original -t $originalRev[0] -cl $compString;
		$mirrorShape = $originalShape[0];
	}
	
	int $nIds[] = shapesMain_getShapeIds(1, {});
	int $ids[] = shapesMain_getShapeIds(0, {});
	
	for ($n = 0; $n < size($nIds); $n ++)
	{
		int $result = `br_blendShapeEditWeights -mirror -n $gShapes_bsNode -i $nIds[$n] -om $intermediate -mm $mirrorShape -ax $axis -dir $dir -tol $tolerance`;
		// indicate the weights on the target
		if ($result == 1)
			dict_setValue($gShapes_bsData, $ids[$n], "weights", "true");
		else if ($mirrorShape != "")
			delete $mirrorShape;
	}
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_setBlendShapePaintTargetIndex $gShapes_bsNode $gShapes_targetIndex;
	
	shapesMain_refreshTargetList;
	
	if (`gmatch $lastTool "*artAttrBlendShapeContext*"`)
		shapesWeights_paintShapeWeights;
}

global proc shapesWeights_trimShapeWeights( int $positive )
{
	//
	// trims the weights to appear only on the positive axis
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	global string $gShapes_bsData[];
	
	int $nIds[] = shapesMain_getShapeIds(1, {});
	int $ids[] = shapesMain_getShapeIds(0, {});
	
	string $axis = shapesMirror_mirrorAxisString();
	float $tolerance = `optionVar -q SHAPESMirrorToleranceValue`;
	
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	
	for ($n = 0; $n < size($nIds); $n ++)
	{
		int $result = `br_blendShapeEditWeights -trim -n $gShapes_bsNode -i $nIds[$n] -om $intermediate -ax $axis -dir $positive -tol $tolerance`;
		if ($result)
		{
			// indicate the weights on the target
			dict_setValue($gShapes_bsData, $ids[$n], "weights", "true");
		}
	}
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_setBlendShapePaintTargetIndex $gShapes_bsNode $gShapes_targetIndex;
}


global proc string shapesWeights_getListBasedInfo( string $type )
{
	//
	// return a dictionary of infos about the given list type
	// unifying renaming and deleting of weight and region maps
	//
	string $info = "";
	if ($type == "weights")
		$info = "{'list': 'shpUI_shapeWeightsList', 'typePath': 'weights', 'upCase': 'Weight', 'lowCase': 'weight', 'ext': '.bsw', 'context': ''}";
	else if ($type == "region")
		$info = "{'list': 'shpUI_regionList', 'typePath': 'regions', 'upCase': 'Region', 'lowCase': 'region', 'ext': '.bsr', 'context': 'shpUI_deleteRegionItem'}";
	return $info;
}


global proc shapesWeights_renameWeightMap( string $type )
{
	//
	// renames the weight/region map file on disk
	//
	global string $gShapes_bsNode;
	
	string $info = shapesWeights_getListBasedInfo($type);
	
	string $oldName[] = `textScrollList -q -si (dict_getStringValue($info, "list"))`;
	
	string $exportPath = shapesUtil_getExportPath("/" + dict_getStringValue($info, "typePath") + "/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return;
	
	string $prompt = `promptDialog 	-t "Rename" 
									-m ("New " + dict_getStringValue($info, "upCase") + " Map Name") 
									-tx $oldName[0] 
									-b "OK" 
									-b "Cancel" 
									-db "Cancel" 
									-cb "Cancel" 
									-ds "Cancel"`;
	if ($prompt == "Cancel")
		return;
	
	string $mapName = `promptDialog -q -tx`;
	
	string $oldFileName = $exportPath + "/" + $oldName[0] + dict_getStringValue($info, "ext");
	string $fileName = $exportPath + "/" + $mapName + dict_getStringValue($info, "ext");
	
	python("import os; os.rename('" + $oldFileName + "', '" + $fileName + "')");
	
	string $cmd;
	if (dict_getStringValue($info, "typePath") == "regions")
		$cmd = "menuItem -e -en 0 " + dict_getStringValue($info, "context");
	else
		$cmd = "shapesUI_toggleWeightsContextMenu 0";
	eval $cmd;
	shapesUtil_buildImportMenu (dict_getStringValue($info, "list"));
	
	// in case of region file renaming also check
	// if the current region map name needs to be updated as well
	if (dict_getStringValue($info, "typePath") == "regions")
	{
		string $fieldText = `textField -q -tx shpUI_currentRegionNameField`;
		if ($fieldText == $oldName[0])
		{
			textField -e -tx $mapName shpUI_currentRegionNameField;
			
			string $node = "SHAPESRegionData";
			lockNode -l 0 $node;
			setAttr ($node + ".regionMap") -type "string" $mapName;
			lockNode -l 1 $node;
		}
	}
}


global proc shapesWeights_deleteWeightMap( string $type )
{
	//
	// deletes the weight/region map file on disk
	//
	global string $gShapes_bsNode;
	global string $gShapes_undoInfo;
	
	string $info = shapesWeights_getListBasedInfo($type);
	
	string $mapName[] = `textScrollList -q -si (dict_getStringValue($info, "list"))`;
	
	string $msg = "Delete " + dict_getStringValue($info, "lowCase") + " map file?\n\n" + $gShapes_undoInfo;
	if (!shapesGlobal_confirmWindow($msg, "Delete"))
		return;
	
	string $exportPath = shapesUtil_getExportPath("/" + dict_getStringValue($info, "typePath") + "/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return;
	
	string $fileName = $exportPath + "/" + $mapName[0] + dict_getStringValue($info, "ext");
	
	python("import os; os.remove('" + $fileName + "')");
	
	print ("// Deleted " + dict_getStringValue($info, "lowCase") + " map " + $fileName + " //\n");
	
	string $cmd;
	if (dict_getStringValue($info, "typePath") == "regions")
		$cmd = "menuItem -e -en 0 " + dict_getStringValue($info, "context");
	else
		$cmd = "shapesUI_toggleWeightsContextMenu 0";
	eval $cmd;
	shapesUtil_buildImportMenu (dict_getStringValue($info, "list"));
	
	if (dict_getStringValue($info, "lowCase") == "region")
		shapesRegion_clearRegionData $mapName[0];
}


global proc shapesWeights_freezeShapeWeights( string $shapes[] )
{
	//
	// applies the scaled vertex position from the the weight map to the
	// target shape and deletes the weight map
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_bsData[];
	
	// the freezing needs to be performed through a command string collection
	// because if executing the command through a loop an error occurs
	// that the weight information cannot be found even though it should make no difference
	string $cmd;
	
	int $nIds[] = shapesMain_getShapeIds(1, $shapes);
	int $ids[] = shapesMain_getShapeIds(0, $shapes);
	for ($n = 0; $n < size($nIds); $n ++)
	{
		string $values[] = dict_getValueArray($gShapes_bsData[$ids[$n]], "values");
		for ($v in $values)
			$cmd += "br_blendShapeEditWeights -freeze -n " + $gShapes_bsNode + " -i " + $nIds[$n] + " -tv " + $v + ";\n";
		
		// indicate no weights on the target
		dict_setValue($gShapes_bsData, $ids[$n], "weights", "false");
	}
	eval $cmd;
	
	// sets the paintable index of the blend shape node
	if (`currentCtx` == "artAttrBlendShapeContext")
		shapesWeights_setBlendShapePaintTargetIndex $gShapes_bsNode $gShapes_targetIndex;
	
	shapesMain_refreshTargetList;
}


global proc int shapesWeights_setPaintFreezeWeights( string $fileName )
{
	//
	// writes the vertex color information for the freeze brush
	// from the weight list file
	//
	string $sel[] = `ls -sl -tr`;
	if (!size($sel))
		return 0;
	
	string $shape[] = `listRelatives -s -ni $sel[0]`;
	if (!size($shape))
		error ($sel[0] + " has no shape node");
	if (`nodeType $shape[0]` != "mesh")
		error ($shape[0] + " is not a mesh object");
	
	string $currentContext = `currentCtx`;
	PaintVertexColorTool;
	
	if (!`optionVar -q SHAPESUseMayaSculptTool`)
	{
		string $artContext = `currentCtx`;
		if ($currentContext != "artAttrColorPerVertexContext")
			error "The brush freeze paint mode must be enabled to write the freeze data";
	
		// flood everything black to set all vertices
		artAttrPaintVertexCtx -e -colorRGBValue 0 0 0 $artContext;
		artAttrPaintVertexCtx -e -clear $artContext;
		artAttrPaintVertexCtx -e -colorRGBValue 0.4 0.7 1.0 -selectedattroper "absolute" $artContext;
	}
	
	int $return = `br_blendShapeEditWeights -im -fp -fn $fileName -om $shape[0]`;
	
	setToolTo $currentContext;
	
	return $return;
}


global proc shapesWeights_combineWeightMap( int $add )
{
	//
	// adds or subtracts the weights from the selected weight map file
	// to/from the the current weights
	//
	global int $gShapes_index;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	global string $gShapes_bsData[];
	
	string $exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return;
	
	string $mapName[] = `textScrollList -q -si shpUI_shapeWeightsList`;
	if (!size($mapName))
		return;
	string $fileName = $exportPath + "/" + $mapName[0] + ".bsw";
	
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	
	string $cmd = "br_blendShapeEditWeights ";
	if ($add)
		$cmd += "-add ";
	else
		$cmd += "-sub ";
	$cmd += "-fn \"" + $fileName + "\" -n " + $gShapes_bsNode + " -i " + $gShapes_targetIndex + " -om " + $intermediate;
	
	// read the weights from the file and apply them
	int $return = `eval $cmd`;
	
	if ($return)
	{
		dict_setValue($gShapes_bsData, $gShapes_index, "weights", "true");
		// sets the paintable index of the blend shape node
		if (`currentCtx` == "artAttrBlendShapeContext")
			shapesWeights_setBlendShapePaintTargetIndex $gShapes_bsNode $gShapes_targetIndex;
		
		shapesMain_refreshTargetList;
	}
}


// --------------------------------------------------------------------------------------------------
// ramp weights
// --------------------------------------------------------------------------------------------------


global proc shapesWeights_editRampWeights( string $shape, int $index, string $ramp )
{
	//
	// displays the options to create, edit or delete a ramp weights node
	//
	global string $gShapes_bsNode;
	global string $gShapes_rampPlug;
	global string $gShapes_bsData[];
	
	string $buttonList[] = {"OK", "Cancel"};
	string $msg;
	string $conn[];
	
	if ($ramp == "")
		$msg = "Create Ramp Weights";
	else
	{
		$msg = "Process Ramp Weights";
		
		// check if a driver for the offset is already present
		$buttonList = {"Delete", "Select", " Create Driver ", "Cancel"};
		if (`gmatch $ramp "*.*"`)
			$buttonList = {"Delete", "Select", " Select Driver ", " Delete Driver ", "Cancel"};
	}
	
	string $cmd = "confirmDialog -t \"SHAPES\" -m \"" + $msg + "\" -b \"" + stringArrayToString($buttonList, "\" -b \"") + "\" -db \"Cancel\" -cb \"Cancel\" -ds \"Cancel\"";
	string $confirm = `eval $cmd`;
	if ($confirm == "Cancel")
		return;
	
	string $displayState;
	
	if ($ramp == "")
	{
		$ramp = shapesWeights_createRampWeights($shape, $index);
		$displayState = "true";
		$gShapes_rampPlug = "";
	}
	else
	{
		string $rampAttr = "offset";
		if (`optionMenu -q -ex shpUI_rampAttrOption`)
			$rampAttr = `optionMenu -q -v shpUI_rampAttrOption`;
		
		if (`gmatch $ramp "*.*"`)
			$gShapes_rampPlug = $ramp;
		else
			$gShapes_rampPlug = $ramp + "." + $rampAttr;
		string $rampNode[] = stringToStringArray($ramp, ".");
		
		if ($confirm == "Delete")
		{
			select -r $rampNode[0];
			brDeleteRampWeights;
			$displayState = "false";
			clear $rampNode;
			$ramp = "";
			$gShapes_rampPlug = "";
		}
		else if ($confirm == "Select")
		{
			select -r $rampNode[0];
			return;
		}
		else if ($confirm == " Create Driver ")
		{
			shapesDriver_createWeightDriver("", 0, 0);
			$displayState = "true";
			$ramp += "." + $rampAttr;
		}
		else if ($confirm == " Select Driver ")
		{
			shapesDriver_collectDriverInfo;
			return;
		}
		else if ($confirm == " Delete Driver ")
		{
			shapesDriver_deleteWeightDriver "";
			$displayState = "true";
			$gShapes_rampPlug = "";
			$ramp = $rampNode[0];
		}
	}
	
	// indicate the ramp on the target
	int $ids[] = shapesMain_getShapeIds(0, {$shape});
	dict_setValue($gShapes_bsData, $ids[0], "weights", $displayState);
	dict_setValue($gShapes_bsData, $ids[0], "ramp", $ramp);
	shapesMain_refreshTargetList;
}


global proc string shapesWeights_createRampWeights( string $shape, int $index )
{
	//
	// creates a ramp weights node
	//
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	string $originalMesh = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	string $node = brConnectRampWeights($originalMesh, $gShapes_bsNode, $index, 1, $shape);
	return $node;
}


global proc SHAPES_weights(){}
