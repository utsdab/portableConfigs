// --------------------------------------------------------------------------------------------------
//
// SHAPES
//
// blend shape editing tool for Maya
//
// required plugins:
//   SHAPESTools
//
// Ingo Clemens
// www.braverabbit.com
//
// copyright brave rabbit, Ingo Clemens 2014-2016
//
// --------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------
//
// THE SOFTWARE PRODUCT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
// IMPLIED, INCLUDING, BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NON-INFRINGEMENT OF THIRD-PARTY RIGHTS. THE ENTIRE RISK AS TO THE QUALITY AND
// PERFORMANCE OF THE SOFTWARE PRODUCT IS WITH YOU.
// NEITHER BRAVE RABBIT NOR ITS SUPPLIERS WARRANT THAT THE FUNCTIONS CONTAINED IN THE SOFTWARE
// PRODUCT WILL MEET YOUR REQUIREMENTS OR THAT THE OPERATION OF THE SOFTWARE PRODUCT WILL BE
// UNINTERRUPTED OR ERROR-FREE. BRAVE RABBIT IS NOT OBLIGATED TO PROVIDE ANY UPDATES TO THE
// SOFTWARE.
// IN NO EVENT SHALL THE AUTHOR OF THIS SOFTWARE PRODUCT BE LIABLE FOR ANY SPECIAL, CONSEQUENTIAL,
// INCIDENTAL, DIRECT OR INDIRECT DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
// LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, FOR PERSONAL INJURY, LOSS OF BUSINESS
// INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THIS
// PRODUCT, EVEN IF THE AUTHOR OF THIS SOFTWARE PRODUCT IS AWARE OF THE POSSIBILITY OF SUCH
// DAMAGES AND KNOWN DEFECTS, ANY CLAIM BY A THIRD PARTY AND EVEN IF THE REMEDY FAILS OF ITS
// ESSENTIAL PURPOSE.
//
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
// mirror target
// --------------------------------------------------------------------------------------------------

global proc shapesMirror_batchMirrorTarget( int $copy, int $flip )
{
	//
	// processes all targets in the selected group
	//
	global string $gShapes_undoInfo;
	
	string $msg = "Proceed with all targets in the selected group?\n\n" + $gShapes_undoInfo;
	if (!shapesGlobal_confirmWindow($msg, "OK"))
		return;
	
	// get the contents of the group
	string $targetList[] = shapesMain_getTargetListSelection(2);
	for ($shape in $targetList)
	{
		treeView -e -cs shpUI_targetTree;
		treeView -e -si $shape 1 shpUI_targetTree;
		string $slider = shapesMain_buildTargetSlider();
		shapesMirror_mirrorTarget $slider $copy $flip;
	}
}


global proc shapesMirror_mirrorTarget( string $slider, int $copy, int $flip )
{
	//
	// mirror the target and all existing inbetweens
	// create a copy for the other side if needed
	// 0: mirror
	// 1: copy to opposite
	// 2: apply to opposite
	//
	global int $gShapes_index;
	global int $gShapes_createSequence;
	global int $gShapes_targetIndex;
	global string $gShapes_selectedTarget;
	global string $gShapes_bsData[];
	
	string $targetList[];
	int $valueList[];
	
	string $sequence = shapesDriver_getShapeSequence($gShapes_selectedTarget);
	string $tgts[] = dict_getValueArray($sequence, "targets");
	if ($sequence != "" && !size($tgts))
		$sequence = "";
	
	if ($sequence == "" || (size($tgts) && $tgts[size($tgts) - 1] != $gShapes_selectedTarget))
	{
		int $value;
		// get the value of the given slider
		string $label = `floatSliderButtonGrp -q -l $slider`;
		if ($label == "Base")
			$value = 6000;
		else
		{
			// get the value from the slider label because the number of the
			// in-between can be used to get the value from the list
			string $valueList[] = dict_getValueArray($gShapes_bsData[$gShapes_index], "values");
			string $labelItems[] = stringToStringArray($label, " ");
			int $vId = $labelItems[1];
			$value = $valueList[$vId];
		}
		
		$targetList[size($targetList)] = $gShapes_selectedTarget;
		$valueList[size($valueList)] = $value;
	}
	else if ((size($tgts) && $tgts[size($tgts) - 1] == $gShapes_selectedTarget))
	{
		$targetList = $tgts;
		for ($t in $targetList)
			$valueList[size($valueList)] = 6000;
	}
	
	$gShapes_createSequence = 0;
	
	for ($i = 0; $i < size($targetList); $i ++)
	{
		// set the current target for the process
		$gShapes_selectedTarget = $targetList[$i];
		int $nIds[] = shapesMain_getShapeIds(1, {$targetList[$i]});
		int $ids[] = shapesMain_getShapeIds(0, {$targetList[$i]});
		
		$gShapes_targetIndex = $nIds[0];
		$gShapes_index = $ids[0];
		
		// update the driver list and ui to show the driver settings
		shapesDriver_collectDriverInfo;
		
		// in case of a sequence
		// if the last shape is processed set the flag
		// to also create the sequence because the other targets already exist
		if ($sequence != "" && $i == size($targetList) - 1)
			$gShapes_createSequence = 1;
		
		shapesMirror_performMirrorTarget $targetList[$i] $valueList[$i] $copy $flip;
	}
}


global proc shapesMirror_performMirrorTarget( string $shape, float $value, int $copy, int $flip )
{
	//
	// mirror the target and all existing inbetweens
	// create a copy for the other side if needed
	// 0: mirror
	// 1: copy to opposite
	// 2: apply to opposite
	//
	global int $gShapes_centerMirrorState;
	global int $gShapes_index;
	global int $gShapes_targetIndex;
	global string $gShapes_bsNode;
	global string $gShapes_selectedTarget;
	global string $gShapes_skinMesh;
	global string $gShapes_bsData[];
	
	// for full and half mirrors get the setting from the menu
	if ($flip == -1)
		$flip = `optionVar -q SHAPESFullMirror`;
	
	int $center = shapesMirror_mirrorDriverSettings();
	if ($gShapes_centerMirrorState == -1)
	{
		$gShapes_centerMirrorState = 0;
		return;
	}
	
	string $opposite = shapesMirror_swapSideLabel($gShapes_selectedTarget);
	
	// define the index for setting the point values
	int $index = shapesAction_findEmptyTargetIndex();
	if (!$copy)
		$index = $gShapes_targetIndex;
	
	// if the target should be copied to the other side
	// check if the destination target and inbetween exists
	if ($copy == 2)
	{
		if ($opposite == $gShapes_selectedTarget)
			error ($gShapes_selectedTarget + " has no side (left/right) identifier");
		
		if (`attributeQuery -n $gShapes_bsNode -ex $opposite`)
		{
			for ($i = 0; $i < size($gShapes_bsData); $i ++)
			{
				if (dict_getStringValue($gShapes_bsData[$i], "target") == $opposite)
				{
					string $valString = $value;
					string $valList[] = dict_getValueArray($gShapes_bsData[$i], "values");
					if (stringArrayContains($valString, $valList))
						$index = dict_getValue($gShapes_bsData[$i], "index");
					else
						error "No sibling for the selected value found for the other side";
				}
			}
		}
		else
			error ($gShapes_selectedTarget + " has no target sibling for the other side");
	}
	
	float $targetIds[];
	if ($copy == 0 || $copy == 2)
		$targetIds[size($targetIds)] = $value;
	else
	{
		// get the target and all inbetweens
		$targetIds = dict_getFloatValueArray($gShapes_bsData[$gShapes_index], "values");
	}
	
	// define axis multiplier
	string $axis = shapesMirror_mirrorAxisString();
	int $inv[] = {1, 1, 1};
	if ($axis == "x")
		$inv[0] = -1;
	else if ($axis == "y")
		$inv[1] = -1;
	else
		$inv[2] = -1;
	
	float $tolerance = `optionVar -q SHAPESMirrorToleranceValue`;
	
	// initialize the progress bar
	global string $gMainProgressBar;
	progressBar -e -bp -ii 0 -max (size($targetIds)) $gMainProgressBar;
	
	string $compString;
	string $original;
	string $sourceName;
	
	int $orderBasedMirror = `optionVar -q SHAPESOrderBasedMirror`;
	if ($orderBasedMirror)
	{
		// duplicate the original mesh
		$original = shapesAction_duplicateOrginalMesh(dict_getStringValue($gShapes_bsData[$gShapes_index], "target"));
		$sourceName = substitute("_extracted", $original, "");
		
		$compString = shapesMirror_getShapeSymmetryComponents(0);
	}
	
	string $target = "";
	int $inbetweenBool;
	
	// store the symmetry setting
	// must be disabled to correctly mirror the shapes
	optionVar -iv SHAPESSymmetricModelingState `symmetricModelling -q -s`;
	symmetricModelling -e -s 0;
	
	for ($id in $targetIds)
	{
		progressBar -e -st ("Mirroring Shape ... (index " + $id + ")") $gMainProgressBar;
		
		//
		// order based mirror
		// 
		if ($orderBasedMirror)
		{
			$target = "";
			string $extracted[];
			if ($id == 6000)
				$extracted = shapesAction_extractTarget("", -1, 0, 0);
			else
			{
				string $dictString = shapesAction_extractTargetByName($shape, $id - 5000);
				$extracted[0] = dict_getStringValue($dictString, "target");
			}
			$target = $extracted[0];
			
			// in case the target extraction encounters an error
			if ($target == "")
			{
				// delete the original mesh
				delete $original;
				progressBar -e -ep $gMainProgressBar;
				return;
			}
			
			$target = `rename $target (shapesMirror_swapSideLabel($sourceName))`;
			string $targetShape[] = `listRelatives -s $target`;
			string $originalHalf[] = {};
		
			if (!$flip)
			{
				// duplicate the original to generate only half of the shape
				$originalHalf = `duplicate $original`;
				string $targetHalf[] = `duplicate $target`;
				string $tempBS[] = `blendShape $targetHalf[0] $originalHalf[0]`;
				blendShape -e -w 0 1 $tempBS[0];
				// delete the targetHalf in order to store the points on the blendshape node
				delete $targetHalf;
				if (`optionVar -q SHAPESMirrorDirection`)
					shapesAction_splitShape $tempBS[0] $original 1 1 0 0 -1;
				else
					shapesAction_splitShape $tempBS[0] $original -1 1 0 0 -1;
				// delete the history to bake the result mesh
				delete -ch $originalHalf[0];
				
				delete $target;
				rename $originalHalf[0] $target;
				
				if (!$copy)
				{
					string $tempHalf[] = `duplicate $target`;
					rename $tempHalf[0] $originalHalf[0];
				}
			}
			
			// reverse the vertex order and flip the geometry
			br_vertexReorder -o $original -t $target -cl $compString;
			
			int $vertCount[] = `polyEvaluate -v $target`;
			// get the selection to restore it later
			string $currentSelection[] = `ls -sl`;
			select -r ($target + ".vtx[0:" + ($vertCount[0] - 1) + "]");
			xform -s $inv[0] $inv[1] $inv[2];
			// restore the selection
			if (size($currentSelection))
				select -r $currentSelection;
			
			// symmetrize if needed
			if (!$flip && !$copy)
			{
				// combine the original half and the mirrored target
				string $result[] = `duplicate $original`;
				string $tempBS[] = `blendShape $originalHalf[0] $target $result`;
				blendShape -e -w 0 1 -w 1 1 $tempBS[0];
				delete -ch $result[0];
				delete $originalHalf[0] $target;
				rename $result[0] $target;
			}
			
			// replace the selected target with the mirrored target
			if ($copy != 1)
				shapesAction_replaceBlendShapeTarget $target "" ($id - 5000) $index 1;
			else
			{
				// add the target to the blendshape node
				float $value = ($id - 5000) / 1000.0;
				string $ibFlag = "";
				if ($inbetweenBool)
					$ibFlag = "-ib";
				string $cmd = "blendShape -e " + $ibFlag + " -t " + $gShapes_skinMesh + " " + $index + " " + $target + " " + $value + " " + $gShapes_bsNode;
				eval $cmd;
				$inbetweenBool = 1;
				delete $target;
			}
		}
		//
		// position based mirror
		// 
		else
		{
			string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
			
			if ($copy == 1)
			{
				string $sourceName = dict_getStringValue($gShapes_bsData[$gShapes_index], "target");
				$target = shapesMirror_swapSideLabel($sourceName);
				string $attrList[] = shapesAction_newChannelName($gShapes_bsNode, $target);
				if ($attrList[1] != "")
					$target = $attrList[1];
			}
			
			int $dir = `optionVar -q SHAPESMirrorDirection`;
			int $mirrorResult = `br_blendShapeMirrorTarget	-axis $axis 
															-direction $dir 
															-flip $flip 
															-sourceIndex $gShapes_targetIndex 
															-inbetween $inbetweenBool 
															-targetIndex $index 
															-node $gShapes_bsNode 
															-mesh $gShapes_skinMesh 
															-originalMesh $intermediate 
															-type $copy 
															-targetPosition $id 
															-targetName $target 
															-tolerance $tolerance`;
			
			if ($copy == 1)
				$inbetweenBool = 1;
			
			// interrupt if the returned reversed point list does not match the original point list length
			if (!$mirrorResult)
			{
				progressBar -e -ep $gMainProgressBar;
				
				// restore the symmetry setting
				symmetricModelling -e -s `optionVar -q SHAPESSymmetricModelingState`;
				
				return;
			}
		}
		progressBar -e -s 1 $gMainProgressBar;
	}
	
	// delete the original mesh
	if ($orderBasedMirror)
		delete $original;
	
	if ($copy == 1)
		shapesMirror_completeRelationships $target $center;
	
	progressBar -e -ep $gMainProgressBar;
	
	// restore the symmetry setting
	symmetricModelling -e -s `optionVar -q SHAPESSymmetricModelingState`;
}


global proc int shapesMirror_mirrorDriverSettings()
{
	//
	// mirrors the shape driver settings
	// and returns a center bool based on the settings
	//
	global int $gShapes_centerMirrorState;
	
	int $center = 0;
	// set the mirrored driver settings
	if (`optionMenu -q -sl shpUI_shapeDriverOption` != 1)
	{
		int $result[] = shapesDriver_performMirrorDriverSettings();
		if ($result[0] == -1)
		{
			shapesMain_refreshTargetList;
			$gShapes_centerMirrorState = -1;
			error "Unable to find the mirror node for the shape driver";
		}
		else
			$center = $result[1];
	}
	return $center;
}


global proc shapesMirror_completeRelationships( string $target, int $center )
{
	//
	// complete the mirror process by creating related shape drivers,
	// sequences and combos
	//
	global int $gShapes_clearSliderFrame;
	global int $gShapes_createSequence;
	global int $gShapes_index;
	global string $gShapes_bsNode;
	global string $gShapes_previousTarget;
	global string $gShapes_selectedTarget;
	
	// selecting the new target and rebuilding the ui is not possible
	// because rebuilding the ui also deletes the popup menu which is used
	// to call the mirroring and this leads to a crash
	// as a workaround the re-building of the slider frame is bypassed
	// which is not needed anyway for the mirror process as this doesn't change
	// the slider frame content
	// the variable is used in buildTargetSlider
	$gShapes_clearSliderFrame = 0;
	
	$gShapes_previousTarget = $gShapes_selectedTarget;
	// add the weight driver
	string $driverList[] = shapesDriver_getConnectedWeightDriver($gShapes_selectedTarget);
	if (size($driverList))
	{
		string $sequence = shapesDriver_getShapeSequence($gShapes_selectedTarget);
		string $tgts[] = dict_getValueArray($sequence, "targets");
		if ($sequence != "" && !size($tgts))
			$sequence = "";
		
		if ($sequence == "" || (size($tgts) && $tgts[size($tgts) - 1] == $gShapes_selectedTarget))
		{
			string $driverName = shapesDriver_createWeightDriver($target, 1, $center);
			if ($driverName != "")
			{
				string $cmd = shapesDriver_setGetWeightDriverBlendCurve(0, $driverName);
				eval $cmd;
			}
		}
		
		if ($gShapes_createSequence)
		{
			string $queryPlug = shapesMain_getQueryPlug(shapesMirror_swapSideLabel($gShapes_selectedTarget));
			string $plug[] = `listConnections -s 1 -d 0 -p 1 -sh 1 $queryPlug`;
			if (size($plug))
			{
				string $targetList[];
				for ($t in $tgts)
					$targetList[size($targetList)] = shapesMirror_swapSideLabel($t);
				float $values[] = dict_getFloatValueArray($sequence, "values");
				int $tan = dict_getValue($sequence, "tangents");
				shapesDriver_performCreateSequence $plug[0] $values $targetList $tan 1 0 {} 0;
			}
			else
				error ("Unable to create the sequence because " + $gShapes_bsNode + "." + $target + " seems to have missing connections");
		}
	}
	shapesCombo_mirrorCombo $target;	
	
	shapesMain_autoOrderNewTarget $target $gShapes_previousTarget 1 1;
	shapesMain_listBlendShapeTargets 1;
	int $ids[] = shapesMain_getShapeIds(0, {$gShapes_previousTarget});
	$gShapes_index = $ids[0];
	
	// re-select the previous target
	treeView -e -cs shpUI_targetTree;
	treeView -e -si $gShapes_previousTarget 1 shpUI_targetTree;
	
	$gShapes_clearSliderFrame = 1;
}


global proc string shapesMirror_mirrorAxisString()
{
	//
	// build the axis string from the mirror setting
	//
	string $axis = "";
	int $dirVal = `optionVar -q SHAPESMirrorAxis`;
	
	// make sure the setting is a 1-based value
	// due to the changes to the preferences in version 3.0_b020
	if ($dirVal == 0)
		$dirVal = 1;
	
	if ($dirVal == 1)
		$axis = "x";
	else if ($dirVal == 2)
		$axis = "y";
	else if ($dirVal == 3)
		$axis = "z";
	return $axis;
}


global proc string shapesMirror_swapSideLabel( string $name )
{
	//
	// replace the side identifier with the opposite side
	//
	global string $gShapes_sideIdentifier;
	
	$gShapes_sideIdentifier = "";
	
	int $found = -1;
	string $identifier[] = shapesUI_getUserIdentifierList();
	string $left[] = stringToStringArray($identifier[0], ", ");
	string $right[] = stringToStringArray($identifier[1], ", ");
	for ($i = 0; $i < size($left); $i ++)
	{
		// embedded identifier
		if (startsWith($left[$i], "_") && endsWith($left[$i], "_"))
		{
			if (`gmatch $name ("*" + $left[$i] + "*")` && $found == -1)
			{
				string $replaced = substitute($left[$i], $name, "%");
				string $items[] = stringToStringArray($replaced, "%");
				if (size($items) == 2)
				{
					$name = $items[0] + $right[$i] + $items[1];
					$found = $i;
					$gShapes_sideIdentifier = "_R";
				}
			}
			else if (`gmatch $name ("*" + $right[$i] + "*")` && $found == -1)
			{
				string $replaced = substitute($right[$i], $name, "%");
				string $items[] = stringToStringArray($replaced, "%");
				if (size($items) == 2)
				{
					$name = $items[0] + $left[$i] + $items[1];
					$found = $i;
					$gShapes_sideIdentifier = "_L";
				}
			}
		}
		else
		{
			if (startsWith($name, $left[$i]) && $found == -1)
			{
				$name = `substring $name (size($left[$i]) + 1) (size($name))`;
				$name = $right[$i] + $name;
				$found = $i;
				$gShapes_sideIdentifier = $right[$i];
			}
			else if (startsWith($name, $right[$i]) && $found == -1)
			{
				$name = `substring $name (size($right[$i]) + 1) (size($name))`;
				$name = $left[$i] + $name;
				$found = $i;
				$gShapes_sideIdentifier = $left[$i];
			}
		}
	}
	if ($found == -1)
	{
		for ($i = 0; $i < size($left); $i ++)
		{
			if (endsWith($name, $left[$i]) && $found == -1)
			{
				$name = `substring $name 1 (size($name) - size($left[$i]))`;
				$name += $right[$i];
				$found = $i;
				$gShapes_sideIdentifier = $right[$i];
			}
			else if (endsWith($name, $right[$i]) && $found == -1)
			{
				$name = `substring $name 1 (size($name) - size($right[$i]))`;
				$name += $left[$i];
				$found = $i;
				$gShapes_sideIdentifier = $left[$i];
			}
		}
	}
	return $name;
}


global proc shapesMirror_verifySymmetry()
{
	//
	// check if symmetry information exists on the selected node
	// and switch the ui accordingly
	//
	string $shape = shapesMain_getShapeNode();
	// in case the mesh has multiple shells it is indicated by an attribute
	// and order based mirror must be turned off
	if (`attributeQuery -n $shape -ex SHAPES_positionBasedMirror`)
	{
		shapesUI_setOrderBasedMirror 0;
		shapesUI_setSymmetryEdgeButtonDefault;
	}
	else
	{
		if (`attributeQuery -n $shape -ex SHAPESSymmetry`)
			shapesMirror_defineSymmetryCenter 0 1;
	}
}


global proc shapesMirror_defineSymmetryCenter( int $custom, int $newMeshLoaded )
{
	//
	// initialize the process for finding the symmetry center
	// and store the components on the original shape node
	//
	int $state = $custom;
	
	string $shape = shapesMain_getShapeNode();
	if ($shape != "")
	{
		int $valid = shapesMain_verifyMeshShell($shape);
		if ($valid)
		{
			// if the symmetry components are already defined use them
			string $compList = shapesMirror_getShapeSymmetryComponents(1);
			if (!$custom && $compList != "")
				;
			else
				$compList = shapesMirror_findCenterEdge($shape, $custom);
	
			// Maya 2016: after setting the new symmetry center the mesh stays in vertex mode
			// hence the command to return to a non-selected object
			if (`shapesGlobal_getMayaVersion` >= 2016)
				eval("source dagMenuProc; maintainActiveChangeSelectMode " + $shape);
	
			if ($compList != "")
			{
			
				if (`radioCollection -ex shpUI_mirrorTypeRadioCollection` && `radioButton -q -sl shpUI_positionBasedMirrorRadio`)
					$state = 0;
				else
				{
					string $items[] = stringToStringArray($compList, ",");
		
					if (size($items) == 5)
					{
						string $buttonCmd = "select -r " + $shape + ".e[" + $items[0] + "]";
						string $buttonLabel = "Current: " + $items[0] + "";
						optionVar -sv SHAPESSymmetryButtonLabel $buttonLabel;
						optionVar -sv SHAPESSymmetryButtonCommand $buttonCmd;
						shapesUI_setSymmetryEdgeButton;
						$state = 1;
			
						// make sure that order based mirroring is selected
						// when either a custom edge has been defined or when a new mesh
						// with component information is loaded
						if ($custom || $newMeshLoaded)
							shapesUI_setOrderBasedMirror 1;
					}
					else
					{
						shapesUI_setSymmetryEdgeButtonDefault;
						optionVar -sv SHAPESOrderBasedMirrorInfo "Error: Could not find all components for defining the symmetry center";
						shapesUI_setOrderBasedMirrorInfo 1 0;
						shapesUI_setOrderBasedMirror 0;
						$state = 0;
					}
				}
			}
			else
			{
				//warning "Unable to find the symmetry center. Position based mirroring will be used for this mesh.";
				shapesUI_setOrderBasedMirror 0;
				$state = 0;
			}
	
			// save the components to the shape node
			shapesMain_addStringAttribute $shape "SHAPESSymmetry";
			setAttr ($shape + "." + "SHAPESSymmetry") -type "string" $compList;
		}
	}
	
	optionVar -iv SHAPESOrderBasedMirror $state;
}


global proc string shapesMirror_getShapeSymmetryComponents( int $edge )
{
	//
	// read the stored component string on the shape node
	//
	string $shape = shapesMain_getShapeNode();
	if (`attributeQuery -n $shape -ex SHAPESSymmetry`)
	{
		string $compString = `getAttr ($shape + ".SHAPESSymmetry")`;
		string $compList[] = stringToStringArray($compString, ",");
		if (!$edge)
		{
			// remove the first entry, which is the symmetry edge
			stringArrayRemoveAtIndex(0, $compList);
			// rebuild the string
			$compString = stringArrayToString($compList, ",");
		}
		return $compString;
	}
	return "";
}


global proc string shapesMirror_findCenterEdge(string $shape, int $customEdge )
{
	//
	// find an edge at the symmetry center of the mesh and get the connected vertices
	// and faces for the reorder process
	// can be called with a selected edge if the process fails and user input is needed
	// returns a string of components: edge, face1, face2, vertex1, vertex2
	//
	int $compList[];
	
	if (!$customEdge)
	{
		int $dirVal = `optionVar -q SHAPESMirrorAxis`;
		// make sure the setting is a 1-based value
		// due to the changes to the preferences in version 3.0_b020
		if ($dirVal == 0)
			$dirVal = 1;
		
		string $axis = "x";
		if ($dirVal == 2)
			$axis = "y";
		if ($dirVal == 3)
			$axis = "z";
		
		float $tolerance = `optionVar -q SHAPESMirrorToleranceValue`;
		
		$compList = `br_polyGetCenterEdge -ax $axis -tol $tolerance $shape`;
		
		if (size($compList) == 0)
		{
			shapesUI_setOrderBasedMirrorInfo 1 0;
			return "";
		}
	}
	else
	{
		$compList = {-1, -1, -1, -1, -1};
		
		string $sel[] = `ls -sl -fl`;
		if (!size($sel))
			return "";
		if (!`gmatch $sel[0] "*.e\\[*"`)
			error "The selection is not an edge";
		string $temp[] = stringToStringArray($sel[0], "[");
		string $idString = `substring $temp[1] 1 (size($temp[1]) - 1)`;
		// get the edge vertices
		string $vertices[] = `polyInfo -ev ($shape + ".e[" + $idString + "]")`;
		string $tempString = substitute("EDGE", $vertices[0], "");
		string $vertexList[] = stringToStringArray($tempString, " :\n\r");
		
		$compList[0] = $idString;
		$compList[3] = $vertexList[2];
		$compList[4] = $vertexList[1];
		
		select -cl;
		
		// get the faces of the center edge
		string $faces[] = `polyInfo -ef ($shape + ".e[" + $compList[0] + "]")`;
		$tempString = substitute("EDGE", $faces[0], "");
		string $faceList[] = stringToStringArray($tempString, " :\n\r");
		stringArrayRemoveAtIndex(0, $faceList);
	
		if (size($faceList) != 2)
		{
			optionVar -sv SHAPESOrderBasedMirrorInfo "Error: Unable to find a center edge to define the symmetry";
			shapesUI_setOrderBasedMirrorInfo 1 0;
			return "";
		}
	
		$compList[1] = $faceList[0];
		$compList[2] = $faceList[1];
	}
		
	return shapesArray_intArrayToString($compList, ",");
}


global proc SHAPES_mirror(){}
