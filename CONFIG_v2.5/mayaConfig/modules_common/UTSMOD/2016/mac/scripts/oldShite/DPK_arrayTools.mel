//----------------------------------------------------------------------------
// Copyright © 2003, Daniel Pook-Kolb
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   - Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   - Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
//   - Neither the name of the author nor the names of its contributors may be
//     used to endorse or promote products derived from this software without
//     specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//----------------------------------------------------------------------------
//
//
//--------------------------------------------------------------------------//
//  DPK_arrayTools.mel
//
//  Author:			Daniel Pook-Kolb
//					daniel@dpk.stargrav.com
//
//  Version:		0.14
//  Date:			Jun 24, 2004
//
//  Description:    This is a collection of little useful procedures that will
//					convert, reverse... different array types. Note that some
//					procedures actually change the given array argument.
//
//  Usage:			...
//
//  Return:			...
//
//  Files Needed:   none
//
//--------------------------------------------------------------------------//


//------------------------------
//------------------------------
//
//  PART 1: STRING Procedures {{{1
//
//------------------------------
//------------------------------

////////////////////////////////
// DPK_at_string_getBuild {{{2
//
// Returns the string that will create the exact same array if evaluated.
////////////////////////////////
global proc string DPK_at_string_getBuild (string $array[], string $name,
										   int $max)
////////////////////////////////
{
//--//
if (!size($array))
	return "";

string $cmd = ("$"+$name+" = {");
string $tempCmd = $cmd;
int $size = size($cmd);
string $space;
int $x;
for ($x = 0; $x < $size; ++$x)
	$space += " ";

int $inc;
$size = size($array);
for ($x = 0; $x < $size; ++$x)
{
	$tempCmd += ("\""+$array[$x]+"\", ");
	if (size($tempCmd) >= $max && $inc)
	{
		$tempCmd = $space;
		$tempCmd += ("\""+$array[$x]+"\", ");
		$cmd = strip($cmd);
		$cmd += ("\n"+$space);
		$inc = 0;
	}

	$cmd += ("\""+$array[$x]+"\", ");
	++$inc;
}

// Remove the triling space.
$cmd = strip($cmd);

// Remove the last comma from $cmd.
$cmd = substring($cmd, 1, size($cmd) - 1);

$cmd += "};";

return $cmd;
//--//
}
//---- end "DPK_at_string_getBuild" ----// }}}2


//------------------------------
// DPK_L_stringMoveUp {{{2
//------------------------------
proc int DPK_L_stringMoveUp (string $allItems[], string $selItems[])
//------------------------------
{
//--//
string $tmp;
int $x, $exch, $count;
for ($x = 0; $x < size($allItems); ++$x)
{
	if (`DPK_at_string_eleIndex $selItems $allItems[$x]` != -1)
	{
		if ($exch)
		{
			$tmp = $allItems[$x-1];
			$allItems[$x-1] = $allItems[$x];
			$allItems[$x] = $tmp;
			++$count;
		}
	}
	else
		$exch = 1;
}
return $count;
//--//
}
//---- end "DPK_L_stringMoveUp" ----// }}}2


//------------------------------
// DPK_L_stringMoveDown {{{2
//------------------------------
proc int DPK_L_stringMoveDown (string $allItems[], string $selItems[])
//------------------------------
{
//--//
int $x, $exch, $count;
for ($x = size($allItems)-1; $x >= 0; --$x)
{
	if (`DPK_at_string_eleIndex $selItems $allItems[$x]` != -1)
	{
		if ($exch)
		{
			string $tmp = $allItems[$x+1];
			$allItems[$x+1] = $allItems[$x];
			$allItems[$x] = $tmp;
			++$count;
		}
	}
	else
		$exch = 1;
}
return $count;
//--//
}
//---- end "DPK_L_stringMoveDown" ----// }}}2


////////////////////////////////
// DPK_at_string_move {{{2
//
// Moves all occurecies of the items $selItems in $allItems either one idex up
// (if $dir is 1) or down (if $dir is -1). Returns the number of items that
// could be moved.
////////////////////////////////
global proc int DPK_at_string_move (string $allItems[], string $selItems[],
									int $dir)
////////////////////////////////
{
//--//
int $x, $count;
if ($dir < 0)
	for ($x = 0; $x > $dir; --$x)
		$count += `DPK_L_stringMoveUp $allItems $selItems`;
else if ($dir > 0)
	for ($x = 0; $x < $dir; ++$x)
		$count += `DPK_L_stringMoveDown $allItems $selItems`;
return $count;
//--//
}
//---- end "DPK_at_string_move" ----// }}}2


////////////////////////////////
// DPK_at_string_eleIndex {{{2
//
// Tries to find the given element in the array and returnes it's index. If
// the element could not be found, -1 is returned.
////////////////////////////////
global proc int DPK_at_string_eleIndex (string $array[], string $element)
////////////////////////////////
{
//--//
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
{
	if ($array[$x] == $element)
		return $x;
}
return -1;
//--//
}
//---- end "DPK_at_string_eleIndex" ----// }}}2


////////////////////////////////
// DPK_at_string_remIndex {{{2
//
// Removes and returns the given index position of the $array.
////////////////////////////////
global proc string DPK_at_string_remIndex (string $array[], int $index)
////////////////////////////////
{
//--//
string $nArray[], $value;
int $x, $inc, $size = size($array);
for ($x = 0; $x < $size; ++$x)
{
	if ($x != $index)
		$nArray[$inc++] = $array[$x];
	else
		$value = $array[$x];
}
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_string_remIndex" ----// }}}2


////////////////////////////////
// DPK_at_string_pop {{{2
//
// Removes and returns the last element of the given $array.
////////////////////////////////
global proc string DPK_at_string_pop (string $array[])
////////////////////////////////
{
//--//
string $nArray[], $value;
int $x, $size = size($array);
for ($x = 0; $x < $size - 1; ++$x)
	$nArray[$x] = $array[$x];

$value = $array[$x];
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_string_pop" ----// }}}2


////////////////////////////////
// DPK_at_string_shift {{{2
//
// Removes and returnes the first element of the given $array.
////////////////////////////////
global proc string DPK_at_string_shift (string $array[])
////////////////////////////////
{
//--//
string $nArray[], $value;
int $x, $size = size($array);
for ($x = 1; $x < $size; ++$x)
	$nArray[$x - 1] = $array[$x];

$value = $array[0];
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_string_shift" ----// }}}2


////////////////////////////////
// DPK_at_string_addMissing {{{2
//
// Appends every element of $array2 to $array1 that is not already included in
// it. Returns the new size of $array1.
////////////////////////////////
global proc int DPK_at_string_addMissing (string $array1[], string $array2[])
////////////////////////////////
{
//--//
// Iterate through the elements of $array2.
int $x, $inc = size($array1), $size = size($array2);
for ($x = 0; $x < $size; ++$x)
{
	// Check whether the current element is already included in $array1.
	if (`DPK_at_string_eleIndex $array1 $array2[$x]` == -1) {
		// No it isn't, so we append it to it.
		$array1[$inc++] = $array2[$x];
	}
}

return $inc;
//--//
}
//---- end "DPK_at_string_addMissing" ----// }}}2


////////////////////////////////
// DPK_at_string_reverse {{{2
//
// Reverses the order of $array.
////////////////////////////////
global proc DPK_at_string_reverse (string $array[])
////////////////////////////////
{
//--//
string $tmp;
int $x, $y;
int $size = size($array);
for ($x = $size - 1, $y = 0; $x >= (($size + 1) / 2); --$x, ++$y)
{
	$tmp       = $array[$y];
	$array[$y] = $array[$x];
	$array[$x] = $tmp;
}
//--//
}
//---- end "DPK_at_string_reverse" ----// }}}2


////////////////////////////////
// DPK_at_string_sort_int {{{2
//
// Returns a sorted version of the given $array. The sorting is done by
// creating a relationship between the elements in $array and the elements in
// $old. $new should contain the new order of the elements of $old. The $array
// will be sorted based on this changed order, so that its elements correspond
// to the elements in $new.
////////////////////////////////
global proc string[] DPK_at_string_sort_int (string $array[],
											 int    $old[],
											 int    $new[])
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

// Iterate through the $new array. For each element of $new, we find the index
// at which this element is stored in $old. This index is then used to store
// the element of $array in the $sorted array. Since we allow the $old and
// $new array's to have non-unique elements (two or more elements with the
// same value), we have to do some extra steps to find the correct element.
string $sorted[];
int $x, $y, $i, $inc, $count[];
for ($x = 0; $x < $sizeNew; ++$x)
{
	// Reset the $i variable (for later use).
	$i = 0;

	// Iterate through the $old array and find the element that equals
	// $new[$x]. The index of this element is the index of the element of
	// $array that is added to the $sorted array.
	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			// Element $y has the desired value. Check whether we're at the
			// right element.
			if ($i == $count[$new[$x]]) {
				// Yes, this element is the one we're looking for, so we copy
				// element $y from the $array to $sorted.
				$sorted[$inc++] = $array[$y];

				// We increment the corresponding element in $count so that we
				// know how often we've added it.
				$count[$new[$x]] += 1;

				// This loop is finished, so we continue with the next $x by
				// breaking this inner loop.
				break;
			}

			// We've skipped element $y since $new[$x] is not the
			// $count[$y]'th occurence in $old. Increment $i, so that we know
			// how many elements we still have to skip.
			++$i;
		}
	}
}

// Return the sorted array.
return $sorted;
//--//
}
//---- end "DPK_at_string_sort_int" ----// }}}2


////////////////////////////////
// DPK_at_string_sort_float {{{2
//
// Same as above, but takes float arrays for the mapping.
////////////////////////////////
global proc string[] DPK_at_string_sort_float ( string $array[],
												float  $old[],
												float  $new[] )
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

// Iterate through the $new array. For each element of $new, we find the index
// at which this element is stored in $old. This index is then used to store
// the element of $array in the $sorted array. Since we allow the $old and
// $new array's to have non-unique elements (two or more elements with the
// same value), we have to do some extra steps to find the correct element.
string $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	// Count the number of elements of $new that have the same value as
	// element $x, starting from element 0 up to element $x. This count ($c)
	// will be used to skip the elements of $old.
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	// Iterate through the $old array and find the element that equals
	// $new[$x]. The index of this element is the index of the element of
	// $array that is added to the $sorted array.
	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			// Element $y has the desired value, so we check, whether we need
			// to skip it.
			if (!$c) {
				// No, this element is the one we're looking for, so we copy
				// element $y from the $array to $sorted and break this loop.
				$sorted[$inc++] = $array[$y];
				break;
			}

			// We skipped element $y since $new[$x] is not the $c'th occurence
			// in $old. Decrement $c, so that we know how many elements we
			// still have to skip.
			--$c;
		}
	}
}

// Return the sorted array.
return $sorted;
//--//
}
//---- end "DPK_at_string_sort_float" ----// }}}2


////////////////////////////////
// DPK_at_string_sort_string {{{2
//
// Same as above, but takes string arrays for the mapping.
////////////////////////////////
global proc string[] DPK_at_string_sort_string (string $array[],
												string $old[],
												string $new[])
////////////////////////////////
{
//--//
// (For comments see DPK_at_string_sort_float)
int $sizeOld = size($old);
int $sizeNew = size($new);

string $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_string_sort_string" ----// }}}2


////////////////////////////////
// DPK_at_string_sort_vector {{{2
////////////////////////////////
global proc string[] DPK_at_string_sort_vector (string $array[],
												vector $old[],
												vector $new[])
////////////////////////////////
{
//--//
// (For comments see DPK_at_string_sort_float)
int $sizeOld = size($old);
int $sizeNew = size($new);

string $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_string_sort_vector" ----// }}}2


////////////////////////////////
// DPK_at_string_prefix {{{2
//
// Adds the $val before every element of $array.
////////////////////////////////
global proc DPK_at_string_prefix (string $array[], string $val)
////////////////////////////////
{
//--//
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
	$array[$x] = ($val+$array[$x]);
//--//
}
//---- end "DPK_at_string_prefix" ----// }}}2


////////////////////////////////
// DPK_at_string_suffix {{{2
//
// Adds the $val after every element of $array.
////////////////////////////////
global proc DPK_at_string_suffix (string $array[], string $val)
////////////////////////////////
{
//--//
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
	$array[$x] = ($array[$x]+$val);
//--//
}
//---- end "DPK_at_string_suffix" ----// }}}2


////////////////////////////////
// DPK_at_string_join {{{2
//
// Creates a string containing all elements of $array, separated by $sep.
////////////////////////////////
global proc string DPK_at_string_join (string $sep, string $array[])
////////////////////////////////
{
//--//
string $text;
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
	$text += ($sep+$array[$x]);

return $text;
//--//
}
//---- end "DPK_at_string_join" ----// }}}2


////////////////////////////////
// DPK_at_string_break {{{2
//
// This procedure takes a string and returns an array of it's characters.
////////////////////////////////
global proc string[] DPK_at_string_break (string $string)
////////////////////////////////
{
//--//
int $size = size($string);
int $x;
string $array[];
for ($x = 1; $x <= $size; ++$x)
	$array[$x - 1] = `substring $string $x $x`;
return $array;
//--//
}
//---- end "DPK_at_string_break" ----// }}}2


////////////////////////////////
// DPK_at_string_to_float {{{2
////////////////////////////////
global proc float[] DPK_at_string_to_float (string $array[])
////////////////////////////////
{
//--//
float $flArr[];
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
	$flArr[$x] = $array[$x];

return $flArr;
//--//
}
//---- end "DPK_at_string_to_string" ----// }}}2


////////////////////////////////
// DPK_at_string_to_int {{{2
////////////////////////////////
global proc int[] DPK_at_string_to_int (string $array[])
////////////////////////////////
{
//--//
int $iArr[];
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
	$iArr[$x] = $array[$x];

return $iArr;
//--//
}
//---- end "DPK_at_string_to_int" ----// }}}2


////////////////////////////////
// DPK_at_string_to_vector {{{2
////////////////////////////////
global proc vector[] DPK_at_string_to_vector (string $array[])
////////////////////////////////
{
//--//
vector $vArr[];
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
	$vArr[$x] = $array[$x];

return $vArr;
//--//
}
//---- end "DPK_at_string_to_vector" ----// }}}2


// }}}1


//------------------------------
//------------------------------
//
//  PART 2: VECTOR Procedures {{{1
//
//------------------------------
//------------------------------

////////////////////////////////
// DPK_at_vector_eleIndex {{{2
////////////////////////////////
global proc int DPK_at_vector_eleIndex (vector $array[], vector $element)
////////////////////////////////
{
//--//
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
{
	if ($array[$x] == $element)
		return $x;
}
return -1;
//--//
}
//---- end "DPK_at_vector_eleIndex" ----// }}}2


////////////////////////////////
// DPK_at_vector_remIndex {{{2
////////////////////////////////
global proc vector DPK_at_vector_remIndex (vector $array[], int $index)
////////////////////////////////
{
//--//
vector $nArray[], $value;
int $x, $inc, $size = size($array);
for ($x = 0; $x < $size; ++$x)
{
	if ($x != $index)
		$nArray[$inc++] = $array[$x];
	else
		$value = $array[$x];
}
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_vector_remIndex" ----// }}}2


////////////////////////////////
// DPK_at_vector_pop {{{2
////////////////////////////////
global proc vector DPK_at_vector_pop (vector $array[])
////////////////////////////////
{
//--//
vector $nArray[], $value;
int $x;
for ($x = 0; $x < size($array) - 1; ++$x)
	$nArray[$x] = $array[$x];

$value = $array[$x];
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_vector_pop" ----// }}}2


////////////////////////////////
// DPK_at_vector_shift {{{2
////////////////////////////////
global proc vector DPK_at_vector_shift (vector $array[])
////////////////////////////////
{
//--//
vector $nArray[], $value;
int $x;
for ($x = 1; $x < size($array); ++$x)
	$nArray[$x - 1] = $array[$x];

$value = $array[0];
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_vector_shift" ----// }}}2


////////////////////////////////
// DPK_at_vector_catenate {{{2
//
// Appends the elements of $array2 to the end of $array1 and returns the new
// size of $array1.
////////////////////////////////
global proc int DPK_at_vector_catenate (vector $array1[], vector $array2[])
////////////////////////////////
{
//--//
int $inc = size($array1);
int $x;
for ($x = 0; $x < size($array2); ++$x) {
	$array1[$inc++] = $array2[$x];
}

return $inc;
//--//
}
//---- end "DPK_at_vector_catenate" ----// }}}2


////////////////////////////////
// DPK_at_vector_intersect {{{2
//
// Intersects the two arrays and returns an array containing the elements that
// exist in both. The order of the returned elements is their order in the
// first array.
////////////////////////////////
global proc vector[] DPK_at_vector_intersect (  vector $array1[],
												vector $array2[]  )
////////////////////////////////
{
//--//
int $x, $inc, $size = size($array1);
vector $intersect[];
for ($x = 0; $x < $size; ++$x)
{
	// Check if the current element of the $array1 is part of $array2 and
	// whether it is added to $intersect.
	if (`DPK_at_vector_eleIndex $array2    $array1[$x]` != -1 &&
		`DPK_at_vector_eleIndex $intersect $array1[$x]` == -1)
	{
		// The current element of $array1 exists in both arrays and is not yet
		// added to $intersect.
		$intersect[$inc++] = $array1[$x];
	}
}

return $intersect;
//--//
}
//---- end "DPK_at_vector_intersect" ----// }}}2


////////////////////////////////
// DPK_at_vector_addMissing {{{2
//
// Appends every element of $array2 to $array1 that is not already included in
// it. Returns the new size of $array1.
////////////////////////////////
global proc int DPK_at_vector_addMissing (vector $array1[], vector $array2[])
////////////////////////////////
{
//--//
// Iterate through the elements of $array2.
int $x, $inc = size($array1), $size = size($array2);
for ($x = 0; $x < $size; ++$x)
{
	// Check whether the current element is already included in $array1.
	if (`DPK_at_vector_eleIndex $array1 $array2[$x]` == -1) {
		// No it isn't, so we append it to it.
		$array1[$inc++] = $array2[$x];
	}
}

return $inc;
//--//
}
//---- end "DPK_at_vector_addMissing" ----// }}}2


////////////////////////////////
// DPK_at_vector_reverse {{{2
////////////////////////////////
global proc DPK_at_vector_reverse (vector $array[])
////////////////////////////////
{
//--//
vector $tmp;
int $x, $y;
int $size = size($array);
for ($x = $size - 1, $y = 0; $x >= (($size + 1) / 2); --$x, ++$y)
{
	$tmp       = $array[$y];
	$array[$y] = $array[$x];
	$array[$x] = $tmp;
}
//--//
}
//---- end "DPK_at_vector_reverse" ----// }}}2


////////////////////////////////
// DPK_at_vector_sort_int {{{2
////////////////////////////////
global proc vector[] DPK_at_vector_sort_int (vector $array[],
											 int    $old[],
											 int    $new[])
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

vector $sorted[];
int $x, $y, $i, $inc, $count[];
for ($x = 0; $x < $sizeNew; ++$x)
{
	$i = 0;

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if ($i == $count[$new[$x]]) {
				$sorted[$inc++] = $array[$y];
				$count[$new[$x]] += 1;
				break;
			}
			++$i;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_vector_sort_int" ----// }}}2


////////////////////////////////
// DPK_at_vector_sort_float {{{2
////////////////////////////////
global proc vector[] DPK_at_vector_sort_float ( vector $array[],
												float  $old[],
												float  $new[] )
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

vector $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_vector_sort_float" ----// }}}2


////////////////////////////////
// DPK_at_vector_sort_string {{{2
////////////////////////////////
global proc vector[] DPK_at_vector_sort_string (vector $array[],
												string $old[],
												string $new[])
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

vector $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_vector_sort_string" ----// }}}2


////////////////////////////////
// DPK_at_vector_sort_vector {{{2
////////////////////////////////
global proc vector[] DPK_at_vector_sort_vector (vector $array[],
												vector $old[],
												vector $new[])
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

vector $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_vector_sort_vector" ----// }}}2


////////////////////////////////
// DPK_at_vector_addVector {{{2
//
// Adds the $val vector to every element of $array.
////////////////////////////////
global proc DPK_at_vector_addVector (vector $array[], vector $val)
////////////////////////////////
{
//--//
int $x;
for ($x = 0; $x < size($array); ++$x)
	$array[$x] += $val;
//--//
}
//---- end "DPK_at_vector_addVector" ----// }}}2


////////////////////////////////
// DPK_at_vector_addFloat {{{2
//
// Adds the float $val to every component of every vector in $array.
////////////////////////////////
global proc DPK_at_vector_addFloat (vector $array[], float $val)
////////////////////////////////
{
//--//
int $x;
vector $temp;
for ($x = 0; $x < size($array); ++$x)
{
	$temp = $array[$x];
	$array[$x] = << (($temp.x) + $val),
					(($temp.y) + $val),
					(($temp.z) + $val) >>;
}
//--//
}
//---- end "DPK_at_vector_addFloat" ----// }}}2


////////////////////////////////
// DPK_at_vector_join {{{2
////////////////////////////////
global proc string DPK_at_vector_join (string $sep, vector $array[])
////////////////////////////////
{
//--//
string $text;
int $x;
vector $temp;
for ($x = 0; $x < size($array); ++$x)
{
	$temp = $array[$x];
	$text += ($sep+"<< "+
			 ($temp.x)+", "+
			 ($temp.y)+", "+
			 ($temp.z)
			 +" >>");
}

return $text;
//--//
}
//---- end "DPK_at_vector_join" ----// }}}2


////////////////////////////////
// DPK_at_vector_to_string {{{2
////////////////////////////////
global proc string[] DPK_at_vector_to_string (vector $array[])
////////////////////////////////
{
//--//
string $strArr[];
int $x;
vector $temp;
for ($x = 0; $x < size($array); ++$x)
{
	$temp = $array[$x];
	$strArr[$x] = ("<< "+($temp.x)+", "+
						 ($temp.y)+", "+
						 ($temp.z)+" >>");
}

return $strArr;
//--//
}
//---- end "DPK_at_vector_to_string" ----// }}}2


////////////////////////////////
// DPK_at_vector_to_int {{{2
////////////////////////////////
global proc int[] DPK_at_vector_to_int (vector $array[])
////////////////////////////////
{
//--//
int $iArr[];
int $x;
for ($x = 0; $x < size($array); ++$x)
	$iArr[$x] = mag($array[$x]);

return $iArr;
//--//
}
//---- end "DPK_at_vector_to_int" ----// }}}2


////////////////////////////////
// DPK_at_vector_to_float {{{2
////////////////////////////////
global proc float[] DPK_at_vector_to_float (vector $array[])
////////////////////////////////
{
//--//
float $flArr[];
int $x;
for ($x = 0; $x < size($array); ++$x)
	$flArr[$x] = mag($array[$x]);

return $flArr;
//--//
}
//---- end "DPK_at_vector_to_vector" ----// }}}2


// }}}1


//------------------------------
//------------------------------
//
//  PART 3: FLOAT Procedures {{{1
//
//------------------------------
//------------------------------

////////////////////////////////
// DPK_at_float_eleIndex {{{2
////////////////////////////////
global proc int DPK_at_float_eleIndex (float $array[], float $element)
////////////////////////////////
{
//--//
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
{
	if ($array[$x] == $element)
		return $x;
}
return -1;
//--//
}
//---- end "DPK_at_float_eleIndex" ----// }}}2


////////////////////////////////
// DPK_at_float_remIndex {{{2
////////////////////////////////
global proc float DPK_at_float_remIndex (float $array[], int $index)
////////////////////////////////
{
//--//
float $nArray[], $value;
int $x, $inc, $size = size($array);
for ($x = 0; $x < $size; ++$x)
{
	if ($x != $index)
		$nArray[$inc++] = $array[$x];
	else
		$value = $array[$x];
}
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_float_remIndex" ----// }}}2


////////////////////////////////
// DPK_at_float_pop {{{2
////////////////////////////////
global proc float DPK_at_float_pop (float $array[])
////////////////////////////////
{
//--//
float $nArray[], $value;
int $x;
for ($x = 0; $x < size($array) - 1; ++$x)
	$nArray[$x] = $array[$x];

$value = $array[$x];
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_float_pop" ----// }}}2


////////////////////////////////
// DPK_at_float_shift {{{2
////////////////////////////////
global proc float DPK_at_float_shift (float $array[])
////////////////////////////////
{
//--//
float $nArray[], $value;
int $x;
for ($x = 1; $x < size($array); ++$x)
	$nArray[$x - 1] = $array[$x];

$value = $array[0];
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_float_shift" ----// }}}2


////////////////////////////////
// DPK_at_float_catenate {{{2
//
// Appends the elements of $array2 to the end of $array1 and returns the new
// size of $array1.
////////////////////////////////
global proc int DPK_at_float_catenate (float $array1[], float $array2[])
////////////////////////////////
{
//--//
int $inc = size($array1);
int $x;
for ($x = 0; $x < size($array2); ++$x) {
	$array1[$inc++] = $array2[$x];
}

return $inc;
//--//
}
//---- end "DPK_at_float_catenate" ----// }}}2


////////////////////////////////
// DPK_at_float_intersect {{{2
//
// Intersects the two float arrays and returns an array containing the
// elements that exist in both. The order of the returned elements is their
// order in the first array.
////////////////////////////////
global proc float[] DPK_at_float_intersect (float $array1[], float $array2[])
////////////////////////////////
{
//--//
int $x, $inc, $size = size($array1);
float $intersect[];
for ($x = 0; $x < $size; ++$x)
{
	// Check if the current element of the $array1 is part of $array2 and
	// whether it is added to $intersect.
	if (`DPK_at_float_eleIndex $array2    $array1[$x]` != -1 &&
		`DPK_at_float_eleIndex $intersect $array1[$x]` == -1)
	{
		// The current element of $array1 exists in both arrays and is not yet
		// added to $intersect.
		$intersect[$inc++] = $array1[$x];
	}
}

return $intersect;
//--//
}
//---- end "DPK_at_float_intersect" ----// }}}2


////////////////////////////////
// DPK_at_float_addMissing {{{2
//
// Appends every element of $array2 to $array1 that is not already included in
// it. Returns the new size of $array1.
////////////////////////////////
global proc int DPK_at_float_addMissing (float $array1[], float $array2[])
////////////////////////////////
{
//--//
// Iterate through the elements of $array2.
int $x, $inc = size($array1), $size = size($array2);
for ($x = 0; $x < $size; ++$x)
{
	// Check whether the current element is already included in $array1.
	if (`DPK_at_float_eleIndex $array1 $array2[$x]` == -1) {
		// No it isn't, so we append it to it.
		$array1[$inc++] = $array2[$x];
	}
}

return $inc;
//--//
}
//---- end "DPK_at_float_addMissing" ----// }}}2


////////////////////////////////
// DPK_at_float_reverse {{{2
////////////////////////////////
global proc DPK_at_float_reverse (float $array[])
////////////////////////////////
{
//--//
float $tmp;
int $x, $y;
int $size = size($array);
for ($x = $size - 1, $y = 0; $x >= (($size + 1) / 2); --$x, ++$y)
{
	$tmp       = $array[$y];
	$array[$y] = $array[$x];
	$array[$x] = $tmp;
}
//--//
}
//---- end "DPK_at_float_reverse" ----// }}}2


////////////////////////////////
// DPK_at_float_sort_int {{{2
////////////////////////////////
global proc float[] DPK_at_float_sort_int ( float $array[],
											int   $old[],
											int   $new[] )
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

float $sorted[];
int $x, $y, $i, $inc, $count[];
for ($x = 0; $x < $sizeNew; ++$x)
{
	$i = 0;

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if ($i == $count[$new[$x]]) {
				$sorted[$inc++] = $array[$y];
				$count[$new[$x]] += 1;
				break;
			}
			++$i;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_float_sort_int" ----// }}}2


////////////////////////////////
// DPK_at_float_sort_float {{{2
////////////////////////////////
global proc float[] DPK_at_float_sort_float ( float $array[],
											  float $old[],
											  float $new[] )
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

float $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_float_sort_float" ----// }}}2


////////////////////////////////
// DPK_at_float_sort_string {{{2
////////////////////////////////
global proc float[] DPK_at_float_sort_string (float  $array[],
											  string $old[],
											  string $new[])
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

float $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_float_sort_string" ----// }}}2


////////////////////////////////
// DPK_at_float_sort_vector {{{2
////////////////////////////////
global proc float[] DPK_at_float_sort_vector (float  $array[],
											  vector $old[],
											  vector $new[])
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

float $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_float_sort_vector" ----// }}}2


////////////////////////////////
// DPK_at_float_max {{{2
//
// Returns the index of the element with the highest value.
////////////////////////////////
global proc int DPK_at_float_max (float $array[])
////////////////////////////////
{
//--//
int $x, $max;
for ($x = 0; $x < size($array); ++$x) {
	if ($array[$x] > $array[$max]) {
		$max = $x;
	}
}

return $max;
//--//
}
//---- end "DPK_at_float_max" ----// }}}2


////////////////////////////////
// DPK_at_float_min {{{2
//
// Returns the index of the element with the lowest value.
////////////////////////////////
global proc int DPK_at_float_min (float $array[])
////////////////////////////////
{
//--//
int $x, $max;
for ($x = 0; $x < size($array); ++$x) {
	if ($array[$x] < $array[$max]) {
		$max = $x;
	}
}

return $max;
//--//
}
//---- end "DPK_at_float_min" ----// }}}2


////////////////////////////////
// DPK_at_float_add {{{2
//
// Adds $val to every element of $array.
////////////////////////////////
global proc DPK_at_float_add (float $array[], float $val)
////////////////////////////////
{
//--//
int $x;
for ($x = 0; $x < size($array); ++$x)
	$array[$x] += $val;
//--//
}
//---- end "DPK_at_float_add" ----// }}}2


////////////////////////////////
// DPK_at_float_addArr {{{2
//
// Adds the elements of $val to the elements of $array.
////////////////////////////////
global proc DPK_at_float_addArr (float $array[], float $val[])
////////////////////////////////
{
//--//
int $x;
for ($x = 0; $x < size($array); ++$x)
	$array[$x] += $val[$x];
//--//
}
//---- end "DPK_at_float_addArr" ----// }}}2


////////////////////////////////
// DPK_at_float_subArr {{{2
//
// Subtracts the elements of $val to the elements of $array.
////////////////////////////////
global proc DPK_at_float_subArr (float $array[], float $val[])
////////////////////////////////
{
//--//
int $x;
for ($x = 0; $x < size($array); ++$x)
	$array[$x] -= $val[$x];
//--//
}
//---- end "DPK_at_float_subArr" ----// }}}2


////////////////////////////////
// DPK_at_float_mult {{{2
////////////////////////////////
global proc DPK_at_float_mult (float $array[], float $val)
////////////////////////////////
{
//--//
int $x;
for ($x = 0; $x < size($array); ++$x)
	$array[$x] *= $val;
//--//
}
//---- end "DPK_at_float_mult" ----// }}}2


////////////////////////////////
// DPK_at_float_multArr {{{2
//
// Adds the elements of $val to the elements of $array.
////////////////////////////////
global proc DPK_at_float_multArr (float $array[], float $val[])
////////////////////////////////
{
//--//
int $x;
for ($x = 0; $x < size($array); ++$x)
	$array[$x] *= $val[$x];
//--//
}
//---- end "DPK_at_float_multArr" ----// }}}2


////////////////////////////////
// DPK_at_float_eval {{{2
////////////////////////////////
global proc DPK_at_float_eval (float $array[], string $cmd)
////////////////////////////////
{
//--//
// Check if there's a command.
string $toks[];
tokenize $cmd " (" $toks;
int $makeGlobal;
if (!`exists $toks[0]`)
	$makeGlobal = 1;

int $x;
string $nCmd;
for ($x = 0; $x < size($array); ++$x)
{
	$nCmd = substituteAllString($cmd, "#", $array[$x]);
	if ($makeGlobal)
		$array[$x] = eval("global proc float DPK_at_float_tmp (){return ("+
						  $nCmd+");}DPK_at_float_tmp();");
	else
		$array[$x] = eval($nCmd);
}
//--//
}
//---- end "DPK_at_float_eval" ----// }}}2


////////////////////////////////
// DPK_at_float_join {{{2
////////////////////////////////
global proc string DPK_at_float_join (string $sep, float $array[])
////////////////////////////////
{
//--//
string $text;
int $x;
for ($x = 0; $x < size($array); ++$x)
	$text += ($sep+$array[$x]);

return $text;
//--//
}
//---- end "DPK_at_float_join" ----// }}}2


////////////////////////////////
// DPK_at_float_to_string {{{2
////////////////////////////////
global proc string[] DPK_at_float_to_string (float $array[])
////////////////////////////////
{
//--//
string $strArr[];
int $x;
for ($x = 0; $x < size($array); ++$x)
	$strArr[$x] = $array[$x];

return $strArr;
//--//
}
//---- end "DPK_at_float_to_string" ----// }}}2


////////////////////////////////
// DPK_at_float_to_int {{{2
////////////////////////////////
global proc int[] DPK_at_float_to_int (float $array[])
////////////////////////////////
{
//--//
int $iArr[];
int $x;
for ($x = 0; $x < size($array); ++$x)
	$iArr[$x] = $array[$x];

return $iArr;
//--//
}
//---- end "DPK_at_float_to_int" ----// }}}2


////////////////////////////////
// DPK_at_float_to_vector {{{2
////////////////////////////////
global proc vector[] DPK_at_float_to_vector (float $array[])
////////////////////////////////
{
//--//
vector $vArr[];
int $x;
for ($x = 0; $x < size($array); ++$x)
	$vArr[$x] = << $array[$x], $array[$x], $array[$x] >>;

return $vArr;
//--//
}
//---- end "DPK_at_float_to_vector" ----// }}}2


// }}}1


//------------------------------
//------------------------------
//
//  PART 4: INT Procedures {{{1
//
//------------------------------
//------------------------------

////////////////////////////////
// DPK_at_int_eleIndex {{{2
////////////////////////////////
global proc int DPK_at_int_eleIndex (int $array[], int $element)
////////////////////////////////
{
//--//
int $x, $size = size($array);
for ($x = 0; $x < $size; ++$x)
{
	if ($array[$x] == $element)
		return $x;
}
return -1;
//--//
}
//---- end "DPK_at_int_eleIndex" ----// }}}2


////////////////////////////////
// DPK_at_int_remIndex {{{2
////////////////////////////////
global proc int DPK_at_int_remIndex (int $array[], int $index)
////////////////////////////////
{
//--//
int $nArray[], $value;
int $x, $inc, $size = size($array);
for ($x = 0; $x < $size; ++$x)
{
	if ($x != $index)
		$nArray[$inc++] = $array[$x];
	else
		$value = $array[$x];
}
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_int_remIndex" ----// }}}2


////////////////////////////////
// DPK_at_int_pop {{{2
////////////////////////////////
global proc int DPK_at_int_pop (int $array[])
////////////////////////////////
{
//--//
int $nArray[], $value;
int $x;
for ($x = 0; $x < size($array) - 1; ++$x)
	$nArray[$x] = $array[$x];

$value = $array[$x];
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_int_pop" ----// }}}2


////////////////////////////////
// DPK_at_int_shift {{{2
////////////////////////////////
global proc int DPK_at_int_shift (int $array[])
////////////////////////////////
{
//--//
int $nArray[], $value;
int $x;
for ($x = 1; $x < size($array); ++$x)
	$nArray[$x - 1] = $array[$x];

$value = $array[0];
$array = $nArray;
return $value;
//--//
}
//---- end "DPK_at_int_shift" ----// }}}2


////////////////////////////////
// DPK_at_int_catenate {{{2
//
// Appends the elements of $array2 to the end of $array1 and returns the new
// size of $array1.
////////////////////////////////
global proc int DPK_at_int_catenate (int $array1[], int $array2[])
////////////////////////////////
{
//--//
int $inc = size($array1);
int $x;
for ($x = 0; $x < size($array2); ++$x) {
	$array1[$inc++] = $array2[$x];
}

return $inc;
//--//
}
//---- end "DPK_at_int_catenate" ----// }}}2


////////////////////////////////
// DPK_at_int_intersect {{{2
//
// Intersects the two integer arrays and returns an array containing the
// elements that exist in both. The order of the returned elements is their
// order in the first array.
////////////////////////////////
global proc int[] DPK_at_int_intersect (int $array1[], int $array2[])
////////////////////////////////
{
//--//
int $x, $inc, $intersect[], $size = size($array1);
for ($x = 0; $x < $size; ++$x)
{
	// Check if the current element of the $array1 is part of $array2 and
	// whether it is added to $intersect.
	if (`DPK_at_int_eleIndex $array2    $array1[$x]` != -1 &&
		`DPK_at_int_eleIndex $intersect $array1[$x]` == -1)
	{
		// The current element of $array1 exists in both arrays and is not yet
		// added to $intersect.
		$intersect[$inc++] = $array1[$x];
	}
}

return $intersect;
//--//
}
//---- end "DPK_at_int_intersect" ----// }}}2


////////////////////////////////
// DPK_at_int_addMissing {{{2
//
// Appends every element of $array2 to $array1 that is not already included in
// it. Returns the new size of $array1.
////////////////////////////////
global proc int DPK_at_int_addMissing (int $array1[], int $array2[])
////////////////////////////////
{
//--//
// Iterate through the elements of $array2.
int $x, $inc = size($array1), $size = size($array2);
for ($x = 0; $x < $size; ++$x)
{
	// Check whether the current element is already included in $array1.
	if (`DPK_at_int_eleIndex $array1 $array2[$x]` == -1) {
		// No it isn't, so we append it to it.
		$array1[$inc++] = $array2[$x];
	}
}

return $inc;
//--//
}
//---- end "DPK_at_int_addMissing" ----// }}}2


////////////////////////////////
// DPK_at_int_reverse {{{2
////////////////////////////////
global proc DPK_at_int_reverse (int $array[])
////////////////////////////////
{
//--//
int $tmp;
int $x, $y;
int $size = size($array);
for ($x = $size - 1, $y = 0; $x >= (($size + 1) / 2); --$x, ++$y)
{
	$tmp       = $array[$y];
	$array[$y] = $array[$x];
	$array[$x] = $tmp;
}
//--//
}
//---- end "DPK_at_int_reverse" ----// }}}2


////////////////////////////////
// DPK_at_int_sort_int {{{2
////////////////////////////////
global proc int[] DPK_at_int_sort_int ( int $array[],
										int $old[],
										int $new[])
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

int $sorted[];
int $x, $y, $i, $inc, $count[];
for ($x = 0; $x < $sizeNew; ++$x)
{
	$i = 0;

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if ($i == $count[$new[$x]]) {
				$sorted[$inc++] = $array[$y];
				$count[$new[$x]] += 1;
				break;
			}
			++$i;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_int_sort_int" ----// }}}2


////////////////////////////////
// DPK_at_int_sort_float {{{2
////////////////////////////////
global proc int[] DPK_at_int_sort_float ( int   $array[],
										  float $old[],
										  float $new[] )
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

int $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_int_sort_float" ----// }}}2


////////////////////////////////
// DPK_at_int_sort_string {{{2
////////////////////////////////
global proc int[] DPK_at_int_sort_string (int    $array[],
										  string $old[],
										  string $new[])
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

int $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_int_sort_string" ----// }}}2


////////////////////////////////
// DPK_at_int_sort_vector {{{2
////////////////////////////////
global proc int[] DPK_at_int_sort_vector (int    $array[],
										  vector $old[],
										  vector $new[])
////////////////////////////////
{
//--//
int $sizeOld = size($old);
int $sizeNew = size($new);

int $sorted[];
int $x, $y, $c, $inc;
for ($x = 0; $x < $sizeNew; ++$x)
{
	$c = 0;
	for ($y = 0; $y < $x; ++$y) {
		if ($new[$y] == $new[$x]) {
			++$c;
		}
	}

	for ($y = 0; $y < $sizeOld; ++$y)
	{
		if ($old[$y] == $new[$x])
		{
			if (!$c) {
				$sorted[$inc++] = $array[$y];
				break;
			}
			--$c;
		}
	}
}

return $sorted;
//--//
}
//---- end "DPK_at_int_sort_vector" ----// }}}2


////////////////////////////////
// DPK_at_int_max {{{2
//
// Returns the index of the element with the highest value.
////////////////////////////////
global proc int DPK_at_int_max (int $array[])
////////////////////////////////
{
//--//
int $x, $max;
for ($x = 0; $x < size($array); ++$x) {
	if ($array[$x] > $array[$max]) {
		$max = $x;
	}
}

return $max;
//--//
}
//---- end "DPK_at_int_max" ----// }}}2


////////////////////////////////
// DPK_at_int_min {{{2
//
// Returns the index of the element with the lowest value.
////////////////////////////////
global proc int DPK_at_int_min (int $array[])
////////////////////////////////
{
//--//
int $x, $max;
for ($x = 0; $x < size($array); ++$x) {
	if ($array[$x] < $array[$max]) {
		$max = $x;
	}
}

return $max;
//--//
}
//---- end "DPK_at_int_min" ----// }}}2


////////////////////////////////
// DPK_at_int_add {{{2
////////////////////////////////
global proc DPK_at_int_add (int $array[], int $val)
////////////////////////////////
{
//--//
int $x;
for ($x = 0; $x < size($array); ++$x)
	$array[$x] += $val;
//--//
}
//---- end "DPK_at_int_add" ----// }}}2


////////////////////////////////
// DPK_at_int_eval {{{2
////////////////////////////////
global proc DPK_at_int_eval (int $array[], string $cmd)
////////////////////////////////
{
//--//
// Check if there's a command.
string $toks[];
tokenize $cmd " (" $toks;
int $makeGlobal;
if (!`exists $toks[0]`)
	$makeGlobal = 1;

int $x;
string $nCmd;
for ($x = 0; $x < size($array); ++$x)
{
	$nCmd = substituteAllString($cmd, "#", $array[$x]);
	if ($makeGlobal)
		$array[$x] = eval("global proc int DPK_at_int_tmp (){return ("+
						  $nCmd+");}DPK_at_int_tmp();");
	else
		$array[$x] = eval($nCmd);
}
//--//
}
//---- end "DPK_at_float_eval" ----// }}}2


////////////////////////////////
// DPK_at_int_increment {{{2
//
// Returns 1 if the incrementing could be done and 0 if the maximum is
// reached.
//
// This procedure takes a maximum dimension integer array ($max) and the int
// array to be incremented and returns an int array that is one index higher.
// If no further incrementing is possible in a certain dimension, it is reset
// to 0 and the next higher dimension is incremented. If the array to be
// incremented is empty, it is set to zero. If no more incrementing is
// possible, the array is emptied and 0 is returned.
//
// NOTE that the incrementing of a dimension will never reach the max but
// stay one below it. This is because $max is considered to be a $sizes array
// from the DPK_multiDimArray script and $array is the index.
//
// This makes it possible to create a while loop that starts with an empty int
// array and ends with the max like this:
//
//   DPK_arrayTools;
//   int $inc[];
//   while (`DPK_at_int_increment {4, 2, 2, 3} $inc`)
//       print (`DPK_at_int_join " " $inc`+"\n");
//
// The first output would be " 0 0 0 0" and the next " 0 0 0 1"... The last is
// " 3 1 1 2".
////////////////////////////////
global proc int DPK_at_int_increment (int $max[], int $array[])
////////////////////////////////
{
//--//
// When the $max array has no elements, we can't increment anything.
int $size = size($max);
if (!$size) {
	return 0;
}

// If the array to be incremented is empty, we initialize it with values of 0
// and return true.
int $x;
if (!size($array))
{
	for ($x = 0; $x < $size; ++$x)
		$array[$x] = 0;

	// We don't do any incrementation since we're just starting and want to
	// begin at the very first element.
	return 1;
}

// Create a copy of the $array (which is to be incremented) but only copy as
// many elements as there are elements in the $max array (which defines the
// upper border).
int $arr[];
for ($x = 0; $x < $size; ++$x)
	$arr[$x] = $array[$x];

// Iterate backwards from the last to the first element and do the
// incrementing.
int $isOK;
for ($x = $size - 1; $x >= 0; --$x)
{
	// Check whether the current element can be incremented.
	if ($arr[$x] < $max[$x] - 1)
	{
		// Yes, because it is lower than the corresponding max value.
		// Increment the value.
		$arr[$x] += 1;

		// An incrementation operation has been possible so we set $isOK to
		// true.
		$isOK = 1;

		// Since we don't want to increment any further, we exit this loop.
		break;
	}
	else
	{
		// The current element is at its maximum so we can't increment it. In
		// the next iteration, we're going to try to increment the previous
		// element. Because the current element is on a lower level, we set it
		// to 0.
		$arr[$x] = 0;
	}
}

if (!$isOK) {
	// No incrementing could be done so we clear the array and return 0.
	clear $array;
	return 0;
}

// Assign the incremented array to the original.
$array = $arr;
return 1;
//--//
}
//---- end "DPK_at_int_increment" ----// }}}2


////////////////////////////////
// DPK_at_int_join {{{2
////////////////////////////////
global proc string DPK_at_int_join (string $sep, int $array[])
////////////////////////////////
{
//--//
string $text;
int $x;
for ($x = 0; $x < size($array); ++$x)
	$text += ($sep+$array[$x]);

return $text;
//--//
}
//---- end "DPK_at_int_join" ----// }}}2


////////////////////////////////
// DPK_at_int_to_string {{{2
////////////////////////////////
global proc string[] DPK_at_int_to_string (int $array[])
////////////////////////////////
{
//--//
string $strArr[];
int $x;
for ($x = 0; $x < size($array); ++$x)
	$strArr[$x] = $array[$x];

return $strArr;
//--//
}
//---- end "DPK_at_int_to_string" ----// }}}2


////////////////////////////////
// DPK_at_int_to_float {{{2
////////////////////////////////
global proc float[] DPK_at_int_to_float (int $array[])
////////////////////////////////
{
//--//
float $flArr[];
int $x;
for ($x = 0; $x < size($array); ++$x)
	$flArr[$x] = $array[$x];

return $flArr;
//--//
}
//---- end "DPK_at_int_to_float" ----// }}}2


////////////////////////////////
// DPK_at_int_to_vector {{{2
////////////////////////////////
global proc vector[] DPK_at_int_to_vector (int $array[])
////////////////////////////////
{
//--//
vector $vArr[];
int $x;
for ($x = 0; $x < size($array); ++$x)
	$vArr[$x] = << $array[$x], $array[$x], $array[$x] >>;

return $vArr;
//--//
}
//---- end "DPK_at_int_to_vector" ----// }}}2


////////////////////////////////
//------------------------------
// DPK_arrayTools {{{2
//------------------------------
////////////////////////////////
global proc DPK_arrayTools ()
////////////////////////////////
{
//--//
// This proc does nothing. It's just here so that you can source this script
// by typing "DPK_arrayTools;".
//--//
}
//---- end "DPK_arrayTools" ----// }}}2


// }}}1


//------------------------------
// Configure Vim {{{3
//
// If you're wondering why there are places with three curly braces ("{" or
// "}") with a number in comments, these are used by vim to do automatic
// folding (hiding lines).
//
// If you don't know what vim is, check out:
//    http://www.vim.org
//
// These settings will configure vim to display this file correctly.
//    vim:set ts=4 tw=78 fdm=marker fdl=1 fdc=3:
