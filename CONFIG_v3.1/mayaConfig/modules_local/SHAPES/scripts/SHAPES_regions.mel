// --------------------------------------------------------------------------------------------------
//
// SHAPES
//
// blend shape editing tool for Maya
//
// required plugins:
//   SHAPESTools
//
// Ingo Clemens
// www.braverabbit.com
//
// copyright brave rabbit, Ingo Clemens 2014-2016
//
// --------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------
//
// THE SOFTWARE PRODUCT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
// IMPLIED, INCLUDING, BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NON-INFRINGEMENT OF THIRD-PARTY RIGHTS. THE ENTIRE RISK AS TO THE QUALITY AND
// PERFORMANCE OF THE SOFTWARE PRODUCT IS WITH YOU.
// NEITHER BRAVE RABBIT NOR ITS SUPPLIERS WARRANT THAT THE FUNCTIONS CONTAINED IN THE SOFTWARE
// PRODUCT WILL MEET YOUR REQUIREMENTS OR THAT THE OPERATION OF THE SOFTWARE PRODUCT WILL BE
// UNINTERRUPTED OR ERROR-FREE. BRAVE RABBIT IS NOT OBLIGATED TO PROVIDE ANY UPDATES TO THE
// SOFTWARE.
// IN NO EVENT SHALL THE AUTHOR OF THIS SOFTWARE PRODUCT BE LIABLE FOR ANY SPECIAL, CONSEQUENTIAL,
// INCIDENTAL, DIRECT OR INDIRECT DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
// LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, FOR PERSONAL INJURY, LOSS OF BUSINESS
// INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THIS
// PRODUCT, EVEN IF THE AUTHOR OF THIS SOFTWARE PRODUCT IS AWARE OF THE POSSIBILITY OF SUCH
// DAMAGES AND KNOWN DEFECTS, ANY CLAIM BY A THIRD PARTY AND EVEN IF THE REMEDY FAILS OF ITS
// ESSENTIAL PURPOSE.
//
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
// region maps
// --------------------------------------------------------------------------------------------------

global proc shapesRegion_storeRegionMap( int $new )
{
	//
	// saves the region map to disk
	//
	string $name = `textFieldGrp -q -tx shpUI_regionNameField`;
	
	if ($name == "")
		error "No region map name defined";
	
	string $node = "SHAPESRegionData";
	if ($new)
		shapesRegion_createDataNode;
	else
		lockNode -l 0 $node;
	
	setAttr ($node + ".regionMap") -type "string" $name;
	setAttr ($node + ".parentToShape") (`checkBox -q -v shpUI_regionParentCheck`);
	
	string $dataList[];
	string $labelString;
	
	for ($i = 0; $i < 6; $i ++)
	{
		string $label = `textField -q -tx ("shpUI_regionLabel" + $i)`;
		$label = substitute(" ", $label, "_");
		int $splitCheck = `checkBox -q -v ("shpUI_regionSplitCheck" + $i)`;
		string $splitMap = `textField -q -tx ("shpUI_regionSplitMapField" + $i)`;
		float $width = `floatField -q -v ("shpUI_regionSplitWidth" + $i)`;
		string $identifier = `textField -q -tx ("shpUI_regionIdentifier" + $i)`;
		
		setAttr ($node + ".regionLabel[" + $i + "]") -type "string" $label;
		setAttr ($node + ".regionSplit[" + $i + "]") (`checkBox -q -v ("shpUI_regionSplitCheck" + $i)`);
		setAttr ($node + ".regionSplitMap[" + $i + "]") -type "string" (`textField -q -tx ("shpUI_regionSplitMapField" + $i)`);
		setAttr ($node + ".regionBlend[" + $i + "]") (`floatField -q -v ("shpUI_regionSplitWidth" + $i)`);
		setAttr ($node + ".regionIdentifier[" + $i + "]") -type "string" (`textField -q -tx ("shpUI_regionIdentifier" + $i)`);
		
		$dataList[size($dataList)] = $label + "," + $splitCheck + "," + $width + "," + $identifier + "," + $splitMap;
		
		// add all labels to the label string
		// just to check if at least one label has been defined
		$labelString += $label;
	}
	
	int $parentCheck = `checkBox -q -v shpUI_regionParentCheck`;
	$dataList[size($dataList)] = $parentCheck;
	
	if ($labelString == "")
	{
		error "At least one region label must be defined";
		shapesRegion_deleteDataNode;
	}
	
	setAttr ($node + ".regions") -type "string" (stringArrayToString($dataList, ":"));
	lockNode -l 1 $node;
	
	deleteUI SHAPESRegionSettingsWin;
	
	shapesRegion_updateColorButtons;
	
	// show the name of the current map
	textField -e -tx $name shpUI_currentRegionNameField;
	
	// save the updated region labels to the file if it exists
	if (!$new)
		shapesRegion_exportRegionMap;
}


global proc shapesRegion_createDataNode()
{
	//
	// creates a new region data node
	//
	global string $gShapes_skinMesh;
	
	// remove the data node if it exists
	shapesRegion_deleteDataNode;
	
	// create a new node and add the attributes
	string $dataNode = `createNode network -n SHAPESRegionData`;
	
	addAttr -ln "regionMap" -dt "string" $dataNode;
	addAttr -ln "regions" -dt "string" $dataNode;
	addAttr -ln "parentToShape" -at "bool" $dataNode;
	
	addAttr -m -ln "regionLabel" -dt "string" $dataNode;
	addAttr -m -ln "regionSplit" -at "bool" $dataNode;
	addAttr -m -ln "regionSplitMap" -dt "string" $dataNode;
	addAttr -m -ln "regionBlend" -at "double" $dataNode;
	addAttr -m -ln "regionIdentifier" -dt "string" $dataNode;
	
	for ($i = 0; $i < 6; $i ++)
	{
		addAttr -ln ("regionWeights" + $i) -dt doubleArray $dataNode;
		addAttr -ln ("regionWeightsBuffer" + $i) -dt doubleArray $dataNode;
	}
	
	// fill the array with default values
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	for ($i = 0; $i < 6; $i ++)
		br_editRegionMap -cl -i $i -n $dataNode -m $intermediate;
}


global proc shapesRegion_deleteDataNode()
{
	//
	// deletes the region data node
	//
	
	string $node = "SHAPESRegionData";
	if (`objExists $node`)
	{
		lockNode -l 0 $node;
		delete $node;
	}
}


global proc shapesRegion_editRegionMap( int $new )
{
	//
	// open the region label ui for creating a new map or for editing
	//
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	if ($gShapes_skinMesh == "")
		return;
	
	if (!$new && `textField -q -tx shpUI_currentRegionNameField` == "")
		return;
	
	shapesUI_buildRegionLabelUI $new;
	
	if (!$new)
	{
		textFieldGrp -e -ed 0 -tx (`getAttr SHAPESRegionData.regionMap`) shpUI_regionNameField;
		if (`attributeQuery -ex -n SHAPESRegionData parentToShape`)
		{
			string $parentValueString = `getAttr SHAPESRegionData.parentToShape`;
			int $parentValue = 0;
			if ($parentValueString != "")
				$parentValue = $parentValueString;
			checkBox -e -v $parentValue shpUI_regionParentCheck;
		}
		else
			addAttr -m -ln "parentToShape" -at "bool" SHAPESRegionData;
		
		int $mapError;
		for ($i = 0; $i < 6; $i ++)
		{
			textField -e -tx (`getAttr SHAPESRegionData.regionLabel[$i]`) ("shpUI_regionLabel" + $i);
			checkBox -e -v (`getAttr SHAPESRegionData.regionSplit[$i]`) ("shpUI_regionSplitCheck" + $i);
			floatField -e -v (`getAttr SHAPESRegionData.regionBlend[$i]`) ("shpUI_regionSplitWidth" + $i);
			textField -e -tx (`getAttr SHAPESRegionData.regionIdentifier[$i]`) ("shpUI_regionIdentifier" + $i);
			string $splitMap = `getAttr SHAPESRegionData.regionSplitMap[$i]`;
			textField -e -tx $splitMap ("shpUI_regionSplitMapField" + $i);
			
			// check if the split map is valid
			if ($splitMap != "")
			{
				string $exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 0);
				if ($exportPath != "")
				{
					if (!`filetest -e ($exportPath + "/" + $splitMap + ".bsw")`)
					{
						$mapError = 1;
						textField -e -tx ("(" + $splitMap + ")") -fn "obliqueLabelFont" ("shpUI_regionSplitMapField" + $i);
					}
				}
				else
					$mapError = 1;
			}
		}
		
		if ($mapError)
			confirmDialog -t "SHAPES" -m "One or more custom split maps cannot be found." -b "OK";
	}
}


global proc shapesRegion_updateColorButtons()
{
	//
	// enables/disables the color buttons
	// based on the current region map
	//
	
	// show the paint layout and enable only the color buttons
	// which have been assigned with a label
	rowLayout -e -en 1 shpUI_colorButtonsLayout;
	for ($i = 0; $i < 6; $i ++)
	{
		int $enable = 0;
		string $label = `getAttr SHAPESRegionData.regionLabel[$i]`;
		if ($label != "")
			$enable = 1;
		iconTextButton -e -en $enable -i ("SHAPES_regionColor" + ($i + 1) + ".png") -ann $label ("shpUI_regionColor" + $i);
	}
}


global proc shapesRegion_clearRegionData( string $mapName )
{
	//
	// resets the region variables
	// when the current region map gets deleted
	//
	if (`textField -q -tx shpUI_currentRegionNameField` == $mapName || $mapName == "")
	{
		textField -e -tx "" shpUI_currentRegionNameField;
		menuItem -e -en 0 shpUI_unloadRegionItem;
		shapesRegion_deleteDataNode;
		rowLayout -e -en 0 shpUI_colorButtonsLayout;
		if ($mapName == "")
			shapesUtil_buildImportMenu "shpUI_regionList";
	}
}


global proc shapesRegion_exportRegionMap()
{
	//
	// export the region map
	//
	global string $gShapes_bsNode;
	
	string $exportPath = shapesUtil_getExportPath("/regions/" + $gShapes_bsNode, 1);
	if ($exportPath == "")
		return;
	
	string $fileName = $exportPath + "/" + (`getAttr SHAPESRegionData.regionMap`) + ".bsr";
	
	br_editRegionMap -ex -fn $fileName -n SHAPESRegionData;
	
	menuItem -e -en 0 shpUI_deleteRegionItem;
	shapesUtil_buildImportMenu "shpUI_regionList";
}


global proc shapesRegion_loadRegionMap()
{
	//
	// loads the selected map in the list for editing
	//
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	string $exportPath = shapesUtil_getExportPath("/regions/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return;
	
	string $mapName[] = `textScrollList -q -si shpUI_regionList`;
	
	if (!size($mapName))
		return;
	
	// delete any previous data
	shapesRegion_createDataNode;
		
	string $fileName = $exportPath + "/" + $mapName[0] + ".bsr";
	
	string $node = "SHAPESRegionData";
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	int $result = `br_editRegionMap -im -fn $fileName -n $node -m $intermediate`;
	if (!$result)
	{
		shapesRegion_clearRegionData "";
		return;
	}
	
	setAttr ($node + ".regionMap") -type "string" $mapName[0];
	
	string $dataString = `getAttr ($node + ".regions")`;
	string $regionArray[] = stringToStringArray($dataString, ":");
	for ($i = 0; $i < 6; $i ++)
	{
		string $data = substituteAllString($regionArray[$i], ",", "-,-");
		string $items[] = stringToStringArray($data, ",");
		for ($j = 0; $j < size($items); $j ++)
		{
			$items[$j] = substituteAllString($items[$j], "-", "");
		}
		setAttr ($node + ".regionLabel[" + $i + "]") -type "string" $items[0];
		float $value;
		if (tolower($items[1]) == "true")
			$value = 1;
		else if (tolower($items[1]) == "false")
			$value = 0;
		else
			$value = $items[1];
		setAttr ($node + ".regionSplit[" + $i + "]") $value;
		$value = $items[2];
		setAttr ($node + ".regionBlend[" + $i + "]") $value;
		
		if (size($items) > 3)
		{
			setAttr ($node + ".regionIdentifier[" + $i + "]") -type "string" $items[3];
			if (size($items) > 4)
				setAttr ($node + ".regionSplitMap[" + $i + "]") -type "string" $items[4];
		}
	}
	
	if (size($regionArray) == 7)
	{
		int $parentValue = $regionArray[6];
		setAttr ($node + ".parentToShape") $parentValue;
	}
	
	// show the name of the current map
	textField -e -tx $mapName[0] shpUI_currentRegionNameField;
	menuItem -e -en 1 shpUI_unloadRegionItem;
	
	shapesRegion_updateColorButtons;
}


global proc shapesRegion_showFullColorMap( int $asColor )
{
	//
	// displays a full color map for all regions
	// or a visual representation of left over weights
	//
	global int $gShapes_currentRegion;
	global int $gShapes_lastRegion;
	global int $gShapes_showFullColorMap;
	
	string $sel[] = `ls -sl -tr`;
	if (!size($sel))
		return;
	
	string $shape[] = `listRelatives -s -ni $sel[0]`;
	if (!size($shape))
		error ($sel[0] + " has no shape node");
	if (`nodeType $shape[0]` != "mesh")
		error ($shape[0] + " is not a mesh object");
	
	// get the current values and add them to the region map
	// before resetting everything and displaying the full map
	if (!$gShapes_showFullColorMap)
	{
		shapesRegion_storeLastRegionEdit;
		$gShapes_showFullColorMap = 1;
		
		// store the currently active region in order to be able to re-activate it
		// when exiting the display of the full color map
		// the current region needs to be set to -1 because if the user
		// continues to paint regions after displaying the full colors
		// the colors will get saved to the current region map
		$gShapes_lastRegion = $gShapes_currentRegion;
		$gShapes_currentRegion = -1;
	}
	
	PaintVertexColorTool;
	string $artContext = `currentCtx -q`;
	
	// create a new color set to display the colors
	polyColorPerVertex $shape[0];
	
	int $displayType = $asColor;
	if ($asColor == 0 && `optionVar -q SHAPESColorDisplayPartialWeights`)
		$displayType = 2;
	
	br_editRegionMap -col $displayType -m $shape[0] -n SHAPESRegionData;
	
	setToolTo selectSuperContext;
	
	shapesRegion_toggleColorPaintButtons 0;
	
	popupMenu -e -dai shpUI_assignPartialWeightsMenu;
	
	// re-define the commands for the buttons so it's possible to
	// switch between both modes but still have a toggle functionality
	// for each button to exit the display
	if ($asColor)
	{
		iconTextButton -e -c shapesRegion_exitFullColorMap shpUI_regionShowColors;
		iconTextButton -e -c ("shapesRegion_showFullColorMap 0") shpUI_regionShowPartials;
	}
	else
	{
		iconTextButton -e -c ("shapesRegion_showFullColorMap 1") shpUI_regionShowColors;
		iconTextButton -e -c shapesRegion_exitFullColorMap shpUI_regionShowPartials;
		
		// add the assign partials context menu
		menuItem -l "Auto Assign" -p shpUI_assignPartialWeightsMenu -c "shapesRegion_appendToRegion -1";
		menuItem -d 1 -p shpUI_assignPartialWeightsMenu;
		for ($i = 0; $i < 6; $i ++)
		{
			string $label = `getAttr SHAPESRegionData.regionLabel[$i]`;
			if ($label != "")
				menuItem -l $label -p shpUI_assignPartialWeightsMenu -c ("shapesRegion_appendToRegion " + $i);
		}
	}
}


global proc shapesRegion_exitFullColorMap()
{
	//
	// exists the display of the full color map for all regions
	// or a visual represenation of left over weights
	//
	global int $gShapes_lastRegion;
	global int $gShapes_showFullColorMap;
	global string $gShapes_regionTarget;
	
	shapesRegion_toggleColorPaintButtons 1;
	iconTextButton -e -c ("shapesRegion_showFullColorMap 1") shpUI_regionShowColors;
	iconTextButton -e -c ("shapesRegion_showFullColorMap 0") shpUI_regionShowPartials;
	
	popupMenu -e -dai shpUI_assignPartialWeightsMenu;
	
	string $colorNodes[] = shapesRegion_getColorPerVertexNode($gShapes_regionTarget);
	if (size($colorNodes))
		delete $colorNodes;
	
	if ($gShapes_lastRegion != -1)
		shapesRegion_paintRegionColor $gShapes_lastRegion;
	
	$gShapes_showFullColorMap = 0;
}


global proc shapesRegion_toggleColorPaintButtons( int $enable )
{
	//
	// enable/disable other region functions when
	// displaying the full color mode
	//
	iconTextButton -e -en $enable shpUI_paintRegionButton;
	for ($i = 0; $i < 6; $i ++)
		iconTextButton -e -en $enable ("shpUI_regionColor" + $i);
	
	// enable only the buttons for the current regions
	if ($enable)
		shapesRegion_updateColorButtons;
	
	formLayout -e -en $enable shpUI_regionLayout;
}


global proc string[] shapesRegion_getColorPerVertexNode( string $node )
{
	//
	// returns a list of color per vertex nodes of the given node
	//
	string $nodes[];
	string $hist[] = `listHistory -gl 1 -pdo 1 -lf 1 -f 0 -il 2 $node`;
	if (size($hist))
	{
		for ($h in $hist)
		{
			if (`nodeType $h` == "polyColorPerVertex")
				$nodes[size($nodes)] = $h;
		}
	}
	return $nodes;
}


global proc shapesRegion_extractRegionMap()
{
	//
	// creates/updates the target shapes from the current map
	//
	global int $gShapes_regionProcess;
	global string $gShapes_bsNode;
	global string $gShapes_selectedTarget;
	global string $gShapes_skinMesh;
	global string $gShapes_bsData[];
	global string $gShapes_left[];
	global string $gShapes_right[];
	
	if ($gShapes_skinMesh == "")
		return;
	
	if ($gShapes_selectedTarget == "")
		error "Select a target shape to extract the regions from";
	
	if ($gShapes_regionProcess)
		error "Exit paint region mode before extracting region maps";
	
	string $basedOnName = $gShapes_selectedTarget;
	
	// check if a helper or group attribute is selected
	// in this case deselect to avoid any errors
	int $ids[] = shapesMain_getShapeIds(0, {$gShapes_selectedTarget});
	if (dict_getBoolValue($gShapes_bsData[$ids[0]], "helper"))
		error "The selected item is a helper attribute and cannot be used for extracting the region map";
	
	// initialize the progress bar
	global string $gMainProgressBar;
	progressBar -e -bp -ii 0 -max 8 $gMainProgressBar;
	
	progressBar -e -s 1 $gMainProgressBar;
	
	string $original = shapesAction_duplicateOrginalMesh("original");
	string $baseTarget[] = shapesAction_extractTarget("", -1, 0, 1);
	if (!size($baseTarget))
	{
		progressBar -e -ep $gMainProgressBar;
		return;
	}
	
	// create a temporary blendshape
	string $tempBS[] = `blendShape $baseTarget[size($baseTarget) - 1] $original`;
	blendShape -e -w 0 1 $tempBS[0];
	if (size($baseTarget) > 1)
	{
		for ($i = 0; $i < size($baseTarget) - 1; $i ++)
		{
			string $items[] = stringToStringArray($baseTarget[$i], "_");
			int $ibValue = $items[size($items) - 1];
			eval ("blendShape -e -ib -tc 1 -t " + $original + " 0 " + $baseTarget[$i] + " " + (($ibValue - 5000) / 1000.0) + " " + $tempBS[0]);
		}
	}
	
	string $originalShape = shapesMain_getOriginalMesh($original, 1);
	
	// store the current context
	string $currentContext = `currentCtx -q`;
	
	progressBar -e -st "Extracting regions ..." $gMainProgressBar;
	
	string $regionShapes[];
	string $regionValues[];
	string $side;
	string $sideLast;
	int $index;
	int $clearSplit;
	string $parent[];
	
	while ($index < 6)
	{
		string $label = `getAttr SHAPESRegionData.regionLabel[$index]`;
		float $blend = `getAttr SHAPESRegionData.regionBlend[$index]`;
		int $split = `getAttr SHAPESRegionData.regionSplit[$index]`;
		string $identifier = `getAttr SHAPESRegionData.regionIdentifier[$index]`;
		string $splitMap = `getAttr SHAPESRegionData.regionSplitMap[$index]`;
		
		if ($label != "")
		{
			blendShape -e -w 0 1 $tempBS[0];
			
			// clear all blend shape weights
			br_blendShapeEditWeights -delete -n $tempBS[0] -i -1;
			
			// clear the base weights from the previous split if used
			if ($clearSplit)
			{
				br_blendShapeEditWeights -delete -n $tempBS[0] -i 0;
				$clearSplit = 0;
			}
			
			br_editRegionMap -e -n SHAPESRegionData -i $index -bs $tempBS[0];
			
			// check if the shape should be splitted
			if ($split)
			{
				int $invert = 1;
				if ($side == "")
				{
					// get the identifier for the side
					// if not given use the default L_
					if ($identifier != "")
						$side = $identifier;
					else
						$side = "L_";
					$index --;
				}
				else
				{
					// get the opposite identifier
					// if not given use the default R_
					// if given, get the position in the left identifier array
					// and use this index for the right array
					if ($identifier != "")
					{
						int $sideIndex = shapesArray_stringArrayFind($identifier, 0, $gShapes_left);
						$side = $gShapes_right[$sideIndex];
					}
					else
					{
						$side = "R_";
					}
					$invert = -1;
					$sideLast = $side;
				}
				
				// check for a custom split map
				if ($splitMap != "")
				{
					string $exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 0);
					if ($exportPath != "")
					{
						$splitMap = $exportPath + "/" + $splitMap + ".bsw";
						
						br_blendShapeEditWeights -im -fn $splitMap -n $tempBS[0] -i 0;
						
						if ($invert == -1)
							br_blendShapeEditWeights -invert -n $tempBS[0] -i 0 -om $originalShape;
					}
				}
				// if there is no custom split map use the default splitting
				else
					shapesAction_splitShape $tempBS[0] $originalShape $invert 1 $blend 0.0 0;
				
				$clearSplit = 1;
			}
			
			int $values[] = `getAttr -mi ($tempBS[0] + ".it[0].itg[0].iti")`;
			float $valuesReverse[] = {};
			string $shapeList[] = {};
			
			// define the parent if the placeholder is used
			if (`gmatch $label "*<*"`)
				$parent[size($parent)] = $gShapes_selectedTarget;
			else
				$parent[size($parent)] = "_";
			
			// replace the placeholder with the proper name
			string $placeholder[] = {"<shape>"};
			string $replacement[] = {$gShapes_selectedTarget};
			for ($i = 0; $i < size($placeholder); $i ++)
				$label = substituteAllString($label, $placeholder[$i], $replacement[$i]);
			
			// in order to extract with inbetweens we need to save
			// all inbetween shapes along with their values;
			// since the values are in ascending order we need to inverse
			// to have the main target listed first
			for ($v = size($values) - 1; $v >= 0; $v --)
			{
				float $weight = ($values[$v] - 5000) / 1000.0;
				// set the blend shape channel to the value of the inbetween
				// so that it's duplicated properly
				blendShape -e -w 0 $weight $tempBS[0];
				$valuesReverse[size($valuesReverse)] = $weight;
				
				string $result[] = `duplicate $original`;
				
				string $inbetweenString = "";
				if ($weight != 1.0)
					$inbetweenString = "_" + $values[$v];
				
				if ($side != "")
				{
					if (!startsWith($side, "_"))
						$result[0] = `rename $result[0] ($side + $label + $inbetweenString)`;
					else
						$result[0] = `rename $result[0] ($label + $side + $inbetweenString)`;
				}
				else
					$result[0] = `rename $result[0] ($label + $inbetweenString)`;
				$shapeList[size($shapeList)] = $result[0];
			}
			$regionShapes[size($regionShapes)] = stringArrayToString($shapeList, ",");
			$regionValues[size($regionValues)] = shapesArray_floatArrayToString($valuesReverse, ",");
			
			if ($side == $sideLast)
				$side = "";
		}
		$index ++;
		
		progressBar -e -s 1 $gMainProgressBar;
	}
	// reselect the previous tool
	setToolTo $currentContext;
	
	// delete the temporary shapes
	delete $original $baseTarget;
	
	progressBar -e -st "Applying extracted shapes ..." $gMainProgressBar;
	
	// add the region targets to the blend shape node
	string $items[] = `treeView -q -ch "" shpUI_targetTree`;
	// check if the region shape already exists as a target
	for ($s = 0; $s < size($regionShapes); $s ++)
	{
		string $shapeList[] = stringToStringArray($regionShapes[$s], ",");
		string $valueList[] = stringToStringArray($regionValues[$s], ",");
		// the main target is first in the list
		string $shape = $shapeList[0];
		
		if (stringArrayContains($shape, $items))
		{
			// if the target name exists check if it's a helper attribute
			int $index = shapesArray_stringArrayFind($shape, 0, $items);
			if (dict_getBoolValue($gShapes_bsData[$index], "helper"))
				error ("Unable to add the region target \"" + $shape + "\" because a helper/group attribute with the same name exists. Check the scene for remaining targets");
			// replace the existing target with the new region target
			$ids = shapesMain_getShapeIds(1, {$shape});
			
			for ($i = 0; $i < size($shapeList); $i ++)
			{
				float $value = $valueList[$i];
				shapesAction_replaceBlendShapeTarget $shapeList[$i] "" ($value * 1000) $ids[0] 1;
			}
		}
		// if it doesn't exist yet add as a new target
		else
		{
			if (size($shapeList) == 1)
				shapesAction_addBlendShapeTarget $gShapes_skinMesh $shape 1;
			else
			{
				string $inbetweenFlag;
				int $index = shapesAction_findEmptyTargetIndex();
				
				for ($i = 0; $i < size($shapeList); $i ++)
				{
					if ($i > 0)
						$inbetweenFlag = "-ib ";
					
					eval ("blendShape -e " + $inbetweenFlag + "-tc 1 -t " + $gShapes_skinMesh + " " + $index + " " + $shapeList[$i] + " " + $valueList[$i] + " " + $gShapes_bsNode);
				}
				shapesMain_autoOrderNewTarget $shape $gShapes_selectedTarget 1 0;
				$gShapes_selectedTarget = $shape;
				shapesMain_listBlendShapeTargets 1;
				
				delete $shapeList;
			}
			
			// set the parent for the new shapes
			if (`getAttr SHAPESRegionData.parentToShape`)
			{
				$ids = shapesMain_getShapeIds(0, {$shape});
				dict_setValue($gShapes_bsData, $ids[0], "parent", ((substituteAllString($parent[$s], "_", "")) + ":1"));
				shapesMain_setItemParent $shape $parent[$s];
			}
		}
	}
	
	progressBar -e -s 1 $gMainProgressBar;
	
	string $mapName = `textField -q -tx shpUI_currentRegionNameField`;
	print ("// Extracted " + size($regionShapes) + " shapes from region map \"" + $mapName + "\" based on the target \"" + $basedOnName + "\" //\n");
	
	progressBar -e -ep $gMainProgressBar;
}


global proc shapesRegion_exportRegionsToWeights()
{
	//
	// exports the regions to weight maps
	//
	global string $gShapes_bsNode;
	global string $gShapes_skinMesh;
	
	if ($gShapes_skinMesh == "")
		return;
	
	string $exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 1);
	if ($exportPath == "")
		return;
	
	for ($i = 0; $i < 6; $i ++)
	{
		string $label = `getAttr SHAPESRegionData.regionLabel[$i]`;
		if ($label != "")
		{
			string $fileName = $exportPath + "/" + $label + ".bsw";
			br_editRegionMap -ex -fn $fileName -n SHAPESRegionData -i $i;
		}
	}
	
	shapesUI_toggleWeightsContextMenu 0;
	shapesUtil_buildImportMenu "shpUI_shapeWeightsList";
}


global proc shapesRegion_enterPaintRegionMode()
{
	//
	// prepares the scene for painting the regions
	//
	global int $gShapes_regionProcess;
	global int $gShapes_splitProcess;
	global string $gShapes_regionBS;
	global string $gShapes_regionTarget;
	global string $gShapes_selectedTarget;
	global string $gShapes_skinMesh;
	global string $gShapes_bsData[];
	global string $gShapes_orderedTargetList[];
	
	if ($gShapes_skinMesh == "" || $gShapes_selectedTarget == "")
		return;
	
	// check if a helper or group attribute is selected
	// in this case deselect to avoid any errors
	if (size($gShapes_orderedTargetList))
	{
		int $id[] = shapesMain_getShapeIds(0, {});
		if (dict_getBoolValue($gShapes_bsData[$id[0]], "helper"))
			treeView -e -cs shpUI_targetTree;
	}
	
	string $view = shapesSculpt_getCurrentModelPanel();
	if ($view == "")
		error "No modeling panel is currently visible";
	
	// create the blend shape for editing the regions
	$gShapes_regionTarget = shapesAction_duplicateOrginalMesh("");
	$gShapes_regionTarget = `rename $gShapes_regionTarget $gShapes_selectedTarget`;
	// apply the default shader
	sets -e -fe initialShadingGroup $gShapes_regionTarget;
	string $tempBs[] = `blendShape (shapesMain_getShapeNode()) $gShapes_regionTarget`;
	$gShapes_regionBS = $tempBs[0];
	blendShape -e -w 0 1 $gShapes_regionBS;
	
	// match the subdivision level of the region mesh to the skin mesh
	setAttr ($gShapes_regionTarget + ".dsm") `getAttr ($gShapes_skinMesh + ".dsm")`;
	setAttr ($gShapes_regionTarget + ".lev") `getAttr ($gShapes_skinMesh + ".lev")`;
	
	// match the transformation values
	eval ("xform -m " + shapesArray_floatArrayToString(`xform -q -m $gShapes_skinMesh`, " ") + " " + $gShapes_regionTarget);
	
	// hide the skin mesh and show the region target mesh
	shapesMain_setSkinVisibility 0;
	setAttr ($gShapes_regionTarget + ".v") 1;
	
	// isolate the mesh
	select -r $gShapes_regionTarget;
	if (`optionVar -q SHAPESSculptIsolation`)
		enableIsolateSelect $view true;
	
	// keep the previous data if the user cancels the paint operation
	br_editRegionMap -res 0 -n SHAPESRegionData -bs $gShapes_regionBS;
	
	// enable the display colors button
	iconTextButton -e -en 1 shpUI_regionShowColors;
	iconTextButton -e -en 1 shpUI_regionShowPartials;
	
	shapesRegion_paintRegionToggleUI 0 $view;
	$gShapes_regionProcess = 1;
	shapesUI_manageUIModeDependencies 2 1 0;
}


global proc shapesRegion_exitPaintRegionMode( string $view, int $cancel )
{
	//
	// finish painting the region map
	//
	global int $gShapes_currentRegion;
	global int $gShapes_regionProcess;
	global string $gShapes_regionBS;
	global string $gShapes_regionTarget;
	
	// make sure the mesh is selected to be able to get the vertex colors
	select -r $gShapes_regionTarget;
	
	string $node = "SHAPESRegionData";
	int $distribute = `optionVar -q SHAPESDistributePartialRegionWeights`;
	br_editRegionMap -a -n $node -i $gShapes_currentRegion -bs $gShapes_regionBS -dw $distribute;
			
	$gShapes_currentRegion = -1;
	
	if (!$cancel)
		shapesRegion_exportRegionMap;
	else
		br_editRegionMap -res 1 -n $node;
	
	// delete the mesh and end the process
	delete $gShapes_regionTarget;
	$gShapes_regionTarget = "";
	$gShapes_regionBS = "";
	$gShapes_regionProcess = 0;
	
	// enable all ui elements
	shapesRegion_paintRegionToggleUI 1 "";
	shapesUI_manageUIModeDependencies 2 1 1;
	// clear any paint icons of the color buttons
	shapesRegion_updateColorButtons;
	
	// show the skin mesh
	shapesMain_setSkinVisibility 1;
	
	// exit the isolation
	if (`optionVar -q SHAPESSculptIsolation` && $view != "")
		enableIsolateSelect $view false;
	
	setToolTo selectSuperContext;
	
	iconTextButton -e -en 0 shpUI_regionShowColors;
	iconTextButton -e -en 0 shpUI_regionShowPartials;
}


global proc shapesRegion_paintRegionToggleUI( int $enable, string $view )
{
	//
	// disables/enables ui elements
	// based on entering/exiting the paint region mode
	//
	global string $gShapes_regionBS;
	
	// set the sculpt mode options enable state
	shapesUI_manageUIModeDependencies 1 1 1;
	
	rowLayout -e -en $enable shpUI_shapeWeightsLayout;
	
	if (!$enable)
	{
		iconTextButton	-e 
						-i "SHAPES_weightPaintActive.png" 
						-c ("shapesRegion_exitPaintRegionMode " + $view + " 0") 
						-ann "Exit paint regions mode (right-click to cancel)" 
						shpUI_paintRegionButton;
		menuItem -l "Cancel" -p "shpUI_paintRegionPopup" -c ("shapesRegion_exitPaintRegionMode " + $view + " 1") shpUI_paintRegionCancelItem;
		// disable the target list
		treeView -e -en 0 shpUI_targetTree;
	}
	else
	{
		iconTextButton	-e 
						-i "SHAPES_weightPaint.png" 
						-c "shapesRegion_enterPaintRegionMode" 
						-ann "Paint regions for the selected shape" 
						shpUI_paintRegionButton;
		// if there are targets in the list enable the list
		string $items[] = `treeView -q -ch "" shpUI_targetTree`;
		if ($items[0] != "No shapes")
			treeView -e -en 1 shpUI_targetTree;
		// delete the cancel popup menu
		deleteUI shpUI_paintRegionCancelItem;
	}
	// enable/disable the popup menu items for the color buttons
	shapesUI_enableRegionColorButtonMenu (!$enable);
}


global proc shapesRegion_paintRegionColor( int $id )
{
	//
	// initialize the paint tool and set the color to white
	//
	global int $gShapes_currentRegion;
	global int $gShapes_regionProcess;
	global string $gShapes_regionBS;
	global string $gShapes_regionTarget;
	
	if (!$gShapes_regionProcess)
		return;
	
	select -r $gShapes_regionTarget;
	
	shapesWeights_activatePaintBlendShapeWeightsTool $gShapes_regionBS "" 0 1;
	
	// after editing a previous region
	// get the current values and add them to the region map
	// before resetting everything and preparing for editing the given region
	shapesRegion_storeLastRegionEdit;
	
	// display the current map in the mesh
	shapesRegion_initMeshPaint 0;
	br_editRegionMap -e -n SHAPESRegionData -i $id -bs $gShapes_regionBS;
	
	ArtPaintBlendShapeWeightsTool;
	artAttrCtx -e -value 1 -selectedattroper "absolute" `currentCtx`;
	
	$gShapes_currentRegion = $id;
	
	shapesRegion_updateColorButtons;
	iconTextButton -e -i ("SHAPES_regionColor" + ($id + 1) + "Paint.png") ("shpUI_regionColor" + $id);
}


global proc shapesRegion_storeLastRegionEdit()
{
	//
	// get the current values and add them to the region map
	//
	global int $gShapes_currentRegion;
	global string $gShapes_regionBS;
	
	if ($gShapes_currentRegion != -1)
	{
		int $distribute = `optionVar -q SHAPESDistributePartialRegionWeights`;
		br_editRegionMap -a -n SHAPESRegionData -i $gShapes_currentRegion -bs $gShapes_regionBS -dw $distribute;
		
		shapesRegion_initMeshPaint 0;
		
		// enable the display colors buttons
		iconTextButton -e -en 1 shpUI_regionShowColors;
		iconTextButton -e -en 1 shpUI_regionShowPartials;
	}
}


global proc shapesRegion_initMeshPaint( float $value )
{
	//
	// flood everything black to reset all vertices
	// only with a new map
	//
	global string $gShapes_regionBS;
	global string $gShapes_regionTarget;
	
	string $shape[] = `listRelatives -s $gShapes_regionTarget`;
	br_blendShapeEditWeights -flush $value -n $gShapes_regionBS -om $shape[0] -i -1;
	ArtPaintBlendShapeWeightsTool;
	artAttrCtx -e -value 1 -selectedattroper "absolute" `currentCtx`;
}


global proc shapesRegion_clearRegion( int $id )
{
	//
	// sets all vertex colors to black
	//
	global int $gShapes_regionProcess;
	global string $gShapes_regionBS;
	global string $gShapes_regionTarget;
	global string $gShapes_skinMesh;
	
	if (!$gShapes_regionProcess)
		return;
	
	select -r $gShapes_regionTarget;
	string $intermediate = shapesMain_getOriginalMesh($gShapes_skinMesh, 0);
	br_editRegionMap -cl -i $id -n SHAPESRegionData -m $intermediate;
	
	shapesRegion_initMeshPaint 0;
}


global proc shapesRegion_setFromSelectedWeightMap( int $id )
{
	//
	// set the vertex color based on the selected weight map
	//
	global int $gShapes_regionProcess;
	global string $gShapes_bsNode;
	global string $gShapes_regionBS;
	global string $gShapes_regionTarget;
	
	if (!$gShapes_regionProcess)
		return;
	
	select -r $gShapes_regionTarget;
	
	string $exportPath = shapesUtil_getExportPath("/weights/" + $gShapes_bsNode, 0);
	if ($exportPath == "")
		return;
	
	string $mapName[] = `textScrollList -q -si shpUI_shapeWeightsList`;
	if (!size($mapName))
		return;
	string $fileName = $exportPath + "/" + $mapName[0] + ".bsw";
	
	int $return = `br_blendShapeEditWeights -im -fn $fileName -n $gShapes_regionBS -i -1`;
	if ($return)
		print ("// Imported weight map \"" + $fileName + "\" //\n");
}


global proc shapesRegion_appendToRegion( int $id )
{
	//
	// append the unassigned weights to the given region
	//
	string $node = "SHAPESRegionData";
	br_editRegionMap -ap -n $node -i $id -m (shapesMain_getShapeNode());
	
	// select the mesh in order to display the updated vertex colors
	string $sel[] = `ls -sl -tr`;
	if (!size($sel))
	{
		// in case the mesh is not selected get the component selection
		// and derive the mesh from there
		$sel = `ls -sl -fl`;
		if (!size($sel))
			return;
		else
		{
			string $items[] = stringToStringArray($sel[0], ".");
			select -r $items[0];
		}
	}
	
	shapesRegion_showFullColorMap 0;
}


global proc SHAPES_regions(){}
