// --------------------------------------------------------------------------------------------------
//
// SHAPES
//
// blend shape editing tool for Maya
//
// required plugins:
//   SHAPESTools
//
// Ingo Clemens
// www.braverabbit.com
//
// copyright brave rabbit, Ingo Clemens 2014-2016
//
// --------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------
//
// THE SOFTWARE PRODUCT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
// IMPLIED, INCLUDING, BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NON-INFRINGEMENT OF THIRD-PARTY RIGHTS. THE ENTIRE RISK AS TO THE QUALITY AND
// PERFORMANCE OF THE SOFTWARE PRODUCT IS WITH YOU.
// NEITHER BRAVE RABBIT NOR ITS SUPPLIERS WARRANT THAT THE FUNCTIONS CONTAINED IN THE SOFTWARE
// PRODUCT WILL MEET YOUR REQUIREMENTS OR THAT THE OPERATION OF THE SOFTWARE PRODUCT WILL BE
// UNINTERRUPTED OR ERROR-FREE. BRAVE RABBIT IS NOT OBLIGATED TO PROVIDE ANY UPDATES TO THE
// SOFTWARE.
// IN NO EVENT SHALL THE AUTHOR OF THIS SOFTWARE PRODUCT BE LIABLE FOR ANY SPECIAL, CONSEQUENTIAL,
// INCIDENTAL, DIRECT OR INDIRECT DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
// LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, FOR PERSONAL INJURY, LOSS OF BUSINESS
// INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THIS
// PRODUCT, EVEN IF THE AUTHOR OF THIS SOFTWARE PRODUCT IS AWARE OF THE POSSIBILITY OF SUCH
// DAMAGES AND KNOWN DEFECTS, ANY CLAIM BY A THIRD PARTY AND EVEN IF THE REMEDY FAILS OF ITS
// ESSENTIAL PURPOSE.
//
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
// button actions for shape drivers and combos
// --------------------------------------------------------------------------------------------------

global proc shapesDriver_initButtonAction( int $btn, string $shape, int $state )
{
	//
	// call the action for the button and request confirmation if needed
	// {"buttons": [{"node": "blendShape1_smile", "ann": "", "type": "animation"}, {"node": "", "ann": "", "type": ""}], "target": "smile"}
	// incoming arguments:
	// button index, targetName, state
	//
	global int $gShapes_comboProcess;
	global int $gShapes_sequenceProcess;
	global string $gShapes_rampPlug;
	global string $gShapes_selectedTarget;
	global string $gShapes_bsData[];
	global string $gShapes_btnData[];
	global string $gShapes_orderedTargetList[];
	
	$gShapes_rampPlug = "";
	
	// show the options for editing the rampWeights node
	if ($btn == 2)
	{
		for ($item in $gShapes_bsData)
		{
			// if the selected item is not a helper attribute
			// select the target shape and show the weights ui
			string $tgt = dict_getStringValue($item, "target");
			if ($shape == $tgt && ! dict_getBoolValue($item, "helper"))
			{
				int $index = dict_getValue($item, "index");
				shapesWeights_editRampWeights $shape $index (dict_getStringValue($item, "ramp"));
			}
		}
		return;
	}
	
	if (!`optionVar -q SHAPESShowUIDriver`)
		return;
	
	// bail if the process of creating a combo is currently active
	if ($gShapes_comboProcess || $gShapes_sequenceProcess)
	{
		string $infoMsg = "creating a combo";
		if ($gShapes_sequenceProcess)
			$infoMsg = "editing the driver sequence";
		warning ("The target buttons are inactive while " + $infoMsg + " is in progress. Select the target shape from the list");
		return;
	}
	
	// get the id of the button
	int $idList[] = shapesMain_getButtonDataIds({$shape});
	
	// just for safety reasons if the list gets corrupted
	if (!size($idList))
		error "Unable to find selected target";
	int $id = $idList[0];
	
	// define the select action if the driver buttons are not sdk or shape driver
	// or if the combo button has a combo attached
	string $type[] = dict_getIndexedSubValue($gShapes_btnData[$id], "buttons", $btn, "type");
	string $ann[] = dict_getIndexedSubValue($gShapes_btnData[$id], "buttons", $btn, "ann");
	string $node[] = dict_getIndexedSubValue($gShapes_btnData[$id], "buttons", $btn, "node");
	if (($btn == 0 && $type[0] != "sdk" && $type[0] != "sdks" && $type[0] != "wd" && $type[0] != "combo" && $type[0] != "") || ($ann[0] == "Select"))
	{
		shapesUI_selectNode("button", {$node[0]}, $shape, "");
		return;
	}
	
	string $msg;
	int $create;
	int $driver;
	
	// create mode
	// if the shape driver button has no input or the combo button no output
	// or if the target is not controlled by a combo
	if (($btn == 0 && $type[0] == "") || ($btn == 1 && ($type[0] == "" || $type[0] == "combo")))
	{
		$msg = "Create ";
		$create = 1;
	}
	else
		$msg = "Delete ";
	
	string $buttonList[] = {"OK", "Cancel"};
	
	if ($btn == 0)
	{
		if ($type[0] == "combo")
		{
			if ($create)
				$msg += "Combo?";
			else
			{
				$msg = "Process Combo";
				$buttonList = {"Edit", "Delete", "Cancel"};
			}
		}
		else
		{
			if ($create)
				$msg += "Shape Driver?";
			else
			{
				$msg = "Process Shape Driver";
				$buttonList = {"Delete", " Edit Sequence ", "Cancel"};
			}
			$driver = 1;
		}
	}
	else
	{
		if (size($gShapes_orderedTargetList) && $gShapes_orderedTargetList[size($gShapes_orderedTargetList) - 1] == $shape)
		{
			if (dict_getStringValue(shapesDriver_getShapeSequence($shape), "sequencer") != "")
				error "Unable to create a combo with a shape which is driven by a sequence";
		}
		$msg += "Combo?";
	}
	
	string $cmd = "confirmDialog -t \"SHAPES\" -m \"" + $msg + "\" -b \"" + stringArrayToString($buttonList, "\" -b \"") + "\" -db \"Cancel\" -cb \"Cancel\" -ds \"Cancel\"";
	string $confirm = `eval $cmd`;
	if ($confirm == "Cancel")
		return;
	
	if ($create)
	{
		if ($driver)
			shapesDriver_createWeightDriver $shape 0 0;
		else
			shapesCombo_createCombo;
	}
	else
	{
		if ($driver)
		{
			if ($confirm == "Delete")
				shapesDriver_deleteWeightDriver $shape;
			else if ($confirm == " Edit Sequence ")
			{
				$gShapes_sequenceProcess = 1;
				shapesDriver_editDriverSequence $shape;
			}
		}
		else
		{
			if ($confirm == "Delete")
				shapesCombo_removeCombo $shape 0;
			else
			{
				$gShapes_comboProcess = 1;
				shapesCombo_editComboItems $shape;
			}
		}
	}
}


// --------------------------------------------------------------------------------------------------
// shape driver
// --------------------------------------------------------------------------------------------------

global proc shapesDriver_collectJointInfo()
{
	//
	// gather all necessary information for setting up the weight driver
	//
	global string $gShapes_currentSdkAttr;
	global string $gShapes_sdkAttrDict;
	global string $gShapes_skinMesh;
	
	if ($gShapes_skinMesh == "")
		return;
	
	string $node[] = `treeView -q -si shpUI_driverTree`;
	// make sure that there is only one item processed
	// because the list allows multiple selections
	if (size($node))
	{
		string $temp = $node[0];
		clear $node;
		$node[0] = $temp;
	}
	
	if (!size($node) || shapesMain_isDriverGroup($node[0]))
	{
		columnLayout -e -en 0 shpUI_driverSettingsColumn;
		$gShapes_sdkAttrDict = dict_setValue({$gShapes_sdkAttrDict}, 0, "None", "0");
		return;
	}
	else if (!`columnLayout -q -en shpUI_driverSettingsColumn`)
		columnLayout -e -en 1 shpUI_driverSettingsColumn;
	
	int $driverType = `optionMenu -q -sl shpUI_shapeDriverOption`;
	
	// check if the current selection is a joint or transform node
	// in case a default node is currently selected
	if (`nodeType $node[0]` != "joint" && `nodeType $node[0]` != "transform")
	{
		if ($driverType != 1)
		{
			optionMenu -e -sl 2 shpUI_shapeDriverOption;
			$driverType = 2;
		}
	}
	
	if ($driverType == 3)
	{
		// get the parent joint
		shapesDriver_getParentFromSelectedJoint;
		// guess the axis setting based on the selection
		int $dir = shapesDriver_getPrimaryAxis();
		// get the joint rotation and set the range slider
		shapesDriver_getMaxAngle $dir;
		
		floatFieldGrp -e -v1 10 shpUI_distanceMaxField;
	}
	else if ($driverType == 2)
	{
		// clear the stored attribute dictionary
		$gShapes_sdkAttrDict = "";
		$gShapes_currentSdkAttr = "";
		// store all keyable attributes in the dictionary
		$gShapes_sdkAttrDict = shapesDriver_sdkAttributeToDictionary($node[0]);
		// store the driver name
		$gShapes_sdkAttrDict = dict_setValue({$gShapes_sdkAttrDict}, 0, "shpCurrentSdkDriver", $node[0]);
		// refresh the option menu
		shapesDriver_refreshAttributeMenu;
	}
}


global proc shapesDriver_collectDriverInfo()
{
	//
	// get all relevant information from the weight driver and fill the ui
	//
	global int $gShapes_index;
	global string $gShapes_driverNodeType;
	global string $gShapes_mirrorDriver;
	global string $gShapes_selectedDriver;
	global string $gShapes_selectedTarget;
	global string $gShapes_bsData[];
	
	string $nodes[] = shapesDriver_getConnectedWeightDriver($gShapes_selectedTarget);
	if (!size($nodes))
	{
		shapesUI_addRampWeightsDrivenAttributeOption;
		return;
	}
	
	// clear the search field to make sure that the joint can be found in the list
	shapesUI_clearSearch "driver" 0;
	
	shapesUI_switchDriverUI;
	
	string $driver[];
	if ($gShapes_driverNodeType == "weightDriver")
	{
		string $parent[] = `listRelatives -p $nodes[0]`;
		textField -e -tx $parent[0] shpUI_parentField;
		$parent = `listRelatives -p $nodes[1]`;
		shapesUI_focusOnSelectedItem 0 "shpUI_driverTree" $parent[0];
		$gShapes_selectedDriver = $parent[0];
		$driver = `listRelatives -s $nodes[0]`;
		
		int $useAngle = `getAttr ($driver[0] + ".useRotate")`;
		checkBoxGrp -e -v1 $useAngle shpUI_useAngleCheck;
		float $angle = `getAttr ($driver[0] + ".angle")`;
		int $dir = `getAttr ($driver[0] + ".direction")`;
		int $invert = `getAttr ($driver[0] + ".invert")`;
		if ($invert == 1)
			$angle *= -1;
		floatFieldGrp -e -v1 $angle shpUI_rangeField;
		float $centerAngleVal = `getAttr ($driver[0] + ".centerAngle")`;
		floatFieldGrp -e -v1 $centerAngleVal shpUI_centerField;
		optionMenuGrp -e -sl ($dir + 1) shpUI_axisOption;
		int $interpolation = `getAttr ($driver[0] + ".interpolation")` + 1;
		optionMenuGrp -e -sl $interpolation shpUI_interpolateOption;
		float $twistVal = `getAttr ($driver[0] + ".twistAngle")`;
		floatFieldGrp -e -v1 $twistVal shpUI_twistAngleField;
		int $useTwist = `getAttr ($driver[0] + ".twist")`;
		checkBoxGrp -e -v1 $useTwist shpUI_useTwistCheck;
		
		int $useTranslate = `getAttr ($driver[0] + ".useTranslate")`;
		checkBoxGrp -e -v1 $useTranslate shpUI_useDistanceCheck;
		int $grow = `getAttr ($driver[0] + ".grow")`;
		checkBoxGrp -e -v1 $grow shpUI_useIncreaseCheck;
		float $minVal = `getAttr ($driver[0] + ".translateMin")`;
		floatFieldGrp -e -v1 $minVal shpUI_distanceMinField;
		float $maxVal = `getAttr ($driver[0] + ".translateMax")`;
		floatFieldGrp -e -v1 $maxVal shpUI_distanceMaxField;
		
		shapesUI_toggleDriverTranslateOptions;
	}
	else if ($gShapes_driverNodeType == "animCurve" && $nodes[1] == "sdk")
	{
		string $plug[] = `listConnections -p 1 -scn 1 ($nodes[0] + ".input")`;
		$driver = stringToStringArray($plug[0], ".");
		string $attr = $driver[1];
		
		// check if the found driver is in the joint list
		// if the driver is from a node which is not listed
		// add the driver to the list of drivers
		if (!`treeView -q -iex $driver[0] shpUI_driverTree`)
			shapesMain_storeCustomDriver $driver[0] 0;
		
		shapesUI_focusOnSelectedItem 0 "shpUI_driverTree" $driver[0];
		$gShapes_selectedDriver = $driver[0];
			
		// get values from the sdk curve
		float $valuePair[] = shapesDriver_getSdkValues($nodes[0]);
		if (!size($valuePair))
			return;
		
		shapesDriver_setSdkAttributes $attr $valuePair[0] $valuePair[2];
		//print $valuePair
		
		// get the tangents
		string $tangents[] = `keyTangent -q -itt $nodes[0]`;
		if (size($tangents) == 2)
		{
			int $interpolation = 1;
			if ($tangents[0] == "spline" && $tangents[1] == "flat")
			{
				$interpolation = 2;
				// in case of a negative value range
				// the interpolation types slow/fast need to be switched
				if ($valuePair[0] > $valuePair[2])
					$interpolation = 3;
			}
			else if ($tangents[0] == "flat" && $tangents[1] == "spline")
			{
				$interpolation = 3;
				// in case of a negative value range
				// the interpolation types slow/fast need to be switched
				if ($valuePair[0] > $valuePair[2])
					$interpolation = 2;
			}
			else if ($tangents[0] == "flat" && $tangents[1] == "flat")
				$interpolation = 4;
			optionMenuGrp -e -sl $interpolation shpUI_interpolateOption;
		}
		else
			warning ($nodes[0] + " has insufficient keyframe information");
		
		// get the infinity
		int $preInf = `getAttr ($nodes[0] + ".preInfinity")`;
		int $postInf = `getAttr ($nodes[0] + ".postInfinity")`;
		if ($preInf == 0 && $postInf == 0)
			optionMenuGrp -e -sl 1 shpUI_infinityOption;
		else if ($preInf >= 1 && $postInf == 0)
			optionMenuGrp -e -sl 2 shpUI_infinityOption;
		else if ($preInf == 0 && $postInf >= 1)
			optionMenuGrp -e -sl 3 shpUI_infinityOption;
		else if ($preInf >= 1 && $postInf >= 1)
			optionMenuGrp -e -sl 4 shpUI_infinityOption;
	}
	$gShapes_mirrorDriver = $nodes[0];
	
	if ($gShapes_index != -1)
	{
		string $rampPlug = dict_getStringValue($gShapes_bsData[$gShapes_index], "ramp");
		string $rampNode[] = stringToStringArray($rampPlug, ".");
		if ($rampPlug != "" && `gmatch $rampPlug "*.*"` && `optionMenu -q -ex shpUI_rampAttrOption`)
		{
			optionMenu -e -v $rampNode[1] shpUI_rampAttrOption;
		}
	}
}


global proc shapesDriver_getParentFromSelectedJoint()
{
	//
	// return the parent node of the selected skin joint
	//
	global string $gShapes_selectedDriver;
	
	string $node[] = `treeView -q -si shpUI_driverTree`;
	$gShapes_selectedDriver = $node[0];
	
	if (`optionMenu -q -sl shpUI_shapeDriverOption` != 3)
		return;
	
	string $parent[] = `listRelatives -p $node[0]`;
	if (size($parent))
		textField -e -tx $parent[0] shpUI_parentField;
}


global proc int shapesDriver_getPrimaryAxis()
{
	//
	// find the primary axis
	// returns if the axis is positive or negative
	// which is important for getting the max angle for the weight driver
	//
	string $node[] = `treeView -q -si shpUI_driverTree`;
	
	// go through the children
	// find a child that is offset to the selected joint
	// the translation offset should tell about the axis orientation
	string $offsetNode = shapesDriver_getJointTranslation($node[0]);
	float $pos[];
	if ($offsetNode != "")
		$pos = `getAttr ($offsetNode + ".t")`;
	else
		$pos = `getAttr($node[0] + ".t")`;
	
	int $axis = 1;
	int $dir = 1;
	if ((abs($pos[0]) > abs($pos[1])) && (abs($pos[0]) > abs($pos[2])))
	{
		$axis = 1;
		if ($pos[0] < 0)
			$dir = -1;
	}
	else if (abs($pos[1]) > abs($pos[2]))
	{
		$axis = 2;
		if ($pos[1] < 0)
			$dir = -1;
	}
	else
	{
		$axis = 3;
		if ($pos[2] < 0)
			$dir = -1;
	}
	
	optionMenuGrp -e -sl $axis shpUI_axisOption;
	
	return $dir;
}


global proc shapesDriver_getMaxAngle( int $dir )
{
	//
	// find the axis with the greatest angle
	//
	string $node[] = `treeView -q -si shpUI_driverTree`;
	
	float $value;
	float $rot[] = `getAttr ($node[0] + ".r")`;
	if ((abs($rot[0]) > abs($rot[1])) && (abs($rot[0]) > abs($rot[2])))
		$value = $rot[0];
	else if (abs($rot[1]) > abs($rot[2]))
		$value = $rot[1];
	else
		$value = $rot[2];
	
	// make sure the axis orientation is reflected in the range value for the weight driver
	// the rotation value is made absolut and then multiplied by the direction,
	// which was defined when getting the primary axis
	$value = abs($value) * $dir;
	if ($value == 0)
		$value = 45;
	
	floatFieldGrp -e -v1 $value shpUI_rangeField;
}


global proc string shapesDriver_getJointTranslation( string $node )
{
	//
	// for finding the primary axis for a joint when setting up the weight driver
	// goes recoursively through the children to find a joint with a translation value
	// this is necessary for particular rig joints which are in place on top of each other
	// returns the name of the joint with the offset
	//
	string $rel[] = `listRelatives -c -type "transform" $node`;
	int $endOfChain;
	string $result;
	while ($endOfChain == 0)
	{
		if (size($rel))
		{
			for ($r in $rel)
			{
				float $pos[] = `getAttr ($r + ".t")`;
				float $posSum = floor(($pos[0] + $pos[1] + $pos[2]) * 1000) / 1000;
				if (abs($posSum) > 0.1)
				{
					return $r;
				}
				$result = shapesDriver_getJointTranslation($r);
			}
			$endOfChain = 1;
		}
		else
			$endOfChain = 1;
	}
	if ($result == "")
		return $node;
	
	return $result;
}


global proc string shapesDriver_createWeightDriver( string $target, int $mirror, int $center )
{
	//
	// create the weight driver node and make connections
	//
	global int $gShapes_index;
	global int $gShapes_namespaceExists;
	global string $gShapes_bsNode;
	global string $gShapes_mirrorDriver;
	global string $gShapes_rampPlug;
	global string $gShapes_selectedTarget;
	global string $gShapes_bsData[];
	
	string $queryPlug;
	if ($gShapes_rampPlug == "")
		$queryPlug = shapesMain_getQueryPlug($target);
	else
		$queryPlug = $gShapes_rampPlug;
	
	// discontinue if the target is already connected
	string $connections[] = `listConnections -s 1 -d 0 $queryPlug`;
	if (size($connections))
		error ($queryPlug + " is already connected");
	
	// discontinue if no weight driver should be created
	if (`optionMenu -q -sl shpUI_shapeDriverOption` == 1)
		return "";
	
	string $nodeItem[] = `treeView -q -si shpUI_driverTree`;
	if (!size($nodeItem) || shapesMain_isDriverGroup($nodeItem[0]))
		error "No driving node selected";
	string $node = $nodeItem[0];
	
	int $interpolationVal = `optionMenuGrp -q -sl shpUI_interpolateOption` - 1;
	
	//-----------------
	// weight driver
	//-----------------
	if (`optionMenu -q -sl shpUI_shapeDriverOption` == 3)
	{
		string $parent = `textField -q -tx shpUI_parentField`;
		if ($parent == "")
			error "No parent node defined for the driving joint";
		
		// get the direction
		string $dir[] = {"x", "y", "z"};
		int $mult = 1;
		float $angle = `floatFieldGrp -q -v1 shpUI_rangeField`;
		int $invert;
		if ($angle < 0 && $mirror != 1)
		{
			$invert = 1;
			$mult = -1;
		}
		int $axisVal = `optionMenuGrp -q -sl shpUI_axisOption` - 1;
		
		// create the weight driver
		string $driverShape = `createNode weightDriver`;
		string $driver[] = `listRelatives -p $driverShape`;
		setAttr -l 1 ($driver[0] + ".v");
		
		// create the locator to act as the driver
		string $loc[] = `spaceLocator`;
		parent $loc[0] $node;
		
		// position the nodes
		delete(`pointConstraint $node $driver[0]`);
		delete(`orientConstraint $node $driver[0]`);
		delete(`pointConstraint $node $loc[0]`);
		parent $driver[0] $parent;
		
		// correctly rotate the weight driver if in mirror mode
		if ($mirror == 1)
		{
			select -cl;
			string $joint1 = `joint`;
			delete(`pointConstraint $gShapes_mirrorDriver $joint1`);
			delete(`orientConstraint $gShapes_mirrorDriver $joint1`);
			select -cl;
			string $joint2 = `joint`;
			parent $joint1 $joint2;
			string $joint3[] = `mirrorJoint -myz -mb`;
			delete(`orientConstraint $joint3[0] $driver[0]`);
			delete $joint2;
			if (!`optionVar -q SHAPESBehaviorMirror`)
				$invert = 1 - $invert;
		}
		
		if ($center == 1)
			$invert = 1 - $invert;
		
		// get the center angle field just here because it only present with the weight driver
		int $useAngle = `checkBoxGrp -q -v1 shpUI_useAngleCheck`;
		float $centerAngleVal = `floatFieldGrp -q -v1 shpUI_centerField`;
		float $twistVal = `floatFieldGrp -q -v1 shpUI_twistAngleField`;
		int $useTwist = `checkBoxGrp -q -v1 shpUI_useTwistCheck`;
		int $useTranslate = `checkBoxGrp -q -v1 shpUI_useDistanceCheck`;
		int $grow = `checkBoxGrp -q -v1 shpUI_useIncreaseCheck`;
		float $minVal = `floatFieldGrp -q -v1 shpUI_distanceMinField`;
		float $maxVal = `floatFieldGrp -q -v1 shpUI_distanceMaxField`;
		
		int $translateMult = 1;
		if (!$useAngle && $useTranslate)
			$translateMult = 0;
		
		// position the locator along the driver axis
		setAttr ($loc[0] + ".t" + $dir[$axisVal]) (10 * $mult * $translateMult);
		delete(`orientConstraint $node $loc[0]`);
		setAttr ($loc[0] + ".v") 0;
		
		// set the weight driver attributes
		setAttr ($driver[0] + ".useRotate") $useAngle;
		setAttr ($driverShape + ".direction") $axisVal;
		setAttr ($driverShape + ".invert") $invert;
		setAttr ($driverShape + ".angle") (abs($angle));
		setAttr ($driverShape + ".centerAngle") $centerAngleVal;
		setAttr ($driverShape + ".interpolation") $interpolationVal;
		setAttr ($driverShape + ".twistAngle") $twistVal;
		setAttr ($driverShape + ".twist") $useTwist;
		setAttr ($driver[0] + ".useTranslate") $useTranslate;
		setAttr ($driver[0] + ".grow") $grow;
		setAttr ($driver[0] + ".translateMin") $minVal;
		setAttr ($driver[0] + ".translateMax") $maxVal;
		
		string $attr[] = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"};
		int $skip = 0;
		if ($useTranslate)
			$skip = 3;
		for ($a = $skip; $a < size($attr); $a ++)
			setAttr -l 1 -k 0 ($loc[0] + "." + $attr[$a]);
		
		// add the message attribute
		addAttr -at "message" -ln "SHAPES_wd" $driverShape;
		
		// make the connections
		connectAttr ($driver[0] + ".worldMatrix[0]") ($driverShape + ".readerMatrix");
		connectAttr ($loc[0] + ".worldMatrix[0]") ($driverShape + ".driverMatrix");
		connectAttr ($driverShape + ".outWeight") $queryPlug;
		
		// deactive/active the driver to force an update
		setAttr ($driverShape + ".nodeState") 1;
		refresh;
		setAttr ($driverShape + ".nodeState") 0;
		refresh;
		
		if ($gShapes_rampPlug != "")
		{
			string $plugItems[] = stringToStringArray($gShapes_rampPlug, ".");
			string $name = $plugItems[0] + "_" + $plugItems[1];
			$driverName = $name + "_WD";
			rename $loc[0] ($name + "_loc");
			rename $driver[0] $driverName;
			select -cl;
			return $driverName;
		}
	}
	//-----------------
	// set driven key
	//-----------------
	else
	{
		string $attr = `optionMenu -q -v shpUI_sdkAttrOption`;
		float $range[] = `floatFieldGrp -q -v shpUI_sdkRangeField`;
		
		string $tangent[] = {"spline", "spline"};
		if ($interpolationVal == 1)
			$tangent = {"spline", "flat"};
		if ($interpolationVal == 2)
			$tangent = {"flat", "spline"};
		if ($interpolationVal == 3 || $interpolationVal == 4)
			$tangent = {"flat", "flat"};
		
		setDrivenKeyframe -dv $range[0] -v 0 -itt $tangent[0] -ott $tangent[0] -cd ($node + "." + $attr) $queryPlug;
		setDrivenKeyframe -dv $range[1] -v 1 -itt $tangent[1] -ott $tangent[1] -cd ($node + "." + $attr) $queryPlug;
		
		// set the infinity
		int $infValue = `optionMenuGrp -q -sl shpUI_infinityOption`;
		
		$node = $gShapes_bsNode;
		$attr = $target;
		if (dict_getBoolValue($gShapes_bsData[$gShapes_index], "set"))
		{
			$node = $target;
			$attr = "value";
		}
		else if ($gShapes_rampPlug != "")
		{
			string $plugItems[] = stringToStringArray($gShapes_rampPlug, ".");
			$node = $plugItems[0];
			$attr = $plugItems[1];
		}
		if ($gShapes_namespaceExists)
			$node = shapesMain_shortenNodePath($node, 0);
		shapesDriver_setCurveInfinity ($node + "_" + $attr) $infValue;
		
		// add the message attribute
		addAttr -at "message" -ln "SHAPES_sdk" ($node + "_" + $attr);
		
		// rename in case of the driver for the rampWeights node
		if ($gShapes_rampPlug != "")
		{
			$driverName = `rename ($node + "_" + $attr) ($node + "_" + $attr + "_WD")`;
			select -cl;
			return $driverName;
		}
	}
	// rename the weight driver
	string $driverName = shapesDriver_renameWeightDriver($target);
	// only return the driver name if it's a weight driver
	if (`optionMenu -q -sl shpUI_shapeDriverOption` != 3)
		$driverName = "";
	
	if ($mirror == 0)
	{
		$gShapes_selectedTarget = $target;
		shapesMain_refreshTargetItem {$target};
	}
	
	select -cl;
	
	return $driverName;
}


global proc shapesDriver_deleteWeightDriver( string $target )
{
	//
	// delete the weight driver from the selected target
	//
	global string $gShapes_rampPlug;
	
	if ($target == "" && $gShapes_rampPlug == "")
		return;
	
	string $refreshList[] = shapesDriver_performDeleteWeightDriver($target);
	shapesMain_refreshTargetItem $refreshList;
}


global proc string[] shapesDriver_performDeleteWeightDriver( string $target )
{
	//
	// execute the weight driver removal
	//
	global string $gShapes_bsNode;
	global string $gShapes_driverPlug[];
	
	string $refreshList[] = {$target};
	string $nodes[] = shapesDriver_getConnectedWeightDriver($target);
	if (size($nodes))
	{
		string $sequence = $nodes[2];
		stringArrayRemoveAtIndex(2, $nodes);
		if ($nodes[1] != "" && ($nodes[1] == "sdk" || $nodes[1] == "animCurve"))
			stringArrayRemoveAtIndex(1, $nodes);
		if ($nodes[0] != $gShapes_bsNode)
		{
			delete $nodes;
			if ($sequence != "")
			{
				delete (dict_getValueArray($sequence, "curves"));
				// just try to remove the network node
				// but it should have been deleted by deleting the sdk curves
				if (`objExists (dict_getStringValue($sequence, "sequencer"))`)
					delete (dict_getStringValue($sequence, "sequencer"));
				$refreshList = dict_getValueArray($sequence, "targets");
			}
		}
		clear $gShapes_driverPlug;
	}
	return $refreshList;
}


global proc string shapesDriver_renameWeightDriver( string $target )
{
	//
	// rename the weight driver and the connected nodes according to the driving target
	//
	global string $gShapes_bsNode;
	global string $gShapes_driverNodeType;
	global string $gShapes_mirrorDriver;
	
	string $name = $gShapes_bsNode + "_" + $target;
	string $driverName;
	
	string $nodes[] = shapesDriver_getConnectedWeightDriver($target);
	if (!size($nodes))
		;
	else if ($nodes[0] != $gShapes_bsNode)
	{
		$driverName = $name + "_WD";
		if ($gShapes_driverNodeType == "weightDriver")
			rename $nodes[1] ($name + "_loc");
		if ($nodes[1] == "animCurve")
		{
			shapesCombo_renameComboMultiplier $target;
			return "";
		}
		rename $nodes[0] $driverName;
		$gShapes_mirrorDriver = $driverName;
		
		// rename the sequencer node
		if ($nodes[2] != "")
			rename (dict_getStringValue($nodes[2], "sequencer")) ("SHAPES_" + $target + "_sequence_net");
	}
	
	shapesCombo_renameComboMultiplier $target;
	
	return $driverName;
}


global proc string[] shapesDriver_getConnectedWeightDriver( string $target )
{
	//
	// find the connected weight driver and the locator node
	//
	global string $gShapes_bsNode;
	global string $gShapes_driverNodeType;
	global string $gShapes_rampPlug;
	
	if ($target == "" && $gShapes_rampPlug == "")
		return {};
	
	$gShapes_driverNodeType = "";
	
	string $queryPlug;
	if ($gShapes_rampPlug == "")
		$queryPlug = shapesMain_getQueryPlug($target);
	else
		$queryPlug = $gShapes_rampPlug;
	
	// check if the target is controlled by a combo multiplier
	string $conn[] = shapesMain_verifyShapeConnections($queryPlug, 0);
	string $comboList[] = dict_stringToCleanArray($conn[0], "%");
	
	// usually the source plug to query connections from is the blend shape target channel
	// but in case of a driver sequence the source plug must be on the network node
	// which is the first entry in the combo list
	if ($comboList[2] != "")
		$queryPlug = dict_getStringValue($comboList[2], "sequencer") + ".driverValue";
	
	string $plug[];
	string $multNode;
	if ($comboList[1] == "combo")
	{
		$multNode = $comboList[0];
		$plug = `listConnections -type "weightDriver" ($multNode + ".i2x")`;
	}
	else
		$plug = `listConnections -sh 1 -type "weightDriver" $queryPlug`;
	
	if (!size($plug))
	{
		if ($comboList[1] == "combo")
		{
			if (shapesCombo_verifyShapeBasedCombo($multNode))
			{
				$gShapes_driverNodeType = "blendShape";
				optionMenu -e -sl 1 shpUI_shapeDriverOption;
				return {$gShapes_bsNode, "", $comboList[2]};
			}
			$plug = `listConnections -type "animCurve" ($multNode + ".i2x")`;
		}
		else
			$plug = `listConnections -s 1 -d 0 -type "animCurve" $queryPlug`;
		
		if (!size($plug))
		{
			optionMenu -e -sl 1 shpUI_shapeDriverOption;
			return {};
		}
		else
		{
			string $input[] = `listConnections -scn 1 ($plug[0] + ".input")`;
			if (size($input))
			{
				$gShapes_driverNodeType = "animCurve";
				optionMenu -e -sl 2 shpUI_shapeDriverOption;
			}
			else
			{
				optionMenu -e -sl 1 shpUI_shapeDriverOption;
				return {};
			}
		}
	}
	else
	{
		$gShapes_driverNodeType = "weightDriver";
		optionMenu -e -sl 3 shpUI_shapeDriverOption;
	}
	
	string $driver = $plug[0];
	
	if ($gShapes_driverNodeType == "animCurve")
	{
		string $curveType = shapesMain_verifyShapeDriverNode($driver, "sdk", "animCurve");
		if ($curveType == "animCurve")
			optionMenu -e -sl 1 shpUI_shapeDriverOption;
		return {$driver, $curveType, $comboList[2]};
	}
	
	string $driverTransform[] = `listRelatives -p $driver`;
	string $loc[] = `listConnections -p 1 ($driver + ".driverMatrix")`;
	$loc = stringToStringArray($loc[0], ".");
	return {$driverTransform[0], $loc[0], $comboList[2]};
}


global proc int[] shapesDriver_performMirrorDriverSettings()
{
	//
	// mirror joint names and settings for creating a mirrored driver
	//
	global int $gShapes_exportProcess;
	global string $gShapes_currentSdkAttr;
	
	string $node[] = `treeView -q -si shpUI_driverTree`;
	
	if (!size($node) || shapesMain_isDriverGroup($node[0]))
		return {-1};
	
	int $driverType = `optionMenu -q -sl shpUI_shapeDriverOption`;
	
	// store the original node name
	// if the node contains a side label the axis will be inverted, but
	// if the node is a center node the axis will remain the same in
	// case of the weight driver
	string $sourceNode = $node[0];
	
	float $sourceRotList[];
	float $sourceAngle;
	float $srcValues[];
	float $sourceStartAngle;
	string $attr;
	// store the source range value before the mirrored node gets selected
	// this is for comparison to check if the mirrored side is posed
	if ($driverType == 3)
	{
		$sourceRotList = `getAttr ($sourceNode + ".rotate")`;
		$sourceAngle = `floatFieldGrp -q -v1 shpUI_rangeField`;
		// store the source settings
		$srcValues = shapesDriver_getSetShapeDriverOptions("weightDriver", 1, {});
		shapesDriver_setGetWeightDriverBlendCurve 1 "";
	}
	else if ($driverType == 2)
	{
		$sourceStartAngle = `floatFieldGrp -q -v1 shpUI_sdkRangeField`;
		$sourceAngle = `floatFieldGrp -q -v2 shpUI_sdkRangeField`;
		// store the source settings
		$srcValues = shapesDriver_getSetShapeDriverOptions("sdk", 1, {});
		$attr = $gShapes_currentSdkAttr;
	}
	
	$node[0] = shapesMirror_swapSideLabel($node[0]);
	if (`treeView -q -iex $node shpUI_driverTree`)
	{
		// clear the search field
		shapesUI_clearSearch "driver" 0;
		shapesUI_focusOnSelectedItem 0 "shpUI_driverTree" $node[0];
	}
	else
	{
		// try to find the node in the scene and add it to the list if needed
		if (`objExists $node[0]`)
			shapesMain_storeCustomDriver $node[0] 0;
		else
			return {-1};
	}
	
	// restore the driver selection which might have changed after storing the new custom driver
	optionMenu -e -sl $driverType shpUI_shapeDriverOption;
	
	int $invert = -1;
	int $center;
	if ($driverType == 3)
	{
		// the parent name has been already updated due to selecting the mirrored driver
		// now we need to check if the node exists
		string $parent = `textField -q -tx shpUI_parentField`;
		if (`objExists $parent`)
			;
		else
			return {-1};
		
		// for the weight driver:
		// if the driver node is at the center the axis value doesn't need to be inverted
		// only invert the value if it's the opposite node, because then the axis will
		// be inverted too
		if ($node[0] == $sourceNode)
		{
			$invert = 1;
			$center = 1;
		}
	}
	else if ($driverType == 2)
	{
		// for the set driven key:
		// the axis value needs to be inverted if the joint is at the center
		// if the joint is on the opposite side, the value doesn't need to be inverted
		if (`nodeType $node[0]` == "joint")
		{
			if ($node[0] != $sourceNode)
			{
				if (`optionVar -q SHAPESBehaviorMirror`)
					$invert = 1;
			}
			else
				$center = 1;
		}
		else if ($node[0] == $sourceNode)
		{
			$invert = 1;
			$center = 1;
		}
		else
		{
			if (!`optionVar -q SHAPESBehaviorMirror`)
				$invert = 1;
		}
	}
	
	int $posed;
	float $targetRotList[];
	float $sourceRot[];
	float $targetRot[];
	if ($driverType == 3)
	{
		$targetRotList = `getAttr ($node[0] + ".rotate")`;
		for ($i = 0; $i < 3; $i ++)
		{
			$sourceRot[$i] = shapesDriver_roundFloat($sourceRotList[$i], 3);
			$targetRot[$i] = shapesDriver_roundFloat($targetRotList[$i], 3);
		}
		if ($sourceRot[0] == $targetRot[0] && $sourceRot[1] == $targetRot[1] && $sourceRot[2] == $targetRot[2])
			$posed = 1;
		else if (!`optionVar -q SHAPESBehaviorMirror`)
		{
			for ($i = 0; $i < 3; $i ++)
			{
				$sourceRot[$i] = shapesDriver_roundFloat(abs($sourceRot[$i]), 2);
				$targetRot[$i] = shapesDriver_roundFloat(abs($targetRot[$i]), 2);
			}
			if ($sourceRot[0] == $targetRot[0] && $sourceRot[1] == $targetRot[1] && $sourceRot[2] == $targetRot[2])
				$posed = 1;
		}
	}
	else if ($driverType == 2)
	{
		// switch to the same attribute of the driver as before
		// it might have changed due to selecting the opposite driver
		if (catch(`eval ("optionMenu -e -v " + $attr + " shpUI_sdkAttrOption")`))
			error "The driving attribute cannot be found on the target side";
		// it's not necessary to check for a posed model when working with sdk
		$posed = 1;
	}
	
	if (!$posed && !$gShapes_exportProcess)
	{
		confirmDialog	-t "SHAPES" 
						-m "The model is not posed.\n\nTo mirror a shape with a shape driver the target side needs to be posed to match the pose of the source side." 
						-b "OK" 
						-db "OK" 
						-cb "OK" 
						-ds "OK";
		return {-1};
	}
	
	if ($driverType == 3)
	{
		shapesDriver_getSetShapeDriverOptions "weightDriver" 0 $srcValues;
		floatFieldGrp -e -v1 ($sourceAngle * $invert) shpUI_rangeField;
	}
	else if ($driverType == 2)
	{
		shapesDriver_getSetShapeDriverOptions "sdk" 0 $srcValues;
		floatFieldGrp -e -v1 ($sourceStartAngle * $invert) shpUI_sdkRangeField;
		floatFieldGrp -e -v2 ($sourceAngle * $invert) shpUI_sdkRangeField;
	}
	
	return {1, $center};
}


global proc float shapesDriver_roundFloat( float $val, int $digits )
{
	//
	// round the float value
	//
	int $pos = pow(10, $digits);
	$val = floor(($val + 0.5 / $pos) * $pos) / $pos;
	return $val;
}


global proc float[] shapesDriver_getSetShapeDriverOptions( string $type, int $read, float $values[] )
{
	//
	// reads or sets the options and values for the shape driver
	//
	if ($read)
	{
		if ($type == "weightDriver")
		{
			float $axisVal = `optionMenuGrp -q -sl shpUI_axisOption`;
			float $angle = `floatFieldGrp -q -v1 shpUI_rangeField`;
			float $twistVal = `floatFieldGrp -q -v1 shpUI_twistAngleField`;
			float $interpolate = `optionMenuGrp -q -sl shpUI_interpolateOption`;
			float $centerAngleVal = `floatFieldGrp -q -v1 shpUI_centerField`;
			float $useTwist = `checkBoxGrp -q -v1 shpUI_useTwistCheck`;
			int $useAngle = `checkBoxGrp -q -v1 shpUI_useAngleCheck`;
			int $useTranslate = `checkBoxGrp -q -v1 shpUI_useDistanceCheck`;
			int $grow = `checkBoxGrp -q -v1 shpUI_useIncreaseCheck`;
			float $minVal = `floatFieldGrp -q -v1 shpUI_distanceMinField`;
			float $maxVal = `floatFieldGrp -q -v1 shpUI_distanceMaxField`;
			$values = {$axisVal, $angle, $twistVal, $interpolate, $centerAngleVal, $useTwist, $useAngle, $useTranslate, $grow, $minVal, $maxVal};
		}
		else
		{
			float $attr = `optionMenu -q -sl shpUI_sdkAttrOption`;
			float $range[] = `floatFieldGrp -q -v shpUI_sdkRangeField`;
			float $interpolate = `optionMenuGrp -q -sl shpUI_interpolateOption`;
			float $infValue = `optionMenuGrp -q -sl shpUI_infinityOption`;
			$values = {$attr, $range[0], $range[1], $interpolate, $infValue};
		}
	}
	else
	{
		if ($type == "weightDriver")
		{
			optionMenuGrp -e -sl $values[0] shpUI_axisOption;
			floatFieldGrp -e -v1 $values[1] shpUI_rangeField;
			floatFieldGrp -e -v1 $values[2] shpUI_twistAngleField;
			optionMenuGrp -e -sl $values[3] shpUI_interpolateOption;
			floatFieldGrp -e -v1 $values[4] shpUI_centerField;
			checkBoxGrp -e -v1 $values[5] shpUI_useTwistCheck;
			checkBoxGrp -e -v1 $values[6] shpUI_useAngleCheck;
			checkBoxGrp -e -v1 $values[7] shpUI_useDistanceCheck;
			checkBoxGrp -e -v1 $values[8] shpUI_useIncreaseCheck;
			floatFieldGrp -e -v1 $values[9] shpUI_distanceMinField;
			floatFieldGrp -e -v1 $values[10] shpUI_distanceMaxField;
		}
		else
		{
			optionMenu -e -sl $values[0] shpUI_sdkAttrOption;
			floatFieldGrp -e -v1 $values[1] -v2 $values[2] shpUI_sdkRangeField;
			optionMenuGrp -e -sl $values[3] shpUI_interpolateOption;
			optionMenuGrp -e -sl $values[4] shpUI_infinityOption;
		}
	}
	return $values;
}


global proc string shapesDriver_setGetWeightDriverBlendCurve( int $read, string $node )
{
	//
	// get/set the weight driver blend curve when mirroring or exporting;
	// in read mode the node is not given but queried here if not exporting;
	// in write mode (export/transfer) the node is given
	//
	global float $gShapes_blendCurveValues[];
	global string $gShapes_selectedTarget;
	
	string $attrString;
	
	if ($read)
	{
		if ($node == "")
		{
			if ($gShapes_selectedTarget == "")
				return "";
	
			string $queryPlug = shapesMain_getQueryPlug($gShapes_selectedTarget);
	
			string $driver[] = shapesMain_verifyShapeConnections($queryPlug, 0);
			if (!size($driver))
				return "";
	
			string $driverItems[] = dict_stringToCleanArray($driver[0], "%");
	
			$node = $driverItems[0];
		}
		
		float $values[];
		int $indices[] = `getAttr -mi ($node + ".blendCurve")`;
		for ($id in $indices)
		{
			$values[size($values)] = `getAttr ($node + ".blendCurve[" + $id + "].blendCurve_Position")`;
			$values[size($values)] = `getAttr ($node + ".blendCurve[" + $id + "].blendCurve_FloatValue")`;
			$values[size($values)] = `getAttr ($node + ".blendCurve[" + $id + "].blendCurve_Interp")`;
		}
		
		$gShapes_blendCurveValues = $values;
	}
	else
	{
		int $indices[] = `getAttr -mi ($node + ".blendCurve")`;
		for ($i = 0; $i < size($indices); $i ++)
		{
			if ($indices[$i] != 0)
				removeMultiInstance -b 1 ($node + ".blendCurve[" +  $indices[$i] + "]");
		}
		
		int $id = 0;
		for ($i = 0; $i < size($gShapes_blendCurveValues); $i += 3)
		{
			$attrString += "setAttr " + $node + ".blendCurve[" + $id + "].blendCurve_Position " + $gShapes_blendCurveValues[$i] + ";\n";
			$attrString += "setAttr " + $node + ".blendCurve[" + $id + "].blendCurve_FloatValue " + $gShapes_blendCurveValues[$i + 1] + ";\n";
			$attrString += "setAttr " + $node + ".blendCurve[" + $id + "].blendCurve_Interp " + $gShapes_blendCurveValues[$i + 2] + ";\n";
			$id ++;
		}
	}
	return $attrString;
}


// --------------------------------------------------------------------------------------------------
// shape driver actions
// --------------------------------------------------------------------------------------------------

global proc shapesDriver_selectDriver()
{
	//
	// select the weight driver of the target
	//
	global string $gShapes_selectedTarget;
	
	string $nodes[] = shapesDriver_getConnectedWeightDriver($gShapes_selectedTarget);
	if (!size($nodes))
		return;
	select $nodes[0];
}


global proc shapesDriver_attachDetachDriver( int $mode, int $ignore, int $sliderDrag )
{
	//
	// connect/disconnect the driving node to freely adjust the blendshape slider
	//
	global int $gShapes_unlinkSlider;
	global int $gShapes_updateValueState;
	global string $gShapes_bsNode;
	global string $gShapes_selectedTarget;
	global string $gShapes_driverPlug[];
	
	if ($ignore && !$gShapes_unlinkSlider)
	{
		$gShapes_unlinkSlider = 1;
		if (!$mode)
			print "// The shape driver has been unlinked. Select the target item again to re-link. //\n";
	}
	else if ($ignore && $gShapes_unlinkSlider)
		$gShapes_unlinkSlider = 0;
	
	// reset the status to force a re-connect if a new shape is selected to make sure
	// that the connection returns to it's default
	if ($mode && $ignore)
		$gShapes_unlinkSlider = 0;
	
	string $queryPlug = $gShapes_bsNode + "." + $gShapes_selectedTarget;
	// get the query plug
	// when a mesh gets loaded this method is called through main.getSelection;
	// at this point $gShapes_index is not yet set and causes an error
	// so we need to check if there is actually an attribute to query
	if (!$mode)
	{
		if ($gShapes_selectedTarget != "")
			$queryPlug = shapesMain_getQueryPlug($gShapes_selectedTarget);
		else
			return;
	}
	
	// disconnect
	if (!$mode)
	{
		$gShapes_updateValueState = 0;
		string $plug[] = `listConnections -s 1 -d 0 -p 1 $queryPlug`;
		if (size($plug))
		{
			string $type = `nodeType $plug[0]`;
			// no need to disconnect if the driver is an animation curve
			if (!`gmatch $type "animCurve*"`)
			{
				$gShapes_driverPlug = {$plug[0], $queryPlug};
				catchQuiet(`disconnectAttr $plug[0] $queryPlug`);
			}
		}
	}
	// connect
	else
	{
		$gShapes_updateValueState = 1;
		if (`iconTextCheckBox -q -v shpUI_filterLiveCheck`)
			shapesJob_updateDisplayValue;
		if (!$gShapes_unlinkSlider)
		{
			if (size($gShapes_driverPlug))
			{
				catchQuiet(`connectAttr $gShapes_driverPlug[0] $gShapes_driverPlug[1]`);
				clear $gShapes_driverPlug;
			}
		}
	}
	// update the other selected targets when the slider is dragged or has been changed
	if ($sliderDrag)
		shapesMain_matchSelectedTargetValues;
}


global proc shapesDriver_showHideWeightDriver( string $attr, int $state )
{
	//
	// show/hide all weight drivers in the scene
	//
	string $wd[] = `ls -type weightDriver`;
	for ($node in $wd)
		setAttr ($node + "." + $attr) $state;
}


global proc shapesDriver_setShapeDriverAttribute( string $item, string $label )
{
	//
	// sets the connected weightDriver attributes or sdk values based on the changed
	// user settings in the shape driver attribute section
	//
	global int $gShapes_index;
	global string $gShapes_currentSdkAttr;
	global string $gShapes_rampPlug;
	global string $gShapes_selectedTarget;
	global string $gShapes_bsData[];
	
	if ($gShapes_selectedTarget == "" && $gShapes_rampPlug == "")
		return;
	
	string $queryPlug;
	if ($gShapes_rampPlug == "")
		$queryPlug = shapesMain_getQueryPlug($gShapes_selectedTarget);
	else
		$queryPlug = $gShapes_rampPlug;
	
	string $driver[] = shapesMain_verifyShapeConnections($queryPlug, 0);
	if (!size($driver))
		return;
	
	string $driverItems[] = dict_stringToCleanArray($driver[0], "%");
	
	string $node = $driverItems[0];
	string $type = $driverItems[1];
	
	if ($type == "sdks")
	{
		string $conn[] = `listConnections -s 1 -d 0 -sh 1 ($node + ".driverValue")`;
		if (`nodeType $conn[0]` == "weightDriver")
			$type = "wd";
		else if (`gmatch (nodeType($conn[0])) "*animCurve*"`)
			$type = "sdk";
		$node = $conn[0];
	}
	
	if ($type == "combo")
		$driver = shapesMain_verifyShapeConnections($node + ".i2x", 0);
	
	if ($type == "wd")
	{
		int $invert;
		float $value;
		if ($label == "direction" || $label == "interpolation")
			$value = `optionMenuGrp -q -sl $item` - 1;
		else if (	$label == "angle" || 
					$label == "centerAngle" || 
					$label == "twistAngle" || 
					$label == "translateMin" || 
					$label == "translateMax")
		{
			float $vList[] = `floatFieldGrp -q -v $item`;
			$value = $vList[0];
			if ($label == "angle" && $value < 0)
			{
				$value = abs($value);
				$invert = 1;
			}
		}
		else if (	$label == "twist" || 
					$label == "useRotate" || 
					$label == "useTranslate" || 
					$label == "grow")
			$value = `checkBoxGrp -q -v1 $item`;
		
		setAttr ($node + "." + $label) $value;
		if ($label == "angle")
			setAttr ($node + ".invert") $invert;
	}
	else if ($type == "sdk")
	{
		if ($label == "minMax")
		{
			float $values[] = `floatFieldGrp -q -v $item`;
			// get the key time values from the sdk curve for comparison
			// this is needed to set the correct keyframes
			int $indexList[] = `getAttr -mi ($node + ".ktv")`;
			float $timeValue1[] = `getAttr ($node + ".ktv[" + $indexList[0] + "]")`;
			float $timeValue2[] = `getAttr ($node + ".ktv[" + $indexList[1] + "]")`;
			// if the first listed keyframe is the one which defines the end state of the sdk (1)
			// the value list needs to be reversed so that the max/end value comes first
			if ($timeValue1[1] > 0)
			{
				float $temp[];
				for ($i = size($values) - 1; $i >= 0; $i --)
					$temp[size($temp)] = $values[$i];
				$values = $temp;
			}
			keyframe -a -o "over" -index 0 -fc $values[0] $node;
			// if the new value for the first keyframe is greater than the value of the second
			// the key listing gets reordered and the second keyframe to be edited will be listed first
			int $keyId = 1;
			if ($values[0] > $timeValue1[0] && $values[0] > $timeValue2[0])
				$keyId = 0;
			keyframe -a -o "over" -index $keyId -fc $values[1] $node;
		}
		else if ($label == "interpolation")
		{
			int $value = `optionMenuGrp -q -sl $item` - 1;
			string $tangent[] = {"spline", "spline"};
			if ($value == 1)
				$tangent = {"spline", "flat"};
			if ($value == 2)
				$tangent = {"flat", "spline"};
			if ($value == 3)
				$tangent = {"flat", "flat"};
			// if the max value is actually negative the keyframe for this pose
			// is actually listed first and makes it necessary to reverse the tangent list
			float $values[] = `floatFieldGrp -q -v shpUI_sdkRangeField`;
			if ($values[1] < 0)
			{
				string $tan[];
				for ($i = size($tangent) - 1; $i >= 0; $i --)
					$tan[size($tan)] = $tangent[$i];
				$tangent = $tan;
			}
			keyTangent -index 0 -itt $tangent[0] -ott $tangent[0] $node;
			keyTangent -index 1 -itt $tangent[1] -ott $tangent[1] $node;
		}
		else if ($label == "infinity")
		{
			int $value = `optionMenuGrp -q -sl $item`;
			shapesDriver_setCurveInfinity $node $value;
		}
		else if ($label == "attribute")
		{
			string $connect[] = `listConnections -s 1 -d 0 -scn 1 -p 1 -c 1 $node`;
			string $conversion[] = `listConnections -type "unitConversion" $node`;
			string $connectItems1[] = stringToStringArray($connect[0], ".");
			string $connectItems2[] = stringToStringArray($connect[1], ".");
			connectAttr -f ($connectItems2[0] + "." + $gShapes_currentSdkAttr) ($node + "." + $connectItems1[1]);
			// delete the previous conversion node if any
			if (size($conversion))
				delete $conversion;
		}
	}
	
	if ($label == "ramp")
	{
		string $rampPlug = dict_getStringValue($gShapes_bsData[$gShapes_index], "ramp");
		string $rampNodeItems[] = stringToStringArray($rampPlug, ".");
		if (`nodeType $rampNodeItems[0]` == "rampWeights" && size($rampNodeItems) > 1)
		{
			string $connect[] = `listConnections -s 1 -d 0 -scn 1 -p 1 -c 1 $rampPlug`;
			if (size($connect))
			{
				string $conversion[] = `listConnections -type "unitConversion" $rampPlug`;
				disconnectAttr $connect[1] $connect[0];
				string $driven = $rampNodeItems[0] + "." + `optionMenu -q -v shpUI_rampAttrOption`;
				connectAttr -f $connect[1] $driven;
				// delete the previous conversion node if any
				if (size($conversion))
					delete $conversion;
				
				dict_setValue($gShapes_bsData, $gShapes_index, "ramp", $driven);
			}
		}
	}
}


// --------------------------------------------------------------------------------------------------
// sdk attributes
// --------------------------------------------------------------------------------------------------

global proc float[] shapesDriver_getSdkValues( string $node )
{
	//
	// return the sdk values for the given curve
	//
	// get the number of keys for the sdk curve
	int $indexList[] = `getAttr -mi ($node + ".ktv")`;
	if (size($indexList) > 2)
	{
		warning "Only two set driven keyframes are currently supported";
		return {};
	}
	if (size($indexList) == 1)
	{
		warning "The set driven key curve has only one keyframe";
		return {};
	}
	float $valuePair[];
	for ($k in $indexList)
	{
		// get the time value pair for the current index
		float $values[] = `getAttr ($node + ".ktv[" + $k + "]")`;
		if (!size($valuePair))
			$valuePair = $values;
		else
		{
			if ($values[1] > $valuePair[1])
			{
				for ($v in $values)
					$valuePair[size($valuePair)] = $v;
			}
			else
			{
				for ($v = 0; $v < size($values); $v ++)
					shapesArray_floatArrayInsertAtIndex($v, $valuePair, $values[$v]);
			}
		}
	}
	return $valuePair;
}


global proc shapesDriver_refreshAttributeMenu()
{
	//
	// build a new option menu with the given driver attributes
	//
	global string $gShapes_currentSdkAttr;
	global string $gShapes_sdkAttrDict;
	
	setParent shpUI_sdkForm;
	
	if (`optionMenu -ex shpUI_sdkAttrOption`)
		deleteUI shpUI_sdkAttrOption;
	
	optionMenu -cc ("shapesDriver_sdkSetCurrentAttribute 1") shpUI_sdkAttrOption;
	
	string $keyList[] = dict_getKeys($gShapes_sdkAttrDict);
	$keyList = sort($keyList);
	int $maxValue;
	string $maxAttr = "None";
	for ($key in $keyList)
	{
		if ($key != "shpCurrentSdkDriver")
		{
			// need to try because of some issues with Maxwell renderer
			// the renderer adds some custom attributes of which some cannot
			// be converted to float values
			float $value = dict_getValue($gShapes_sdkAttrDict, $key);
			menuItem -l $key -p shpUI_sdkAttrOption;
			// compare the values and store the attribute with the highest/lowest value
			// this attribute gets selected in the option menu
			if (abs($value) > $maxValue)
			{
				$maxValue = abs($value);
				$maxAttr = $key;
			}
		}
	}
	
	formLayout	-e 
				
				-af shpUI_sdkAttrOption "top" 0 
				-af shpUI_sdkAttrOption "bottom" 0 
				-af shpUI_sdkAttrOption "right" 29 
				
				-ac shpUI_sdkAttrOption "left" 23 "shpUI_sdkAttrLabel" 
				
				shpUI_sdkForm;
	
	setParent ..;
	
	if ($gShapes_currentSdkAttr == "")
		$gShapes_currentSdkAttr = $maxAttr;
	
	if ($maxAttr != "None")
		shapesDriver_setSdkAttributes $gShapes_currentSdkAttr 0.0 (dict_getValue($gShapes_sdkAttrDict, $gShapes_currentSdkAttr));
}


global proc shapesDriver_sdkSetCurrentAttribute( int $update )
{
	//
	// store the currently selected sdk attribute until the driver changes
	//
	global string $gShapes_currentSdkAttr;
	global string $gShapes_sdkAttrDict;
	
	$gShapes_currentSdkAttr = `optionMenu -q -v shpUI_sdkAttrOption`;
	// if the call does not come from selecting an attribute but rather from either
	// reading the sdk curve values or setting the value previously the field needs no update
	if ($update)
	{
		float $value = dict_getValue($gShapes_sdkAttrDict, $gShapes_currentSdkAttr);
		floatFieldGrp -e -v2 $value shpUI_sdkRangeField;
		shapesDriver_setShapeDriverAttribute "shpUI_sdkAttrOption" "attribute";
	}
}


global proc shapesDriver_setSdkAttributes( string $attr, float $min, float $max )
{
	//
	// set the sdk attributes
	//
	optionMenu -e -v $attr shpUI_sdkAttrOption;
	floatFieldGrp -e -v1 $min -v2 $max shpUI_sdkRangeField;
	shapesDriver_sdkSetCurrentAttribute 0;
}


global proc string shapesDriver_sdkAttributeToDictionary( string $node )
{
	//
	// read the keyable attributes from the channelbox and store
	// them in a dictionary
	//
	string $dict;
	string $attrs[] = `listAttr -k $node`;
	string $attrsCB[] = `listAttr -cb $node`;
	
	if (size($attrsCB))
		$attrs = stringArrayCatenate($attrs, $attrsCB);
	
	string $skipAttrs[] = {"", "string", "float2", "float3", "double2", "double3", "long2", "long3", "short2", "short3", "message"};
	
	if (size($attrs) != 0)
	{
		for ($a in $attrs)
		{
			// make sure no compound attributes get added
			// i.e. weightList.weights from a bend node
			if (size(stringToStringArray($a, ".")) == 1)
			{
				// make sure that no string or double/triple attribute is processed
				string $attrType;
				$attrType = `getAttr -type ($node + "." + $a)`;
				if (!stringArrayContains($attrType, $skipAttrs))
				{
					float $value = `getAttr ($node + "." + $a)`;
					if ($value == 0)
					{
						if (!`optionVar -q SHAPESIgnoreZeroChannels`)
						{
							$dict = dict_setValue({$dict}, 0, $a, $value);
						}
					}
					else
					{
						$dict = dict_setValue({$dict}, 0, $a, $value);
					}
				}
			}
		}
	}
	else
		warning "The selected driver has no keyable attributes to display.";
	
	return $dict;
}


global proc shapesDriver_setCurveInfinity( string $node, float $value )
{
	//
	// get the curve infinity values based on the selected option menu item
	//
	int $preInf;
	int $postInf;
	// pre infinity
	if ($value == 2)
		$preInf = 1;
	// post infinity
	if ($value == 3)
		$postInf = 1;
	// pre/post infinity
	if ($value == 4)
	{
		$preInf = 1;
		$postInf = 1;
	}
	setAttr ($node + ".preInfinity") $preInf;
	setAttr ($node + ".postInfinity") $postInf;
}


// --------------------------------------------------------------------------------------------------
// sequence editing
// --------------------------------------------------------------------------------------------------

global proc shapesDriver_editDriverSequence( string $target )
{
	//
	// initializes the editing of the driver sequence
	// gets the current shape driver and existing sequence targets
	// and populates the slider frame
	//
	global float $gShapes_sequenceMax;
	global string $gShapes_currentSequenceTarget;
	
	string $sequence = shapesDriver_getShapeSequence($target);
	if ($sequence == "")
		return;
	
	// clear the target selection and the slider frame
	treeView -e -cs shpUI_targetTree;
	shapesMain_buildTargetSlider;
	
	// disable the general ui and show the combo ui
	shapesUI_showEditComboUI 1;
	shapesCombo_editComboToggleUI 0;
	frameLayout -e -l "Sequence" -cl 0 shpUI_sliderFrame;
	
	$gShapes_currentSequenceTarget = $target;
	$gShapes_sequenceMax = shapesDriver_getSequenceEndValue(dict_getStringValue($sequence, "master"));
	
	string $tgts[] = dict_getValueArray($sequence, "targets");
	string $valueString[] = dict_getValueArray($sequence, "values");
	float $values[];
	for ($vs in $valueString)
		$values[size($values)] = $vs;
	if (size($tgts))
	{
		shapesDriver_addSequenceSlider $tgts $values 0;
		$gShapes_currentSequenceTarget = $tgts[size($tgts) - 1];
	}
	else
		shapesDriver_addSequenceSlider {$target} {1} 0;
	
	// set the curve option
	eval ("optionMenu -e -sl " + dict_getStringValue($sequence, "tangents") + " shpUI_sequenceCurveOption");
}


global proc shapesDriver_addRemoveSequenceItems( int $add )
{
	//
	// add/remove the selected items in the list to the current channel sliders
	//
	string $selection[] = `treeView -q -si shpUI_targetTree`;
	if (!size($selection))
		return;
	
	if ($add)
	{
		float $values[];
		for ($s in $selection)
			$values[size($values)] = 0.5;
		shapesDriver_addSequenceSlider $selection $values 1;
	}
	else
	{
		string $sliderDictList[] = shapesDriver_getSequenceSlider();
		for ($item in $selection)
		{
			string $remove = "";
			for ($slider in $sliderDictList)
			{
				if (dict_getStringValue($slider, "target") == $item)
					$remove = $slider;
			}
			if (dict_getValue($remove, "value") == 1)
				error "The sequence end shape cannot be removed";
			else
			{
				string $ctrl = dict_getStringValue($remove, "layout");
				if ($ctrl != "")
				{
					deleteUI $ctrl;
					// reset the target color
					treeView -e -lbc (dict_getStringValue($remove, "target")) -1 -1 -1 shpUI_targetTree;
				}
			}
		}
	}
	treeView -e -cs shpUI_targetTree;
}


global proc shapesDriver_addSequenceSlider( string $targets[], float $values[], int $checkRelationship )
{
	//
	// adds a new sequence slider for the selected target
	//
	global float $gShapes_sequenceMax;
	global float $gShapes_driverCol[];
	global float $gShapes_targetCol[];
	global string $gShapes_currentSequenceTarget;
	global string $gShapes_btnData[];
	
	setParent shpUI_sliderFrame;
	
	string $sliderDictList[] = shapesDriver_getSequenceSlider();
	
	for ($i = 0; $i < size($targets); $i ++)
	{
		int $add = 1;
		for ($slider in $sliderDictList)
		{
			if (dict_getStringValue($slider, "target") == $targets[$i])
				$add = 0;
		}
		
		if ($add)
		{
			// check if the target is part of the current sequence;
			// if the target has been removed and then about to be added again
			// it has the sdks type (because of the button icon) and can't be added again;
			// the check needs to be performed so that a previously removed target can be added again
			string $sequence = shapesDriver_getShapeSequence($targets[$i]);
			int $itemOfCurrent = 0;
			string $tgts[] = dict_getValueArray($sequence, "targets");
			if (size($tgts) && $tgts[size($tgts) - 1] == $gShapes_currentSequenceTarget)
				$itemOfCurrent = 1;
			
			// check if the added target is not already part of a sequence;
			// can be part of a sequence when checkRelationship is true,
			// which is necessary for listing the targets when entering edit mode
			int $id[] = shapesMain_getShapeIds(0, {$targets[$i]});
			string $type[] = dict_getIndexedSubValue($gShapes_btnData[$id[0]], "buttons", 0, "type");
			if ($type[0] != "sdks" || !$checkRelationship || $itemOfCurrent)
			{
				int $enable = 1;
				
				// make sure that the main target is disabled
				if ($values[$i] == 1)
					$enable = 0;
				
				shapesUI_expandParentItem $targets[$i];
				
				rowLayout -nc 3 -cat 1 "left" 0 -adj 3;
				
					text -l $targets[$i] -w 140 -al "left";
					string $valueField = `floatField -pre 3 -v (shapesDriver_roundFloat(($gShapes_sequenceMax * $values[$i]), 2)) -w 60 -en $enable`;
					string $slider = `floatSliderGrp	-l "" 
														-f 1 
														-v $values[$i] 
														-en $enable 
														-min 0 
														-max 1 
														-pre 3 
														-cw3 0 50 40 
														-co3 0 5 5 
														-ct3 "left" "both" "right"`;
					
					floatField -e -cc ("shapesDriver_updateSequenceSlider " + $slider + " " + $valueField) $valueField;
					floatSliderGrp -e -cc ("shapesDriver_updateSequenceDriverValue " + $slider + " " + $valueField) $slider;
					
					setParent ..;
				
				if ($enable)
					treeView -e -lbc $targets[$i] $gShapes_driverCol[0] $gShapes_driverCol[1] $gShapes_driverCol[2] shpUI_targetTree;
				else
					treeView -e -lbc $targets[$i] $gShapes_targetCol[0] $gShapes_targetCol[1] $gShapes_targetCol[2] shpUI_targetTree;
			}
			else
				warning ("Unable to add the target \"" + $targets[$i] + "\" because it is already part of another sequence");
		}
	}
}


global proc shapesDriver_orderSequence()
{
	//
	// orders the sequence sliders
	//
	string $sliderDictList[] = shapesDriver_getSequenceSlider();
	
	// sort the list by values
	string $values[];
	for ($slider in $sliderDictList)
		$values[size($values)] = dict_getStringValue($slider, "value");
	$values = sort($values);
	
	string $sorted[];
	for ($v in $values)
	{
		for ($slider in $sliderDictList)
		{
			if (dict_getStringValue($slider, "value") == $v)
				$sorted[size($sorted)] = $slider;
		}
	}
	$sliderDictList = $sorted;
	
	// clear the slider frame
	shapesMain_removeAllTargetSlider "shpUI_sliderFrame";
	// and add new sliders from the modified list
	for ($slider in $sliderDictList)
	{
		string $tgt = dict_getStringValue($slider, "target");
		float $value = dict_getValue($slider, "value");
		shapesDriver_addSequenceSlider {$tgt} {$value} 0;
	}
}


global proc string[] shapesDriver_getSequenceSlider()
{
	//
	// returns a list of dictionaries containing all sliders
	// for the driver sequence
	//
	string $sliderDictList[];
	string $items[] = `frameLayout -q -ca shpUI_sliderFrame`;
	for ($i in $items)
	{
		string $ctrls[] = `rowLayout -q -ca $i`;
		string $sliderDict = "";
		$sliderDict = dict_setValue({$sliderDict}, 0, "layout", $i);
		$sliderDict = dict_setValue({$sliderDict}, 0, "target", `text -q -l $ctrls[0]`);
		$sliderDict = dict_setValue({$sliderDict}, 0, "value", `floatSliderGrp -q -v $ctrls[2]`);
		$sliderDictList[size($sliderDictList)] = $sliderDict;
	}
	return $sliderDictList;
}


global proc shapesDriver_updateSequenceDriverValue( string $slider, string $valueField )
{
	//
	// update the real driver value in the slider label
	//
	global float $gShapes_sequenceMax;
	
	float $value = `floatSliderGrp -q -v $slider`;
	floatField -e -v (shapesDriver_roundFloat(($gShapes_sequenceMax * $value), 3)) $valueField;
}


global proc shapesDriver_updateSequenceSlider( string $slider, string $valueField )
{
	//
	// update the real driver value in the slider label
	//
	global float $gShapes_sequenceMax;
	
	float $value = `floatField -q -v $valueField`;
	floatSliderGrp -e -v (shapesDriver_roundFloat(($value / $gShapes_sequenceMax), 3)) $slider;
}


global proc shapesDriver_updateSequence()
{
	//
	// delete the previous shape sequence and create a new one
	//
	global string $gShapes_currentSequenceTarget;
	global string $gShapes_selectedTarget;
	
	shapesDriver_orderSequence;
	
	// create a new sequence based on the current slider list
	string $sliderDictList[] = shapesDriver_getSequenceSlider();
	
	// delete the old sequence
	string $plug = shapesDriver_removeSequence($gShapes_currentSequenceTarget);
	
	// only continue if there is more than the end target in the list
	if (size($sliderDictList) < 2)
	{
		shapesDriver_cancelEditSequence;
		return;
	}
	
	float $values[];
	string $targets[];
	for ($slider in $sliderDictList)
	{
		$values[size($values)] = dict_getValue($slider, "value");
		$targets[size($targets)] = dict_getStringValue($slider, "target");
	}
	
	// check if all values are different
	string $allValues[];
	for ($v in $values)
		$allValues[size($allValues)] = $v;
	$allValues = stringArrayRemoveDuplicates($allValues);
	if (size($allValues) != size($values))
		error "All sequence values must be different";
	
	int $type = `optionMenu -q -sl shpUI_sequenceCurveOption`;
	shapesDriver_performCreateSequence $plug $values $targets $type 1 0 {} 0;
	
	// update the target list
	$gShapes_selectedTarget = $gShapes_currentSequenceTarget;
	shapesMain_refreshTargetItem $targets;
	
	shapesDriver_cancelEditSequence;
}


global proc string shapesDriver_performCreateSequence( string $driverPlug, float $values[], string $targets[], int $type, int $execute, int $readSdk, string $curves[], int $mirror )
{
	//
	// creates a sdk sequence setup driven by the given node
	// and driving the given list of targets
	// returns the creation string for exporting the setup
	//
	global string $gShapes_bsNode;
	global string $gShapes_exportMirrorSetupSequenceData;
	global string $gShapes_sideIdentifier;
	
	string $driverPlugItems[] = stringToStringArray($driverPlug, ".");
	string $driver = $driverPlugItems[0];
	
	string $driverName = $driver;
	string $driverPlugName = $driverPlug;
	
	// make sure that the driver name matches the name of the sequence target
	// if the names are not matching this can create errors when rebuilding the setup;
	// only perform the renaming when creating the sequence and not during export
	// because during export all sequence information has been already connected
	// and changing the driver name would create errors
	if ($execute && $driver != ($gShapes_bsNode + "_" + $targets[size($targets) - 1] + "_WD"))
	{
		$driverPlugItems[0] = shapesDriver_renameWeightDriver($targets[size($targets) - 1]);
		$driverPlug = stringArrayToString($driverPlugItems, ".");
		$driver = $driverPlugItems[0];
		if (`nodeType $driver` == "transform")
		{
			string $shape[] = `listRelatives -s $driver`;
			$driver = $shape[0];
		}
		
		$driverName = $driver;
		$driverPlugName = $driverPlug;
	}
	
	if (!$execute && $mirror)
	{
		$driverName = shapesMirror_swapSideLabel($driverName);
		$driverPlugItems[0] = $driverName;
		$driverPlugName = stringArrayToString($driverPlugItems, ".");
		$gShapes_sideIdentifier = "";
	}
	
	string $netNode = "SHAPES_" + $targets[size($targets) - 1] + "_sequence_net";
	string $attrName = "SHAPES_sdks";
	
	if ($mirror)
	{
		// call the label swapping just to get the identifier
		shapesMirror_swapSideLabel($gShapes_bsNode);
		if (startsWith($gShapes_sideIdentifier, "_"))
			$netNode = $netNode + $gShapes_sideIdentifier;
		else if (endsWith($gShapes_sideIdentifier, "_"))
			$netNode = $gShapes_sideIdentifier + $netNode;
		$gShapes_sideIdentifier = "";
	}
	
	// store the number of values for the loop
	// since it has to be modified to start with a 0 value
	int $count = size($values);
	
	// insert the 0 value at the beginning of the value list
	shapesArray_floatArrayInsertAtIndex(0, $values, 0);
	
	// create the sequence node and add the attributes
	string $cmd;
	$cmd += "createNode network -n " + $netNode + ";\n";
	$cmd += "addAttr -ln \"driverValue\" -at double " + $netNode + ";\n";
	$cmd += "addAttr -at message -ln " + $attrName + " " + $netNode + ";\n";
	$cmd += "addAttr -dt \"string\" -ln \"SHAPES_sequenceTarget\" " + $netNode + ";\n";
	$cmd += "setAttr \"" + $netNode + ".SHAPES_sequenceTarget\" -l 1 -type \"string\" sequenceOut" + ($count - 1) + ";\n";
	
	string $tangents = "-itt auto -ott auto ";
	if ($type == 2)
		$tangents = "-itt linear -ott linear ";
	
	string $angleWeightString;
	
	for ($i = 0; $i < $count; $i ++)
	{
		// add the attribute for each target to be driven
		string $outAttr = "sequenceOut" + $i;
		$cmd += "addAttr -ln " + $outAttr + " -at double " + $netNode + ";\n";
		
		// if a new sequence is created or an update should be performed
		// create new sdk curves
		// when the call comes from exporting the setup the existing
		// sdk curves can be read instead
		if (!$readSdk)
		{
			// set the alternating value which defines the on/off behaviour of the sdk
			float $value = 0;
		
			// create three keyframes for each target
			for ($k = 0; $k < 3; $k ++)
			{
				int $set = 1;
				// for the last target skip the generation of the last keyframe
				// because it only needs to be turned on
				if ($i == $count - 1 && $k == 2)
					$set = 0;
			
				// create the sdk
				if ($set)
				{
					float $driverValue = $values[$i + $k];
					$cmd += "setDrivenKeyframe -dv " + $driverValue + " -v " + $value + " " + $tangents + "-cd " + ($netNode + ".driverValue") + " " + ($netNode + "." + $outAttr) + ";\n";
				}
				// toggle the value for the next curve
				$value = 1 - $value;
			
				if ($type == 3)
				{
					if ($k == 1)
					{
						$angleWeightString += "keyTangent -e -wt 1 " + $netNode + "_" + $outAttr + ";\n";
						$angleWeightString += "keyTangent -e -in " + $k + " -ia 8 -iw 1.0 -oa 8 -ow 1.5 " + $netNode + "_" + $outAttr + ";\n";
					}
					else if ($k == 2 && $i == $count - 2)
					{
						$angleWeightString += "keyTangent -e -wt 1 " + $netNode + "_" + $outAttr + ";\n";
						$angleWeightString += "keyTangent -e -in " + $k + " -ia -12 -iw 0.8 -oa -12 -ow 0.8 " + $netNode + "_" + $outAttr + ";\n";
					}
				}
			}
		}
		else
		{
			// use $gShapes_exportMirrorSetupSequenceData to store the network node name
			// during the read procedure;
			// it's used during the mirrored export of the setup when the mirror flag
			// for the sdkRead has to be off for the sequence but the sdk driver name needs to
			// have the side identifier order to make the export work correctly
			$gShapes_exportMirrorSetupSequenceData = $netNode;
			$cmd += shapesUtil_readSdk($curves[$i], $netNode + "." + $outAttr, 0, 0);
			$gShapes_exportMirrorSetupSequenceData = "";
		}
	}
	// get the message attribute from the driver plug
	string $attrList[] = `listAttr -m -ud $driver`;
	
	// connect the driver with the sequencer
	$cmd += "connectAttr -f " + $driverPlugName + " " + $netNode + ".driverValue;\n";
	// connect the message attribute
	if (size($attrList))
		$cmd += "connectAttr -f " + $driverName + "." + $attrList[0] + " " + $netNode + "." + $attrName + ";\n";
	
	// connect the sequencer with the targets
	for ($i = 0; $i < $count; $i ++)
	{
		string $queryPlug = shapesMain_getQueryPlug($targets[$i]);
		$cmd += "connectAttr -f " + $netNode + ".sequenceOut" + $i + " " + $queryPlug + ";\n";
	}
	
	$cmd += $angleWeightString;
	
	if ($execute)
		eval $cmd;
	
	return $cmd;
}


global proc string shapesDriver_removeSequence( string $target )
{
	//
	// deletes all previous sequence nodes
	// and connects the source driver directly to the blend shape target
	// returns the plug from the source driver
	//
	string $sequence = shapesDriver_getShapeSequence($target);
	
	string $queryPlug = shapesMain_getQueryPlug($target);
	
	// if there is no current sequence only return the driver plug
	if (dict_getStringValue($sequence, "sequencer") == "")
	{
		string $conn[] = `listConnections -s 1 -d 0 -p 1 $queryPlug`;
		return $conn[0];
	}
	
	// get the connection plug from the source driver to the sequencer node
	string $conn[] = `listConnections -s 1 -d 0 -p 1 (dict_getStringValue($sequence, "sequencer") + ".driverValue")`;
	
	// connect the source driver to the blend shape target
	connectAttr -f $conn[0] $queryPlug;
	
	// delete the sdk curves
	delete (dict_getValueArray($sequence, "curves"));
	
	// try to remove the network node
	// but it should have been deleted by deleting the sdk curves
	catch(`eval("delete " + dict_getStringValue($sequence, "sequencer"))`);
	
	shapesMain_refreshTargetItem {$target};
	
	return $conn[0];
}


global proc shapesDriver_cancelEditSequence()
{
	//
	// exits the sequence edit mode without making modifications
	//
	global int $gShapes_sequenceProcess;
	global string $gShapes_currentSequenceTarget;
	
	// refresh the target list
	shapesMain_listBlendShapeTargets 0;
	// clear the slider frame
	shapesMain_removeAllTargetSlider "shpUI_sliderFrame";
	
	shapesUI_showEditComboUI 0;
	shapesCombo_editComboToggleUI 1;
	frameLayout -e -l "Channels" shpUI_sliderFrame;
	$gShapes_sequenceProcess = 0;
	$gShapes_currentSequenceTarget = "";
}


global proc string shapesDriver_getShapeSequence( string $target )
{
	//
	// returns a dictionary with all sequence nodes, targets and values
	//
	string $sequenceDict;
	
	string $queryPlug = shapesMain_getQueryPlug($target);
	
	// get the connected sdk driver node
	// have to use the shape flag because querying the weight driver node
	// without it returns the transform node instead of the shape node
	// but only the shape node has the important message attribute
	string $conn[] = `listConnections -s 1 -d 0 -sh 1 $queryPlug`;
	
	// if a non-sequence shape is queried return None
	// this is in conjunction to prevent the creation of a combo with a sequence
	// and to check for a sequence during the export
	if (!size($conn))
		return "";
	
	// get the sequence master node
	// getComboMasterNode is utilized because it checks the connection
	// between nodes via the message attribute
	// the option needs to be False in order to make it work
	string $nodeList[] = shapesCombo_getComboMasterNode($conn[0], 0);
	if (!size($nodeList))
		return "";
	
	// get the message attribute on the master node to find the possible network node
	string $attrList[] = `listAttr -m -ud $nodeList[0]`;
	if (!size($attrList))
		return "";
	// remove the [] from the multi attribute (in case of the driven node)
	string $temp[] = stringToStringArray($attrList[0], "[");
	string $msgAttr = $temp[0];
	if (`gmatch $msgAttr "*_combo*"`)
		return "";
	
	string $networkNode[] = `listConnections -s 0 -d 1 ($nodeList[0] + "." + $msgAttr)`;
	if (!size($networkNode) || `nodeType $networkNode[0]` != "network")
	{
		$sequenceDict = "{'master': '" + $nodeList[0] + "', 'sequencer': '', 'targets': [], 'curves': [], 'values': [], 'tangents': '1'}";
		return $sequenceDict;
	}
	
	// get all sequence attributes on the network node
	$attrList = `listAttr -ud $networkNode[0]`;
	// remove the input attribute
	$attrList = stringArrayRemove({"driverValue"}, $attrList);
	
	string $targets[];
	string $curves[];
	string $values[];
	int $tangents = 1;
	
	// collect the sequence data
	for ($a in $attrList)
	{
		if (!`gmatch $a "SHAPES_*"`)
		{
			// get the driven blend shape targets
			string $conn[] = `listConnections -s 0 -d 1 -p 1 ($networkNode[0] + "." + $a)`;
			$targets[size($targets)] = "'" + shapesMain_getFilteredTargetFromPlug($conn[0]) + "'";
			// get the curve values
			$conn = `listConnections -s 1 -d 0 ($networkNode[0] + "." + $a)`;
			$curves[size($curves)] = "'" + $conn[0] + "'";
			string $sdkString = shapesUtil_readSdk($conn[0], "", 0, 0);
			string $temp[] = stringToStringArray($sdkString, "\n");
			$temp = stringToStringArray($temp[2], "-");
			$temp = stringToStringArray($temp[1], " ");
			string $val = $temp[1];
			// error just in case the sdkString has a wrong formatting
			// and the value cannot be converted to float
			if (catchQuiet(`eval("float $shapesFloatTest = " + $val)`))
			{
				warning ("Unable to read the sequence data for node " + $conn[0]);
				$val = "0.5";
			}
			
			$values[size($values)] = "'" + $val + "'";
			
			// check for non-auto tangents
			if ($tangents == 1)
			{
				if (`gmatch $sdkString "*keyTangent*"`)
					$tangents = 3;
				else if (`gmatch $sdkString "*itt linear*"`)
					$tangents = 2;
			}
		}
	}
	
	$sequenceDict = "{'master': '" + $nodeList[0] + "', 'sequencer': '" + $networkNode[0] + "', 'targets': [" + stringArrayToString($targets, ",") + "], 'curves': [" + stringArrayToString($curves, ",") + "], 'values': [" + stringArrayToString($values, ",") + "], 'tangents': '" + $tangents + "'}";
	
	return $sequenceDict;
}


global proc string shapesDriver_getSequenceEndShape( string $networkNode )
{
	//
	// returns the shape which is placed at the end of the sequence
	//
	string $plug = `getAttr ($networkNode + ".SHAPES_sequenceTarget")`;
	string $conn[] = `listConnections -s 0 -d 1 -p 1 ($networkNode + "." + $plug)`;
	return shapesMain_getFilteredTargetFromPlug($conn[0]);
}


global proc float shapesDriver_getSequenceEndValue( string $node )
{
	//
	// return the real maximum value from the shape driver
	//
	if (`nodeType $node` == "weightDriver")
		return `getAttr ($node + ".angle")`;
	else
	{
		float $values[] = shapesDriver_getSdkValues($node);
		return $values[2];
	}
}


global proc SHAPES_driver(){}
