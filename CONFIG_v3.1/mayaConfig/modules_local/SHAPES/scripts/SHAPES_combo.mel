// --------------------------------------------------------------------------------------------------
//
// SHAPES
//
// blend shape editing tool for Maya
//
// required plugins:
//   SHAPESTools
//
// Ingo Clemens
// www.braverabbit.com
//
// copyright brave rabbit, Ingo Clemens 2014-2016
//
// --------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------
//
// THE SOFTWARE PRODUCT IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
// IMPLIED, INCLUDING, BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NON-INFRINGEMENT OF THIRD-PARTY RIGHTS. THE ENTIRE RISK AS TO THE QUALITY AND
// PERFORMANCE OF THE SOFTWARE PRODUCT IS WITH YOU.
// NEITHER BRAVE RABBIT NOR ITS SUPPLIERS WARRANT THAT THE FUNCTIONS CONTAINED IN THE SOFTWARE
// PRODUCT WILL MEET YOUR REQUIREMENTS OR THAT THE OPERATION OF THE SOFTWARE PRODUCT WILL BE
// UNINTERRUPTED OR ERROR-FREE. BRAVE RABBIT IS NOT OBLIGATED TO PROVIDE ANY UPDATES TO THE
// SOFTWARE.
// IN NO EVENT SHALL THE AUTHOR OF THIS SOFTWARE PRODUCT BE LIABLE FOR ANY SPECIAL, CONSEQUENTIAL,
// INCIDENTAL, DIRECT OR INDIRECT DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
// LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, FOR PERSONAL INJURY, LOSS OF BUSINESS
// INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THIS
// PRODUCT, EVEN IF THE AUTHOR OF THIS SOFTWARE PRODUCT IS AWARE OF THE POSSIBILITY OF SUCH
// DAMAGES AND KNOWN DEFECTS, ANY CLAIM BY A THIRD PARTY AND EVEN IF THE REMEDY FAILS OF ITS
// ESSENTIAL PURPOSE.
//
// --------------------------------------------------------------------------------------------------


global proc int shapesCombo_createCombo()
{
	//
	// creates a multiply node and connects them to the blendshape targets
	//
	global string $gShapes_selectedTarget;
	global string $gShapes_btnData[];
	global string $gShapes_orderedTargetList[];
	global string $gShapes_targetTrackList[];
	
	if (size($gShapes_targetTrackList) != 0)
	{
		$gShapes_orderedTargetList = $gShapes_targetTrackList;
	}
	
	if (size($gShapes_orderedTargetList) == 0)
		error "Unable to create a combo without a shape selection";
	
	if (size($gShapes_orderedTargetList) == 1)
		error "Unable to create a combo with only one shape selected";
	
	string $comboTarget = $gShapes_orderedTargetList[size($gShapes_orderedTargetList) - 1];
	
	for ($btn in $gShapes_btnData)
	{
		string $type[] = dict_getIndexedSubValue($btn, "buttons", 0, "type");
		if (dict_getStringValue($btn, "target") == $comboTarget && $type[0] == "combo")
			error "The selected target is already used by another combo";
	}
	
	string $targets[] = $gShapes_orderedTargetList;
	stringArrayRemoveAtIndex(size($targets) - 1, $targets);
	shapesCombo_performCreateCombo $comboTarget $targets 1 0;
	
	$gShapes_selectedTarget = $comboTarget;
	shapesMain_refreshTargetItem $gShapes_orderedTargetList;
	
	$gShapes_targetTrackList = {};
	
	return 1;
}


global proc string shapesCombo_performCreateCombo( string $comboTarget, string $comboDriver[], int $execute, int $mirror )
{
	//
	// multi-source combos
	// create a multiply node based combo network
	// from the given target and driver nodes/attributes
	// returns the creation string for exporting the setup
	//
	global string $gShapes_sideIdentifier;
	
	string $attrName = "SHAPES_" + $comboTarget + "_combo";
	string $multName = $attrName + "_mult";
	if ($mirror)
	{
		if (startsWith($gShapes_sideIdentifier, "_"))
			$multName = $attrName + "_mult" + $gShapes_sideIdentifier;
		else if (endsWith($gShapes_sideIdentifier, "_"))
			$multName = $gShapes_sideIdentifier + $attrName + "_mult";
		$gShapes_sideIdentifier = "";
	}
	
	string $nodes[];
	string $cmd;
	// create the master multiply node
	string $masterNode[] = shapesCombo_createComboMultiplyNode($multName, $attrName, -1, 1);
	$nodes[size($nodes)] = $masterNode[0];
	$cmd += $masterNode[1];
	//setAttr(nodes[0] + ".i2x", 1)
	$cmd += "setAttr " + $nodes[0] + ".i2x 1;\n";
	
	for ($i = 0; $i < size($comboDriver); $i ++)
	{
		// create a multiplyDivide node and rename it to match the driver/driven name combo
		string $multNodeResult[] = shapesCombo_createComboMultiplyNode($multName, $attrName, $i + 1, 0);
		string $multNode = $multNodeResult[0];
		$cmd += $multNodeResult[1];
		// connect the shape with the first input
		string $queryPlug = shapesMain_getQueryPlug($comboDriver[$i]);
		$cmd += "connectAttr " + $queryPlug + " " + $multNode + ".i1x;\n";
		// connect the message attribute with the master node
		$cmd += "connectAttr -f -na " + $multNode + "." + $attrName + " " + $nodes[0] + "." + $attrName + ";\n";
		// set the second input to 1 so no inputs will get forgotten
		$cmd += "setAttr " + $multNode + ".i2x 1;\n";
		$nodes[size($nodes)] = $multNode;
		// connect the previous multiply node with the second input
		if ($i > 0)
			$cmd += "connectAttr " + $nodes[$i] + ".ox " + $multNode + ".i2x;\n";
	}
	
	// connect to the master multiply node
	$cmd += "connectAttr " + $nodes[size($nodes) - 1] + ".ox" + " " + $nodes[0] + ".i1x;\n";
	
	// omit this step when exporting the setup because all connections are already there
	if ($execute)
	{
		string $queryPlug = shapesMain_getQueryPlug($comboTarget);
		// check if the target shape is already driven
		// if it is, connect it to the second input of the master node
		string $plug[] = `listConnections -s 1 -d 0 -p 1 $queryPlug`;
		if (size($plug))
			$cmd += "connectAttr " + $plug[0] + " " + $nodes[0] + ".i2x;\n";
	}
	
	string $queryPlug = shapesMain_getQueryPlug($comboTarget);
	$cmd += "connectAttr -f " + $nodes[0] + ".ox " + $queryPlug + ";\n";
	
	if ($execute)
	{
		// make sure that the multiply nodes don't already exist in the scene
		// to avoid any errors because of duplicate names or attributes
		shapesCombo_removeUnusedMultiplyNode $nodes;
		
		eval $cmd;
	}
	
	return $cmd;
}


global proc string[] shapesCombo_createComboMultiplyNode( string $multName, string $attrName, int $index, int $multi )
{
	//
	// create a multiply node used for the combos
	//
	if ($index != -1)
		$multName += $index;
	
	string $tempName = "SHAPES_temp_multiplyDivide";
	string $cmd;
	$cmd += "shadingNode -au multiplyDivide -n " + $tempName + ";\n";
	$cmd += "rename " + $tempName + " " + $multName + ";\n";
	$multNode = $multName;
	if ($attrName != "")
	{
		if ($multi)
			$cmd += "addAttr -at message -ln " + $attrName + " -m -im 0 " + $multNode + ";\n";
		else
			$cmd += "addAttr -at message -ln " + $attrName + " " + $multNode + ";\n";
	}
	return {$multNode, $cmd};
}


global proc shapesCombo_removeUnusedMultiplyNode( string $nodes[] )
{
	//
	// delete the given nodes if they are not in use
	// usually unused nodes have either the second input not connected
	// or in case of the master node the ouput is disconnected
	//
	for ($node in $nodes)
	{
		if (`objExists $node`)
		{
			if (!size(`listConnections -p 1 ($node + ".i2x")`) || !size(`listConnections -p 1 ($node + ".ox")`))
				delete $node;
		}
	}
}


global proc shapesCombo_mirrorCombo( string $target )
{
	//
	// get the combo info from the mirror source target
	// and apply it to the mirrored shape
	//
	global string $gShapes_selectedTarget;
	
	string $comboDictList[] = shapesCombo_getComboNodes($gShapes_selectedTarget);
	string $driverList[];
	for ($comboDict in $comboDictList)
	{
		if ($gShapes_selectedTarget == dict_getStringValue($comboDict, "target"))
		{
			string $dkDriver[] = dict_getValueArray($comboDict, "driver");
			for ($driver in $dkDriver)
			{
				$driverList[size($driverList)] = shapesMirror_swapSideLabel($driver);
				if (!`treeView -q -iex $driverList[size($driverList) - 1] shpUI_targetTree`)
				{
					warning ("Unable to create the mirrored combo because the opposite driver sibling for \"" + $driver + "\" is missing");
					return;
				}
			}
		}
	}
	
	if (size($driverList) == 0)
		return;
	
	shapesCombo_performCreateCombo $target $driverList 1 0;
}


global proc int shapesCombo_removeCombo( string $shape, string $driver )
{
	//
	// removes the combo multiplier and connects the shape driver directly to the blendshape target
	//
	string $comboDictList[] = shapesCombo_getComboNodes($shape);
	for ($comboDict in $comboDictList)
	{
		string $tgt = dict_getStringValue($comboDict, "target");
		if ($driver && $shape != $tgt)
		{
			string $msg = "\"" + $shape + "\" is a combo driver for \"" + $tgt + "\".\n\nDo you want to continue?";
			if (!shapesGlobal_confirmWindow($msg, "OK"))
				return 0;
		}
		
		string $refreshList[] = shapesCombo_deleteComboMultiplierAndReconnect($comboDict);
		$refreshList[size($refreshList)] = $shape;
		shapesMain_refreshTargetItem $refreshList;
	}
	
	return 1;
}


global proc string[] shapesCombo_deleteComboMultiplierAndReconnect( string $comboDict )
{
	//
	// deletes the combo multiplier and re-connects the shape driver to the target channel
	//
	string $comboNodes[] = dict_getValueArray($comboDict, "comboNodes");
	string $target[] = `listConnections -p 1 ($comboNodes[0] + ".outputX")`;
	
	if (size($target) > 1)
		error ("Unable to delete " + $comboNodes[0] + " because the output is connected to more than one node");
	
	// add all driver shapes to the refresh list
	string $refreshList[] = dict_getValueArray($comboDict, "driver");
	// also add the target shape
	string $tgt = dict_getStringValue($comboDict, "target");
	$refreshList[size($refreshList)] = $tgt;
	
	// in case a shape driver exists re-connect it
	string $drv = dict_getStringValue($comboDict, "shapeDriver");
	if ($drv != "")
	{
		string $queryPlug = shapesMain_getQueryPlug($tgt);
		connectAttr -f $drv $queryPlug;
	}
	
	for ($node in $comboNodes)
		delete $node;
	
	return $refreshList;
}


global proc shapesCombo_deleteComboMultiplier( string $shape )
{
	//
	// delete all multiplier nodes of the combo
	//
	string $comboDictList[] = shapesCombo_getComboNodes($shape);
	for ($comboDict in $comboDictList)
	{
		string $comboNodes[] = dict_getValueArray($comboDict, "comboNodes");
		for ($node in $comboNodes)
			delete $node;
	}
}


global proc shapesCombo_renameComboMultiplier( string $target )
{
	//
	// rename the combo multiplier
	//
	string $comboDictList[] = shapesCombo_getComboNodes($target);
	for ($comboDict in $comboDictList)
	{
		string $tgt = dict_getStringValue($comboDict, "target");
		for ($n in dict_getValueArray($comboDict, "comboNodes"))
		{
			string $parts[] = stringToStringArray($n, "_");
			string $newNameItems[] = {$parts[0], $tgt, $parts[size($parts) - 2], $parts[size($parts) - 1]};
			string $newName = stringArrayToString($newNameItems, "_");
			rename $n $newName;
		}
		// refresh the buttons, especially the annotations to list the new name
		shapesMain_refreshTargetItem {$tgt};
		string $drv = dict_getStringValue($comboDict, "shapeDriver");
		shapesMain_refreshTargetItem {$drv};
	}
}


global proc int shapesCombo_verifyShapeBasedCombo( string $multNode )
{
	//
	// checks if the given multiplier node handles a shape based combo
	//
	global string $gShapes_bsNode;
	
	string $source[] = `listConnections -p 1 ($multNode + ".i2x")`;
	// check if the second source is the blendshape node
	// in this case the combo is a shape based combo
	int $shapeCombo = 0;
	if (size($source))
	{
		string $items[] = stringToStringArray($source[0], ".");
		if ($items[0] == $gShapes_bsNode)
			$shapeCombo = 1;
	}
	return $shapeCombo;
}


global proc string[] shapesCombo_getComboMasterNode( string $node, int $driver )
{
	//
	// returns the name of the master multiply node of a combo
	//
	string $attrList[] = `listAttr -m -ud $node`;
	if (!size($attrList))
		return {};
	// remove the [] from the multi attribute (in case of the driven node)
	string $temp[] = stringToStringArray($attrList[0], "[");
	string $msgAttr = $temp[0];
	
	// get the master node through the message attribute
	//
	// if the provided node is already the master node checking for connected nodes
	// is mainly to make sure that the setup is correct and that the master node
	// is connected to the other multiply nodes
	string $conn[] = `listConnections -s (!$driver) -d $driver -sh 1 ($node + "." + $msgAttr)`;
	if (!size($conn))
	{
		// in case of a legacy combo the message attribute is not connected
		// in this case we set the connected node to the already found node
		// this causes a double entry which needs to be removed later
		$conn = {$node};
	}
	
	// in case of coming from the target shape the search can end here
	// because the master node has already been verified
	// all found connected nodes will be returned and used for getComboNodes
	if (!$driver)
		return $conn;
	
	// make sure that the found master node has a message attribute
	$attrList = `listAttr -m -ud $conn[0]`;
	if (!size($attrList))
		return {};
	
	return {$conn[0]};
}


global proc string[] shapesCombo_getComboNodes( string $shape )
{
	//
	// returns a dictionary with all relevant nodes of the combo
	//
	if ($shape == "")
		return {};
	
	string $master[];
	string $comboMultNodes[];
	string $driverList[];
	string $driven[];
	string $comboDictList[];
	
	string $driver[];
	
	string $queryPlug = shapesMain_getQueryPlug($shape);
	
	// find the master node
	// if the shape is driven by the combo the connected multiply node is the master
	// in this case the message attribute has incoming connections;
	// if the shape is the driver it's multiply node is messaging to the master node
	
	int $cnCount = 0;
	
	// check if there is a multiply node driving the shape
	string $multNode[] = `listConnections -s 1 -d 0 -type "multiplyDivide" $queryPlug`;
	if (size($multNode))
	{
		for ($m in $multNode)
		{
			string $nodeList[] = shapesCombo_getComboMasterNode($m, 0);
			if (!size($nodeList))
				return {};
	
			$driven[size($driven)] = $shape;
			$comboMultNodes[size($comboMultNodes)] = stringArrayToString($nodeList, ",");
			$master[size($master)] = $m;
			
			$cnCount ++;
		}
	}
	// if the shape is not driven by a combo it must the one of the drivers
	else
	{
		// check if the shape is outputting to a multiply node
		$multNode = `listConnections -s 0 -d 1 -type "multiplyDivide" $queryPlug`;
		if (!size($multNode))
			return {};
		
		for ($m in $multNode)
		{
			string $comboMaster[] = shapesCombo_getComboMasterNode($m, 1);
			if (!size($comboMaster))
				return {};
		
			// get the driven shape from the multiply node output
			string $conn[] = `listConnections -p 1 ($comboMaster[0] + ".ox")`;
			$driven[size($driven)] = shapesMain_getFilteredTargetFromPlug($conn[0]);
			$master[size($master)] = $comboMaster[0];
			// simple way to retrieve the multiply nodes because the master node has been found
			string $nodeList[] = shapesCombo_getComboMasterNode($comboMaster[0], 0);
			$comboMultNodes[size($comboMultNodes)] = stringArrayToString($nodeList, ",");
			
			$cnCount ++;
		}
	}
	
	// get all driver nodes
	for ($i = 0; $i < $cnCount; $i ++)
	{
		string $driverNodes[] = stringToStringArray($comboMultNodes[$i], ",");
		string $items[] = {};
		for ($n in $driverNodes)
		{
			string $conn[] = `listConnections -p 1 ($n + ".i1x")`;
			if (size($conn))
				$items[size($items)] = shapesMain_getFilteredTargetFromPlug($conn[0]);
		}
		$driverList[size($driverList)] = stringArrayToString($items, ",");
	}
	
	// add the master multiply node to the node list
	// in case of a legacy combo the found combo multiplier node and the master node are the same
	// don't add the master node in this case
	for ($i = 0; $i < $cnCount; $i ++)
	{
		string $cmNodes[] = stringToStringArray($comboMultNodes[$i], ",");
		if (!stringArrayContains($master[$i], $cmNodes))
			stringArrayInsertAtIndex(0, $cmNodes, $master[$i]);
		
		string $driverItems[] = shapesArray_stringToQuotedArray($driverList[$i], ",", "'");
		string $comboItems[] = shapesArray_stringArrayToQuotedArray($cmNodes, "'");
		
		// if the second input of the master node is connected from a shape driver
		// list this connection as well
		string $plug = shapesCombo_getComboSecondaryDriver($queryPlug, $cmNodes[0]);
		if (`gmatch $plug "None:*"`)
		{
			string $temp[] = stringToStringArray($plug, ":");
			$driverItems[size($driverItems)] = "'" + $temp[1] + "'";
			$plug = "";
		}
		
		string $comboDict = "{'target': '" + $driven[$i] + "', 'driver': [" + stringArrayToString($driverItems, ",") + "], 'comboNodes': [" + stringArrayToString($comboItems, ",") + "], 'shapeDriver': '" + $plug + "'}";
		
		$comboDictList[size($comboDictList)] = $comboDict;
	}
	
	return $comboDictList;
}


global proc string shapesCombo_getComboSecondaryDriver( string $plug, string $multNode )
{
	//
	// returns the plug if the target shape is driven by a combo
	// and the second input of the combo master node is controlled by a shape driver;
	// this check replaces getComboNodes() when collecting target information
	// for ($building the target list and should be faster than getComboNodes() 
	//
	// check if there is a multiply node driving the shape
	if ($multNode == "")
	{
		string $conn[] = `listConnections -s 1 -d 0 -type "multiplyDivide" $plug`;
		if (!size($conn))
			return "";
		$multNode = $conn[0];
	}
	
	// if the second input of the master node is connected from a shape driver
	// list this connection as well
	string $conn[] = `listConnections -p 1 ($multNode + ".i2x")`;
	if (!size($conn))
		return "";
	// in case of a legacy shape based combo the second input is connected
	// to a target of the blend shape node and can be added to the driver list
	else
	{
		string $temp[] = stringToStringArray($conn[0], ".");
		if (`nodeType $temp[0]` == "blendShape")
			return ("None:" + $temp[1]);
	}
	
	return $conn[0];
}


global proc string[] shapesCombo_getComboItems( string $shape )
{
	//
	// returns all related combo items for the given shape
	//
	string $targets[];
	string $comboDictList[] = shapesCombo_getComboNodes($shape);
	for ($comboDict in $comboDictList)
	{
		$targets[size($targets)] = dict_getStringValue($comboDict, "target");
		string $drivers[] = dict_getValueArray($comboDict, "driver");
		for ($d in $drivers)
			$targets[size($targets)] = $d;
	}
	stringArrayRemoveDuplicates($targets);
	
	$targets = stringArrayRemove ({$shape}, $targets);
	return $targets;
}


// --------------------------------------------------------------------------------------------------
// combo editing
// --------------------------------------------------------------------------------------------------

global proc shapesCombo_editComboItems( string $target )
{
	//
	// initializes the combo edit process
	// selects all driving shapes and the driven shape
	// of the combo in the target list
	//
	global float $gShapes_driverCol[];
	global float $gShapes_targetCol[];
	global string $gShapes_comboEditDict;
	global string $gShapes_currentComboTarget;
	
	string $comboDictList[] = shapesCombo_getComboNodes($target);
	string $comboDict = $comboDictList[0];
	
	// create a copy of the current combo dictionary to use for editing
	$gShapes_comboEditDict = $comboDict;
	// store the current target for the update process
	string $tgt = dict_getStringValue($comboDict, "target");
	$gShapes_currentComboTarget = $tgt;
	
	treeView -e -cs shpUI_targetTree;
	shapesMain_buildTargetSlider;
	
	string $drv[] = dict_getValueArray($comboDict, "driver");
	for ($item in $drv)
	{
		shapesUI_expandParentItem $item;
		treeView -e -lbc $item $gShapes_driverCol[0] $gShapes_driverCol[1] $gShapes_driverCol[2] shpUI_targetTree;
	}
	treeView -e -lbc $tgt $gShapes_targetCol[0] $gShapes_targetCol[1] $gShapes_targetCol[2] shpUI_targetTree;
	
	shapesUI_showEditComboUI 1;
	shapesCombo_editComboToggleUI 0;
}


global proc shapesCombo_addRemoveComboItems( int $add )
{
	//
	// add/remove the selected items in the list to the currently shown combo
	// items will be color coded and the current combo selection list is updated
	//
	global float $gShapes_driverCol[];
	global string $gShapes_comboEditDict;
	
	string $selection[] = `treeView -q -si shpUI_targetTree`;
	if (!size($selection))
		return;
	
	if ($add)
	{
		for ($item in $selection)
		{
			$gShapes_comboEditDict = dict_addArrayValue({$gShapes_comboEditDict}, 0, "driver", $item);
			treeView -e -lbc $item $gShapes_driverCol[0] $gShapes_driverCol[1] $gShapes_driverCol[2] shpUI_targetTree;
		
			// if the selection is the same as the combo target remove the target
			if (stringArrayContains($item, dict_getValueArray($gShapes_comboEditDict, "target")))
				$gShapes_comboEditDict = dict_setValue({$gShapes_comboEditDict}, 0, "target", "");
		}
	}
	else
	{
		for ($item in $selection)
		{
			// reset the target color
			treeView -e -lbc $item -1 -1 -1 shpUI_targetTree;
			if (stringArrayContains($item, dict_getValueArray($gShapes_comboEditDict, "driver")))
				$gShapes_comboEditDict = dict_removeArrayValue({$gShapes_comboEditDict}, 0, "driver", $item);
		}
	}
	
	treeView -e -cs shpUI_targetTree;
}


global proc shapesCombo_setComboTarget()
{
	//
	// sets the selected item as the new combo target
	//
	global float $gShapes_targetCol[];
	global string $gShapes_comboEditDict;
	
	string $selection[] = `treeView -q -si shpUI_targetTree`;
	if (!size($selection))
		return;
	
	string $tgt = dict_getStringValue($gShapes_comboEditDict, "target");
	
	// reset the previous target color
	if ($tgt != "")
		treeView -e -lbc $tgt -1 -1 -1 shpUI_targetTree;
	
	$gShapes_comboEditDict = dict_setValue({$gShapes_comboEditDict}, 0, "target", $selection[0]);
	treeView -e -lbc $selection[0] $gShapes_targetCol[0] $gShapes_targetCol[1] $gShapes_targetCol[2] shpUI_targetTree;
	
	if (stringArrayContains($selection[0], dict_getValueArray($gShapes_comboEditDict, "driver")))
		$gShapes_comboEditDict = dict_removeArrayValue({$gShapes_comboEditDict}, 0, "driver", $selection[0]);
	
	treeView -e -cs shpUI_targetTree;
}


global proc shapesCombo_updateCombo()
{
	//
	// exists edit combo mode
	// the old combo is deleted and a new one created
	//
	global string $gShapes_comboEditDict;
	global string $gShapes_currentComboTarget;
	global string $gShapes_selectedTarget;
	global string $gShapes_orderedTargetList[];
	
	string $tgt = dict_getStringValue($gShapes_comboEditDict, "target");
	if ($tgt == "")
		error "The updated combo has no target";
	
	string $drv[] = dict_getValueArray($gShapes_comboEditDict, "driver");
	if (!size($drv))
		error "The updated combo has no driver";
	
	// delete the old combo
	shapesCombo_removeCombo $gShapes_currentComboTarget 0;
	
	// create a new combo based on the selection
	shapesCombo_performCreateCombo $tgt $drv 1 0;
	
	// update the target list
	$gShapes_selectedTarget = $tgt;
	shapesMain_refreshTargetItem $gShapes_orderedTargetList;
	
	shapesCombo_cancelEditCombo;
}


global proc shapesCombo_cancelEditCombo()
{
	//
	// exits the combo edit mode without making modifications
	//
	global int $gShapes_comboProcess;
	
	// refresh the target list
	shapesMain_listBlendShapeTargets 0;
	
	shapesUI_showEditComboUI 0;
	shapesCombo_editComboToggleUI 1;
	$gShapes_comboProcess = 0;
}


global proc string[] shapesCombo_filterHelperAttributes( string $list[] )
{
	//
	// removes any helper attributes from the given list
	// to make sure that only blend shape targets are processed
	//
	global string $gShapes_bsData[];
	
	int $ids[] = shapesMain_getButtonDataIds($list);
	string $tempList[];
	for ($i = 0; $i < size($ids); $i ++)
	{
		if (!dict_getBoolValue($gShapes_bsData[$ids[$i]], "helper"))
			$tempList[size($tempList)] = $list[$i];
		else
			warning ("Unable to process \"" + $list[$i] + "\" because it is a helper attribute");
	}
	return $tempList;
}


global proc shapesCombo_editComboToggleUI( int $enable )
{
	//
	// disables/enables ui elements
	// based on entering/exiting the edit combo mode
	//
	// set the sculpt mode options enable state
	shapesUI_manageUIModeDependencies -1 1 $enable;
	
	if ($enable)
	{
		treeView 	-e 
					-adr 1 
					-arp 1 
					-dad ("shapesMain_storeNewTargetOrder {} {} {} {} {}") 
					-ecc shapesMain_redefineParent 
					-scc shapesMain_buildTargetSlider 
					shpUI_targetTree;
	}
	else
	{
		treeView 	-e 
					-adr 0 
					-arp 0 
					-dad shapesGlobal_doNothing 
					-ecc shapesGlobal_doNothing 
					-scc shapesGlobal_doNothing 
					shpUI_targetTree;
	}
}


global proc SHAPES_combo(){}
