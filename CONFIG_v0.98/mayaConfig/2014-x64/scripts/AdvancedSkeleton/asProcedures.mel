//     AdvancedSkeleton
//     Version 3.9.93
// 
// 
// AdvancedSkeleton is is a collection of Maya tools for doing character setup.
//   
// INSTALLATION: 
// Run the SETUP file (setup.exe) 
// Choose the Destination Folder.
// NOTE: destination folder must be your Maya user directory 
// eg: C:\Users\$user\Documents\maya\2014\
// Continue installation.
// Start Maya. 
// Now you will find a new Shelf called 'advancedSkeleton':  
// 
// For detailed instructions go to: www.animationstudios.com.au
// 
// Copyright (C)2014 Animation Studios
// 
// email: support@animationstudios.com.au
// Last Modified 17/04/2014

global proc asScriptLocator (){}

global proc string asScriptLocation ()
{
string $whatIs=`whatIs asScriptLocator`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;
return $scriptLocation;
}

global proc float asCharSize (string $topNode)
{
float $charSize;
float $charAxisSizes[];
string $allChildren[]=`listRelatives -ad -f -type joint $topNode`;
float $highestJointX,$highestJointY,$highestJointZ;
float $lowestJointX,$lowestJointY,$lowestJointZ;
float $temp[3];
for ($child in $allChildren)
	{
	$temp=`xform -q -ws -t $child`;
	if ($temp[0]>$highestJointX) $highestJointX=$temp[0];
	if ($temp[0]<$lowestJointX) $lowestJointX=$temp[0];

	if ($temp[1]>$highestJointY) $highestJointY=$temp[1];
	if ($temp[1]<$lowestJointY) $lowestJointY=$temp[1];

	if ($temp[2]>$highestJointZ) $highestJointZ=$temp[2];
	if ($temp[2]<$lowestJointZ) $lowestJointZ=$temp[2];
	}
$charAxisSizes[0]=$highestJointX-$lowestJointX;
$charAxisSizes[1]=$highestJointY-$lowestJointY;
$charAxisSizes[2]=$highestJointZ-$lowestJointZ;
$charAxisSizes=`sort $charAxisSizes`;
$charSize=$charAxisSizes[2];
return $charSize;
}

global proc float asgetCharHeight ()
{
float $height;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
return $height;
}

global proc displayAllJointRLA (string $topNode, int $onOff)
{
string $joints[];
//Before AdvancedSkeleton build, FitSkeleton is not defined yet, so using all joints
if ($topNode=="FitSkeleton" && !`objExists $topNode`)
	$joints=`ls -type joint`;
else if (!`objExists $topNode`)
	return;
else
	$joints=`listRelatives -ad -type joint $topNode`;
for ($i=0;$i<size($joints);$i++)
	{
	string $tempString[]=`listRelatives -c -type joint $joints[$i]`;
	int $value=$onOff;
	if ($tempString[0]=="")
		$value=0;
	setAttr ($joints[$i]+".displayLocalAxis") $value;
	}
}

global proc asCreateAngleAttrs (string $joint)
{
string $sel[]=`ls -sl`;
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
float $charHeight=`asgetCharHeight`;
int $sideFactor=1;
if (`gmatch $joint "*_L"`)
	$sideFactor=-1;
string $FKjoint=$joint;
if (`objExists ("FK"+$joint)`)
	$FKjoint="FK"+$joint;
string $XYZ[]={"X","Y","Z"};
string $xyz[]={"x","y","z"};
string $RGB[]={"R","G","B"};
string $posNegs[]={"Pos","Neg"};
for ($i=0;$i<size($XYZ);$i++)
	{
	addAttr -k 1 -ln ("angle"+$XYZ[$i]) -at double $joint;
	addAttr -k 0 -ln ("angle"+$XYZ[$i]) -at double $FKjoint;
	setAttr -e -channelBox true ("FK"+$joint+".angle"+$XYZ[$i]);
	connectAttr -f ($joint+".angle"+$XYZ[$i]) ($FKjoint+".angle"+$XYZ[$i]);
	}
if (!`objExists AngleSystem`)
	createNode -n AngleSystem -p MotionSystem transform;

string $tempString[]=`listRelatives -p $joint`;
string $parent=$tempString[0];

createNode -n ($joint+"AngleSamplerBaseParent") -p AngleSystem transform;
createNode -n ($joint+"AngleSamplerBase") -p ($joint+"AngleSamplerBaseParent") transform;
pointConstraint $parent ($joint+"AngleSamplerBaseParent");
orientConstraint $parent ($joint+"AngleSamplerBaseParent");
delete `orientConstraint $joint ($joint+"AngleSamplerBase")`;
pointConstraint $joint ($joint+"AngleSamplerBase");

for ($i=1;$i<size($XYZ);$i++)
	for ($y=0;$y<size($posNegs);$y++)
		{
		string $loc=$joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y];
		spaceLocator -n $loc;
		parent $loc ($joint+"AngleSamplerBase");
		setAttr -type float3 ($loc+".t") 0 0 0;
		setAttr -type float3 ($loc+".r") 0 0 0;
		setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
		}
setAttr ($joint+"AngleSamplerYPos.tz") ($sideFactor*-1*0.7071104);
setAttr ($joint+"AngleSamplerYNeg.tz") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZPos.ty") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZNeg.ty") ($sideFactor*-1*0.7071104);

createNode -n ($joint+"AngleSamplerRotate") -p ($joint+"AngleSamplerBase") transform;
orientConstraint $joint ($joint+"AngleSamplerRotate");

string $loc=$joint+"AngleSamplerEnd";
spaceLocator -n $loc;
parent $loc ($joint+"AngleSamplerRotate");
setAttr -type float3 ($loc+".t") ($sideFactor*0.7071104) 0 0;
setAttr -type float3 ($loc+".r") 0 0 0;
setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);

for ($y=0;$y<size($posNegs);$y++)
	{
	createNode -n ($joint+"OneMinus"+$posNegs[$y]) plusMinusAverage;
	setAttr ($joint+"OneMinus"+$posNegs[$y]+".operation") 2;
	setAttr -type float3 ($joint+"OneMinus"+$posNegs[$y]+".input3D[0]") 1 1 1;
	}
//Y & Z
for ($i=1;$i<size($XYZ);$i++)
	{
	for ($y=0;$y<size($posNegs);$y++)
		{
		createNode -n ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]) distanceBetween;
		connectAttr -f ($joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y]+"Shape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point1");
		connectAttr -f ($joint+"AngleSamplerEndShape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point2");
		connectAttr -f ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".distance") ($joint+"OneMinus"+$posNegs[$y]+".input3D[1].input3D"+$xyz[$i]);
		}
	createNode -n ($joint+"AngleCondition"+$XYZ[$i]) condition;
	setAttr ($joint+"AngleCondition"+$XYZ[$i]+".operation") 2;
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".firstTerm");
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".secondTerm");
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".colorIfTrue"+$RGB[$i]);
	createNode -n ($joint+"AngleInverse"+$XYZ[$i]) unitConversion;
	setAttr ($joint+"AngleInverse"+$XYZ[$i]+".conversionFactor") -1;
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleInverse"+$XYZ[$i]+".input");
	connectAttr -f ($joint+"AngleInverse"+$XYZ[$i]+".output") ($joint+"AngleCondition"+$XYZ[$i]+".colorIfFalse"+$RGB[$i]);
	connectAttr -f ($joint+"AngleCondition"+$XYZ[$i]+".outColor.outColor"+$RGB[$i]) ($joint+".angle"+$XYZ[$i]);
	}
//X
createNode -n ($joint+"AngleXMultiplyDivide") multiplyDivide;
setAttr ($joint+"AngleXMultiplyDivide.operation") 2;
setAttr -type float3 ($joint+"AngleXMultiplyDivide.input2") 90 1 1;
if (`objExists ("TwistBalancer"+$joint)`) // tapping into existing twist system
	connectAttr -f ("TwistBalancer"+$joint+".rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
else // create twist deriver
	{
	select ($joint+"AngleSamplerBase");
	joint -n ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXUnTwistEnd");
	setAttr ($joint+"AngleXUnTwistEnd.tx") ($charHeight/12.0*$sideFactor);
	select ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXBalancer");
	orientConstraint -mo ($joint) ($joint+"AngleXBalancer");
	ikHandle -n ($joint+"AngleXUnTwistIK") -ns 2 -sol "ikRPsolver" -sj ($joint+"AngleXUnTwist") -ee ($joint+"AngleXUnTwistEnd");
	parent ($joint+"AngleXUnTwistIK") ($joint+"AngleSamplerBase");
	parentConstraint -mo $joint ($joint+"AngleXUnTwistIK");
	createNode -n ($joint+"AngleXUnTwistPoleVec") -p ($joint+"AngleSamplerBase") transform;
	poleVectorConstraint ($joint+"AngleXUnTwistPoleVec") ($joint+"AngleXUnTwistIK");
	connectAttr -f ($joint+"AngleXBalancer.rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
	}
connectAttr ($joint+"AngleXMultiplyDivide.output.outputX") ($joint+".angleX");

setAttr -l 1 ($joint+"AngleSamplerBaseParent.v") 0;
eval($restorePoseCmd);
select $sel;
}

global proc string asCreateBlendedAttribute (string $drivers[])
{
string $sel[]=`ls -sl`;
string $tempString[],$driverObjs[],$driverAttrs[];
string $attr;
for ($i=0;$i<size($drivers);$i++)
	{
	tokenize $drivers[$i] "[.]" $tempString;
	$driverObjs[$i]=$tempString[0];
	$driverAttrs[$i]=$tempString[1];
	$attr+=$driverAttrs[$i];
	if (`getAttr $drivers[$i]`>=0)
		$attr+="Pos";
	else
		$attr+="Neg";
	if ($i<size($drivers)-1)
		$attr+="_";
	}

createNode -n BlendedCorrectiveDriver transform;
addAttr -ln driverObj -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverObj $driverObjs[0];
addAttr -ln driverAttr -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverAttr $attr;

if (`attributeExists $attr $driverObjs[0]`)
	{
	select $sel;
	return $attr;
	}

addAttr -k 0 -ln $attr -at double $driverObjs[0];
setAttr -e -channelBox true ($driverObjs[0]+"."+$attr);
if (!`gmatch $driverObjs[0] "FK*"` && `objExists ("FK"+$driverObjs[0])`)
	{
	addAttr -k 0 -ln $attr -at double ("FK"+$driverObjs[0]);
	setAttr -e -channelBox true ("FK"+$driverObjs[0]+"."+$attr);
	connectAttr ($driverObjs[0]+"."+$attr) ("FK"+$driverObjs[0]+"."+$attr);
	}

string $mpd,$sr;
string $previousOutput=$driverObjs[0]+"."+$driverAttrs[0];
for ($i=1;$i<size($drivers);$i++)
	{
	$sr=$driverObjs[0]+$attr+"SetRange"+$i;
	$mpd=$driverObjs[0]+$attr+"MultiplyDivide"+$i;
	createNode -n $sr setRange;
	connectAttr -f $previousOutput ($sr+".valueX");
	connectAttr -f ($driverObjs[$i]+"."+$driverAttrs[$i]) ($sr+".valueY");
	setAttr -type float3 ($sr+".max") 1 1 1;
	setAttr ($sr+".oldMaxX") `getAttr ($sr+".valueX")`;
	setAttr ($sr+".oldMaxY") `getAttr ($sr+".valueY")`;
	addAttr -k 1 -ln dvX -at double -dv `getAttr ($sr+".valueX")` $sr;
	addAttr -k 1 -ln dvY -at double -dv `getAttr ($sr+".valueY")` $sr;

	createNode -n $mpd multiplyDivide;
	connectAttr ($sr+".outValueX") ($mpd+".input1.input1X");
	connectAttr ($sr+".outValueY") ($mpd+".input2.input2X");
	if (`getAttr ($sr+".valueX")`<0)	//reverse negative numbers X
		{
		setAttr ($sr+".minX") 1;
		setAttr ($sr+".maxX") 0;
		setAttr ($sr+".oldMinX") (`getAttr ($sr+".oldMaxX")`);
		setAttr ($sr+".oldMaxX") 0;
		}
	if (`getAttr ($sr+".valueY")`<0)	//reverse negative numbers Y
		{
		setAttr ($sr+".minY") 1;
		setAttr ($sr+".maxY") 0;
		setAttr ($sr+".oldMinY") (`getAttr ($sr+".oldMaxY")`);
		setAttr ($sr+".oldMaxY") 0;
		}
	$previousOutput=($mpd+".outputX");
	}
connectAttr -f $previousOutput ($driverObjs[0]+"."+$attr);
select $sel;
return $attr;
}

global proc string[] asSetBlendedAttribute (string $driverObj, string $driverAttr, float $value, int $getDriversMode)
{
string $tempString[],$drivers[];
int $connectedToMultDiv=1;
string $plug=$driverObj+"."+$driverAttr;
string $drivers[];
float $dvs[];
int $connectedToMultDiv=1;
while ($connectedToMultDiv)
	{
	$connectedToMultDiv=0;
	$tempString=`listConnections -s 1 -d 0 -scn 1 $plug`;
	string $nodeA=$tempString[0];
	if(size($tempString)>0)
		{
		if (`objectType $nodeA`=="multiplyDivide")
		{
		$connectedToMultDiv=1;
		$plug=$nodeA+".input1.input1X";
		}
		else if (`objectType $nodeA`=="setRange")
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueY")`;
			$drivers[size($drivers)]=$tempString[0];
			$dvs[size($dvs)]=`getAttr ($nodeA+".dvY")`;
			
			$tempString=`listConnections -s 1 -d 0 -p 0 -scn 1 ($nodeA+".valueX")`;
			string $nodeB=$tempString[0];
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueX")`;
			if (`objectType $nodeB`=="multiplyDivide")
				{
				$connectedToMultDiv=1;
				$plug=$nodeA+".valueX";
				}
			else
				{
				$drivers[size($drivers)]=$tempString[0];
				$dvs[size($dvs)]=`getAttr ($nodeA+".dvX")`;
				}
			}
		}
	
	}

//For inbetweens, just find the values were all inputs are equal, and sum up to total
if ($value<1)
	for ($i=0;$i<size($dvs);$i++)
		{
		float $temp=`pow $dvs[$i] 2`;
		$dvs[$i]=`sqrt($temp*$value)`;
		}

for ($i=0;$i<size($drivers);$i++)
	if (!$getDriversMode)
		{
		string $setDriver=$drivers[$i];
		if (`gmatch $setDriver "*[.]angle*"`)// blended angles
			{
			tokenize $setDriver "[.]" $tempString;
			string $driverObj=$tempString[0];
			string $driverAttr=$tempString[1];
			asSetRotationFromAngle $driverObj $driverAttr $dvs[$i];
			}
		else
			{
			string $FKDriver="FK"+$drivers[$i];
			if (`objExists $FKDriver`)
				$setDriver=$FKDriver;
			setAttr $setDriver $dvs[$i];
			}
		}
$drivers=`sort $drivers`;
return $drivers;
}

global proc asCreateCorrectiveShape ()
{
string $sel[]=`ls -sl -o`;
if(size($sel)==0)
	error "No mesh selected, select geometry on your character";
if (size($sel)>1)
	error "More than 1 object selected, Only 1 object must be selected";
if (`gmatch $sel[0] "*__*"`)
	error "Selected object IS a Corrective Shape. Select geometry on your character";
if ($sel[0]!="")
	if (`objectType $sel[0]`=="mesh")
		$sel=`listRelatives -p $sel[0]`;
string $tempString[]=`listRelatives -ni -s $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not geometry";
if (`objectType $tempString[0]`!="mesh")
	error "Selected object is not a mesh";

string $controlSetMembers[]=`sets -q ControlSet`;
string $tempString[],$tempString2[];
if (`objExists FaceControlSet`)
	{
	//As below v3.9.7 had bug where EyeOrientOffset_L was in FaceControlSet
	if (`objExists EyeOrientOffset_L`)
		if (`sets -im FaceControlSet EyeOrientOffset_L`)
			sets -rm FaceControlSet EyeOrientOffset_L;
	$tempString=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $tempString`;
	//ctrlMouth_M connected to FKExtraJaw_M, causes double driver.
	if (`objExists ctrlMouth_M` && `stringArrayCount FKExtraJaw_M $controlSetMembers`)
		$controlSetMembers=`stringArrayRemove {"FKExtraJaw_M"} $controlSetMembers`;
	}
if (`objExists Main`)
	{
	float $version=`getAttr Main.version`;
	if ($version<=3.97)
		warning ("This rig was build with AdvancedSkeleton version:"+$version
			+", Corrective Shapes with version 3.97 or below can cause unpredictable results");
	}

//string $tr[]={"t","r"};
//string $xyz[]={"x","y","z"};
string $drivers[],$keyableAttr[];
string $objAttr;
float $poseValue,$currentValue;
//Find driving attribute(s)
string $buildPoseCmds[],$runCmds[];
//get $buildPoseCmds
$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}
string $runObjAttrs[],$checkObjAttr[];
float $runValues[];
for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<2;$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];
			//																									//
			if (`gmatch $checkObjAttr[$z] "FKExtraJaw_M*"`)//ban FKExtraJaw_M as this is commonly already a driven controller.
				continue;
			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//ban FKIK* as this might be just to get to FK.
				continue;
			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				$drivers[size($drivers)]=$checkObjAttr[$z];
			}
		}
	}
if (size($drivers)==0)
	error ("Found no driving attribute, all values are in Build-Pose");

for ($i=0;$i<size($drivers);$i++)
	{
	string $nonFKDriver=`substitute "FK" $drivers[$i] ""`;
	if (`objExists $nonFKDriver`)
//		if (!`gmatch $drivers[0] "FK*[.]translate*"`) //(FK*.t* dont have zero default values)
			$drivers[$i]=$nonFKDriver;
	}

tokenize $drivers[0] "[.]" $tempString;
string $deformObj=$sel[0];
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
float $dv=`getAttr $drivers[0]`;
float $idv=0;

//angle driver
if (`checkBox -q -v asCorrectiveAngleCheckBox`)
	if (`gmatch $driverAttr "r*"`)//rotation && !blended
		{
		if (!`attributeExists "angleX" $driverObj`)
			asCreateAngleAttrs $driverObj;

		//Max 90 degrees
		float $FKdv=`getAttr ("FK"+$drivers[0])`;
		if (abs($FKdv)>90)
			{
			warning ("Angle rotation more than 90 degrees, now reducing rotation to 90.");
			if ($dv>0) $dv=90;
			if ($dv<0) $dv=-90;
			setAttr ("FK"+$drivers[0]) $dv;
			}
		for ($i=0;$i<size($drivers);$i++)
			{
			if (`gmatch $drivers[$i] "*[.]rotate*"`)
				{
				$drivers[$i]=`substitute "rotate" $drivers[$i] "angle"`;
				$driverAttr=`substitute "rotate" $driverAttr "angle"`;
				}
			$idv=$dv;
			$dv=`getAttr ($driverObj+"."+$driverAttr)`;
			}
		//2 rotation attributes could be translated to 3 angle attributes
		string $XYZ[]={"X","Y","Z"};
		if (size($drivers)>1)
			for ($i=0;$i<size($drivers);$i++)
				{
				for ($y=0;$y<size($XYZ);$y++)
					{
					string $check=$driverObj+".angle"+$XYZ[$y];
					float $checkVal=`getAttr $check`;
					if (abs($checkVal)>0.001)
						if (!`stringArrayCount $check $drivers`)
							{
							$drivers[size($drivers)]=$check;
							$drivers=`sort $drivers`;
							}
					}
				}
		}

if (size($drivers)>1)
	{
	//We might have arrived back here from already created blendAttr
	if (`objExists BlendedCorrectiveDriver`)
		{
		$driverObj=`getAttr BlendedCorrectiveDriver.driverObj`;
		$driverAttr=`getAttr BlendedCorrectiveDriver.driverAttr`;
		$dv=`getAttr ($driverObj+"."+$driverAttr)`;
		}
	else
		{
		string $m="Create Corrective Shape from blend of these drivers?\n\n";
		for ($i=0;$i<size($drivers);$i++)
			{
			float $value=`getAttr $drivers[$i]`;
			$value=(trunc($value*`pow 10 3`+0.5)/`pow 10 3`);//Roundoff Driver to 3 decimals
			$m+=$drivers[$i]+" = "+$value+"\n";
			}
		string $dialog=`confirmDialog -t "Multiple Drivers Found"
			-m $m
			-b "OK" -b "Cancel" -db "Cancel"
			-ds "Cancel"`;
		if ($dialog!="OK")
			return;
		if ($dialog=="OK")
			{
			asCreateBlendedAttribute $drivers;
			asCreateCorrectiveShape;
			return;
			}
		}
	}

string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
//Roundoff Driver to 3 decimals
if ($dv>=0) $dv=(trunc($dv*`pow 10 3`+0.5)/`pow 10 3`);
else $dv=(trunc(abs($dv)*`pow 10 3`+0.5)/`pow 10 3`)*-1;

float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr+"__"+$posNeg;

if (size($drivers)==1)
	{
	string $dialog=`confirmDialog -t "Multiple Drivers Found"
		-m ("Create Corrective Shape from this driver?\n\n"+$driverObj+"."+$driverAttr+" = "+$dv)
		-b "OK" -b "Cancel" -db "Cancel"
		-ds "Cancel"`;
	if ($dialog!="OK")
		return;
	}

asCorrectiveDuplicate $attrCode $sel[0];

addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;
}

global proc float asCorrectiveGetIV (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $iv=1;
string $bs=$deformObj+"Corrective";
if (!`objExists $bs`)
	return 1;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
float $maxKeyVal;
string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount ($driverObj+"__"+$driverAttr+"__"+$posNeg) $weights`)
	{
	$tempString=`listConnections ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
	float $keyXValues[]=`keyframe -q -fc $tempString[0]`;
	float $keyYValues[]=`keyframe -q -vc $tempString[0]`;
	float $xvalueAtOneY=$keyXValues[size($keyXValues)-1];
	for ($i=0;$i<size($keyYValues);$i++)
		if ($keyYValues[$i]==1)
			$xvalueAtOneY=$keyXValues[$i];

	$iv=$dv/$xvalueAtOneY;
	if ($iv>=0) $iv=(trunc($iv*`pow 10 3`+0.5)/`pow 10 3`);//Roundoff to 3 decimals
	else $iv=(trunc(abs($iv)*`pow 10 3`+0.5)/`pow 10 3`)*-1;
	}
return $iv;
}

global proc asCorrectiveDuplicate (string $attrCode, string $source)
{
float $charHeight=`asgetCharHeight`;
duplicate -n $attrCode $source;
string $tempString[]=`listRelatives -p $attrCode`;
if ($tempString[0]!="")
	parent -w $attrCode;
asLockAttr $attrCode 0 0 0 0;
$tempString=`listRelatives -s $attrCode`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="mesh")
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];

button -e -en 1 asCancelCorrectiveShapeButton;
button -e -en 1 asConnectCorrectiveShapeButton;
button -e -en 0 asCreateCorrectiveButton;
button -e -en 0 asReCreateCorrectiveButton;
button -e -en 0 asDeleteCorrectiveButton;
button -e -en 0 asGraphCorrectiveButton;
setAttr "Group.v" 0;

$tempString=`ls -sl -l $source`;
if (!`gmatch $tempString[0] "|Group|*"`)
	{
	setAttr ($source+".v") 0;
	if (!`attributeExists "correctiveShapeModeHidden" "Group"`)
		addAttr -ln "correctiveShapeModeHidden" -dt "string" "Group";
	setAttr -type "string" "Group.correctiveShapeModeHidden" $source;
	}

//setAttr ($attrCode+".tx") ($charHeight*0.5);
select $attrCode;
SculptGeometryTool;

headsUpDisplay -s 2 -b 0 -bs "medium" -l "Corrective Shape Mode" -lfs "large" HUDCSMMode;
scriptJob -runOnce true -e deleteAll "asExitCorrectiveShapeMode";
scriptJob -runOnce true -nodeDeleted $attrCode "asExitCorrectiveShapeMode";
}

global proc asConnectCorrectiveShape ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $tempString[];
if (size($sel)<1)
	error "Select the Corrective Shape";
if (`gmatch $sel[0] "*[.]*"`)
	$sel=`ls -sl -o`;
if (`objectType $sel[0]`!="transform")
	{
	$tempString=`listRelatives -p $sel[0]`;
	$sel[0]=$tempString[0];
	}
if (size($sel)!=1)
	error "Select only the Corrective Shape";
string $restoreCmds[];
tokenize `substituteAllString $sel[0] "__"  "|"` "|" $tempString;
string $deformObj=$tempString[0];
string $driverObj=$tempString[1];
string $driverAttr=$tempString[2];
float $dv=`getAttr ($sel[0]+".driverValue")`;
float $idv=`getAttr ($sel[0]+".indirectDriverValue")`;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
float $iv=`getAttr ($sel[0]+".inbetweenValue")`;
int $deleteMode=`objExists DeleteCorrectiveShape`;
string $deltaShape=$driverObj+"__"+$driverAttr+"__"+$posNeg;
string $sdk=$deformObj+"Corrective_"+$deltaShape;
float $keyXValues[];
if (`objExists $sdk`)
	$keyXValues=`keyframe -q -fc $sdk`;
if ($sel[0]==$deformObj)
	error "Can not use itself as Corrective Shape, Select the Corrective Shape";
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;

int $isJoystick=0;
$tempString=`ls -l $driverObj`;
if (`gmatch $tempString[0] "*|ctrlBox|*"`)
	$isJoystick=1;
float $mirrorDv=$dv;
string $mirrorPosNeg=$posNeg;
if (($driverAttr=="translateX" && !$isJoystick) || (`gmatch $driverObj "FK*"` && `gmatch $driverAttr "translate*"`))
	{
	$mirrorDv=$dv*-1;
	if ($posNeg=="pos") $mirrorPosNeg="neg";
	if ($posNeg=="neg") $mirrorPosNeg="pos";
	}
int $doMirror=0;
string $mirrorDriverObj,$FKMirrorDriverObj,$mirrorDeltaShape,$mirrorSdk;
string $side="_R";
string $mirrorDriverAttr=$driverAttr;
string $mirrorSide="_L";
if (`gmatch $driverObj "*_L"`)
	{
	$side="_L";
	$mirrorSide="_R";
	}
if (`checkBox -q -v asCorrectiveMirrorCheckBox`)
	{
	$mirrorDriverObj=`substitute $side $driverObj $mirrorSide`;
	$FKMirrorDriverObj=`substitute $side $FKDriverObj $mirrorSide`;
	$mirrorDeltaShape=`substitute $side $deltaShape $mirrorSide`;
	if ($mirrorPosNeg!=$posNeg)
		$mirrorDeltaShape=`substitute $posNeg $mirrorDeltaShape $mirrorPosNeg`;
	$mirrorSdk=`substitute $side $sdk $mirrorSide`;

	if (`objExists $mirrorDriverObj` && $driverObj!=$mirrorDriverObj)
		{
		$doMirror=1;
		//angle attrs
		if (`gmatch $driverAttr "angle*"`)
			if (!`attributeExists "angleX" $mirrorDriverObj`)
				asCreateAngleAttrs $mirrorDriverObj;
		//blended attrs
		if (`gmatch $driverAttr "*_*"`)
			{
			string $drivers[]=`asSetBlendedAttribute $driverObj $driverAttr 0 1`;
			string $mirroredDrivers[];
			float $driverValues[],$mirroredDriverValues[],$rotates[];
			for ($i=0;$i<size($drivers);$i++)
				{
				$driverValues[$i]=`getAttr $drivers[$i]`;
				$mirroredDriverValues[$i]=$driverValues[$i];
				$mirroredDrivers[$i]=`substitute $side $drivers[$i] $mirrorSide`;
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						$rotates=`getAttr ($FKDriverObj+".r")`;
						setAttr -type float3 ($FKDriverObj+".r") 0 0 0;
						}
					}
				else
					setAttr $drivers[$i] 0;
				if ((`gmatch $mirroredDrivers[$i] "*[.]translateX"` && !$isJoystick) || (`objExists ("FK"+$driverObj)` && `gmatch $mirroredDrivers[$i] "*[.]translate*"`))
					$mirroredDriverValues[$i]=$driverValues[$i]*-1;
				//temporary mirror blended pose
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						setAttr -type float3 ($FKMirrorDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
					}
				else
					setAttr $mirroredDrivers[$i] $mirroredDriverValues[$i];
				}
			//asCreateBlendedAttribute
			$mirrorDriverAttr=`asCreateBlendedAttribute $mirroredDrivers`;
			$mirrorDeltaShape=$mirrorDriverObj+"__"+$mirrorDriverAttr+"__pos";
			//restore blended pose
			for ($i=0;$i<size($drivers);$i++)
				{
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						setAttr -type float3 ($FKMirrorDriverObj+".r") 0 0 0;
						setAttr -type float3 ($FKDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
						}
					}
				else
					{
					setAttr $mirroredDrivers[$i] 0;
					setAttr $drivers[$i] $driverValues[$i];					
					}
				}
			}
		}
	}

string $history[]=`listHistory $deformObj`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			{
			setAttr ($history[$i]+".envelope") 0;
			$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
			}
duplicate -n $deltaShape $deformObj;
asLockAttr $deltaShape 0 0 0 0;
$tempString=`listRelatives -p $deltaShape`;
if ($tempString[0]!="")
	parent -w $deltaShape;
addAttr -k 1 -ln driverValue -at double -dv $dv $deltaShape;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $deltaShape;
if($doMirror && !$deleteMode)
	{
	duplicate -n $mirrorDeltaShape $deformObj;
	asLockAttr $mirrorDeltaShape 0 0 0 0;
	$tempString=`listRelatives -p $mirrorDeltaShape`;
	if ($tempString[0]!="")
		parent -w $mirrorDeltaShape;
	addAttr -k 1 -ln driverValue -at double -dv $mirrorDv $mirrorDeltaShape;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $mirrorDeltaShape;
	}

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

//Inverse shapes from other deformers
//if (`gmatch $driverAttr "*_*"` && `objExists ($deformObj+"Corrective")`)
duplicate -n ($deltaShape+"_componentReverse") $deformObj;
$tempString=`listRelatives -p ($deltaShape+"_componentReverse")`;
if ($tempString[0]!="")
	parent -w ($deltaShape+"_componentReverse");
select $sel[0] $deformObj ($deltaShape+"_componentReverse");
blendShape -n ($deltaShape+"_componentReverseBS") -frontOfChain -w 0 1 -w 1 1;
//	setAttr ($deformObj+"Corrective.envelope") 0;
string $history[]=`listHistory $deformObj`;
//int $resetDeformer=1;
//string $resetTargetsRestoreCmd;
string $weights[];
if (`objExists ($deformObj+"Corrective.w")`)
	$weights=`listAttr -m ($deformObj+"Corrective.w")`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			{
//			$resetDeformer=1;
			//Dont reset the Corrective deformers.
//			if ($history[$i]==($deformObj+"Corrective") || $history[$i]==($deformObj+"PB"))
//				$resetDeformer=0;
			//For combined drivers, reset the `other` bs targets
			if ($history[$i]==($deformObj+"Corrective"))
				if (`gmatch $driverAttr "*_*"`)
					for ($y=0;$y<size($weights);$y++)
						{
						if ($weights[$y]!=$deltaShape)
							{
							setAttr ($deformObj+"Corrective."+$weights[$y]) 0;
//							$resetTargetsRestoreCmd+="setAttr "+$deformObj+"Corrective."+$weights[$y]+" 1;";
							}
						}
/*
			if ($resetDeformer)
				{
				setAttr ($history[$i]+".envelope") 0;
				$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
				}
*/
			}
select ($deltaShape+"_componentReverse");
DeleteHistory;
select ($deltaShape+"_componentReverse") $sel[0];
blendShape -n ($deltaShape+"_componentReverseBS2") -frontOfChain -w 0 1;
select $sel[0];
DeleteHistory;
//	setAttr ($deformObj+"Corrective.envelope") 1;
for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);
delete ($deltaShape+"_componentReverse");

//Restore bsTargets that were rest to Zero, by dgdirty. SDK`s will ensure restore.
dgdirty -a;
//eval ($resetTargetsRestoreCmd);

select $deltaShape $deformObj;
asCorrectiveConnectBS;

string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
	setAttr ($deformObj+"Corrective."+$deltaShape) 1;

int $incOnce,$numVtxMoved;
int $numVtxs[]=`polyEvaluate -v $deltaShape`;
float $mag,$prevMag,$move;
float $tol=0.001;
float $selPos[]=`xform -q -ws -t $sel[0]`;
float $deformPos[]=`xform -q -ws -t $deformObj`;
xform -ws -t $deformPos[0] $deformPos[1] $deformPos[2] $sel[0];
float $posA[3],$posA2[3],$posB[3],$temp[3];
string $xyz[]={"x","y","z"};
string $history[];

int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

float $zv=`getAttr ($driverObj+"."+$driverAttr)`;
$zv=(trunc($zv*`pow 10 3`+0.5)/`pow 10 3`);//Roundoff Driver to 3 decimals
float $mirrorZv;
if($doMirror)
	{
	$mirrorZv=`getAttr ($mirrorDriverObj+"."+$mirrorDriverAttr)`;
	$mirrorZv=(trunc($mirrorZv*`pow 10 3`+0.5)/`pow 10 3`);//Roundoff Driver to 3 decimals
	}

if (`gmatch $driverAttr "angleX*"`)
	setAttr ($FKDriverObj+".rx") $idv;
else if (`gmatch $driverAttr "angleY*"`)
	setAttr ($FKDriverObj+".ry") $idv;
else if (`gmatch $driverAttr "angleZ*"`)
	setAttr ($FKDriverObj+".rz") $idv;
else if (!`getAttr -settable ($FKDriverObj+"."+$driverAttr)`)
	asSetBlendedAttribute $FKDriverObj $driverAttr $dv 0;
else
	setAttr ($FKDriverObj+"."+$driverAttr) $dv;

$tempString=`listRelatives -s $deformObj`;
string $preDeformMesh;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		$preDeformMesh=$tempString[$i];

//matrix loop utilities
float $xPoint[],$yPoint[],$zPoint[],$newPos[];
createNode -n correctiveMatrixUtilities transform;
createNode -n matrix2xform parentConstraint;
createNode -n matrix2scale scaleConstraint;
createNode -n invMReaderOffset transform;
addAttr -ln theMatrix -dt "matrix" invMReaderOffset;
createNode -n invMReader -p invMReaderOffset transform;
createNode -n invMNewPos -p invMReader transform;
createNode -n defOffset transform;
createNode -n corPos -p defOffset transform;
connectAttr -f corPos.translate invMNewPos.translate;
connectAttr -f corPos.rotate invMNewPos.rotate;
connectAttr -f corPos.scale invMNewPos.scale;
//invMReaderOffset.theMatrix to matrixInverter.xform
createNode -n matrixInverter transform;
createNode -n matrix2xform2 parentConstraint;
createNode -n matrix2scale2 scaleConstraint;
connectAttr invMReaderOffset.theMatrix  matrix2xform2.target[0].targetParentMatrix;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateX matrixInverter.translate.translateX;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateY matrixInverter.translate.translateY;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateZ matrixInverter.translate.translateZ;
connectAttr matrix2xform2.constraintRotate.constraintRotateX matrixInverter.rotate.rotateX;
connectAttr matrix2xform2.constraintRotate.constraintRotateY matrixInverter.rotate.rotateY;
connectAttr matrix2xform2.constraintRotate.constraintRotateZ matrixInverter.rotate.rotateZ;
connectAttr invMReaderOffset.theMatrix matrix2scale2.target[0].targetParentMatrix;
connectAttr matrix2scale2.constraintScale matrixInverter.scale;
//matrixInverter.inverseMatrix to invMReader.xform
connectAttr matrixInverter.inverseMatrix matrix2xform.target[0].targetParentMatrix;
connectAttr matrix2xform.constraintTranslate.constraintTranslateX invMReader.translate.translateX;
connectAttr matrix2xform.constraintTranslate.constraintTranslateY invMReader.translate.translateY;
connectAttr matrix2xform.constraintTranslate.constraintTranslateZ invMReader.translate.translateZ;
connectAttr matrix2xform.constraintRotate.constraintRotateX invMReader.rotate.rotateX;
connectAttr matrix2xform.constraintRotate.constraintRotateY invMReader.rotate.rotateY;
connectAttr matrix2xform.constraintRotate.constraintRotateZ invMReader.rotate.rotateZ;
connectAttr matrixInverter.inverseMatrix matrix2scale.target[0].targetParentMatrix;
connectAttr matrix2scale.constraintScale invMReader.scale;
parent matrix2xform matrix2scale invMReaderOffset defOffset matrixInverter matrix2xform2 matrix2scale2 correctiveMatrixUtilities;
//setAttr ($deformObj+"Corrective.envelope") 0;

//Existing blendShape nodes causes a inverse (&multiplied) deformation, so envelope off these.
$history=`listHistory $deformObj`;
clear $restoreCmds;
string $bsNodes[];
string $skinCluster;
for ($i=0;$i<size($history);$i++)
	{
	if (`objectType $history[$i]`=="skinCluster" && $skinCluster=="")
		$skinCluster=$history[$i];
	if (`objectType $history[$i]`=="blendShape" && $history[$i]!="asFaceBS")
		{
		setAttr ($history[$i]+".envelope") 0;
		$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
		}
	}

//Make sure the corrective is the first BS before the skinCluster
catchQuiet (`reorderDeformers $skinCluster ($deformObj+"Corrective") $deformObj`);
//And before "asFaceBS"
if (`objExists "asFaceBS"`)
	catchQuiet (`reorderDeformers "asFaceBS" ($deformObj+"Corrective") $deformObj`);

//xyz Offsets`s
move -r 1 0 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n xOffsetts $deformObj;
move -r -1 1 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n yOffsetts $deformObj;
move -r 0 -1 1 ($preDeformMesh+".vtx[0:999999]");
duplicate -n zOffsetts $deformObj;
move -r 0 0 -1 ($preDeformMesh+".vtx[0:999999]");
asLockAttr xOffsetts 0 0 0 0;
asLockAttr yOffsetts 0 0 0 0;
asLockAttr zOffsetts 0 0 0 0;
parent xOffsetts yOffsetts zOffsetts correctiveMatrixUtilities;

progressBar -e -st ("Computing Delta Shape") -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
for ($i=0;$i<$numVtxs[0];$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
		blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
		delete $deltaShape;
		if (`objExists $mirrorDeltaShape`)
			delete $mirrorDeltaShape;
		delete correctiveMatrixUtilities;
		select $sel[0];
		print ("// Corrective Shape Cancelled	\n");
		return;
		}
	if ($deleteMode)
		break;
	progressBar -e -s 1 $gMainProgressBar;

	$posA=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	$posB=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;

	if (abs($posA[0]-$posB[0])<$tol && abs($posA[1]-$posB[1])<$tol && abs($posA[2]-$posB[2])<$tol)
		continue;

	$numVtxMoved++;

	//inverseMatrix
	float $nonDefPos[]=`xform -q -ws -t ($preDeformMesh+".vtx["+$i+"]")`;
	float $defPos[]=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	float $corPos[]=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;
	xform -ws -t $nonDefPos[0] $nonDefPos[1] $nonDefPos[2] invMReaderOffset;

	xform -ws -t $defPos[0] $defPos[1] $defPos[2] defOffset;
	xform -ws -t $corPos[0] $corPos[1] $corPos[2] corPos;

	$xPoint=`xform -q -ws -t ("xOffsetts.vtx["+$i+"]")`;
	$yPoint=`xform -q -ws -t ("yOffsetts.vtx["+$i+"]")`;
	$zPoint=`xform -q -ws -t ("zOffsetts.vtx["+$i+"]")`;

	setAttr -type "matrix" invMReaderOffset.theMatrix 
	($xPoint[0]-$defPos[0]) ($xPoint[1]-$defPos[1]) ($xPoint[2]-$defPos[2]) 0
	($yPoint[0]-$defPos[0]) ($yPoint[1]-$defPos[1]) ($yPoint[2]-$defPos[2]) 0
	($zPoint[0]-$defPos[0]) ($zPoint[1]-$defPos[1]) ($zPoint[2]-$defPos[2]) 0
	0 0 0 1;

	$newPos=`xform -q -ws -t invMNewPos`;
	xform -ws -t $newPos[0] $newPos[1] $newPos[2] ($deltaShape+".vtx["+$i+"]");
	}
progressBar -e -ep $gMainProgressBar;
//setAttr ($deformObj+"Corrective.envelope") 1;
delete correctiveMatrixUtilities;
xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
print ("//Calculated "+$numVtxMoved+" vtx for deltashape\n");

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
eval($restorePoseCmd);
dgdirty -a;

if($doMirror && !$deleteMode)
	{
	createNode -n ($deltaShape+"MirrorGroup") transform;
	parent $deltaShape ($deltaShape+"MirrorGroup");
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	duplicate -n ($mirrorDeltaShape+"Default") $mirrorDeltaShape;
	select ($mirrorDeltaShape+"Default") $deltaShape;
	blendShape -n tempMirrorCorrectiveBS -frontOfChain;
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 1;
	select $mirrorDeltaShape $deltaShape;
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "0", "0" };
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 0;
	DeleteHistory $mirrorDeltaShape;
	delete ($mirrorDeltaShape+"Default");
	select $mirrorDeltaShape $deformObj;
	asCorrectiveConnectBS;
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	}
if ($deleteMode)
	{
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	print ("deleting "+$deltaShape+", (inbetweenValue="+$iv+", value="+$dv+")\n");
	blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
	selectKey -add -k -f $dv $sdk;
	cutKey -animation keys -clear;
	}
delete $deltaShape;
delete $sel[0];
if($doMirror && !$deleteMode)
	delete $mirrorDeltaShape ($deltaShape+"MirrorGroup");
if ($deleteMode)
	delete DeleteCorrectiveShape;
string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if ($iv<1)
	;//print ("Inbetweener..skipping SDK..\n");
if ($iv==1) //SDK for inbetweens not done here
	if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
		{
		if (`objExists $sdk`) if (size($keyXValues)<2) delete $sdk;
		setDrivenKeyframe -v 0 -dv $zv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		setDrivenKeyframe -v 1 -dv $dv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		if($doMirror && !$deleteMode)
			{
			if (`objExists $mirrorSdk`) {float $mirrorKeyValues[]=`keyframe -q -fc $mirrorSdk`;if (size($mirrorKeyValues)<2) delete $mirrorSdk;}
			setDrivenKeyframe -v 0 -dv $mirrorZv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			setDrivenKeyframe -v 1 -dv $mirrorDv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			}
		}

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;

setAttr "Group.v" 1;
asExitCorrectiveShapeMode;
autoKeyframe -state $autoKeyframe;
select $deformObj;
setToolTo $gSelect;
}

global proc asCancelCorrectiveShape ()
{
global string $gSelect;
string $tempString[];
string $rootLevelObjects[]=`ls -as -type transform`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		{
		delete $rootLevelObjects[$i];
		tokenize $rootLevelObjects[$i] "_" $tempString;
		if (`objExists $tempString[0]`)
			select $tempString[0];
		}
if (`objExists "Group"`)
	setAttr "Group.v" 1;
asExitCorrectiveShapeMode;
setToolTo $gSelect;
}

global proc asExitCorrectiveShapeMode ()
{
//setAttr "Group.v" 1; crashes maya :(
button -e -en 0 asCancelCorrectiveShapeButton;
button -e -en 0 asConnectCorrectiveShapeButton;
button -e -en 1 asCreateCorrectiveButton;
button -e -en 1 asReCreateCorrectiveButton;
button -e -en 1 asDeleteCorrectiveButton;
button -e -en 1 asGraphCorrectiveButton;

if (`attributeExists "correctiveShapeModeHidden" "Group"`)
	setAttr (`getAttr "Group.correctiveShapeModeHidden"`+".v") 1;
if (`headsUpDisplay -q -ex HUDCSMMode`)
	headsUpDisplay -rem HUDCSMMode;
}

global proc asCorrectiveConnectBS ()
{
int $numLetters;
string $sel[]=`ls -sl`;
string $deltaShape=$sel[0];
string $deformObj=$sel[1];
string $tempString[];
tokenize `substituteAllString $deltaShape "__"  "|"` "|" $tempString;
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $posNeg="pos";
if (`getAttr ($deltaShape+".driverValue")`<0)
	$posNeg="neg";
float $iv=`getAttr ($deltaShape+".inbetweenValue")`;
int $existingTargetNr=-1;
if (`objExists ($deformObj+"Corrective")`) //BSnode Exists (Adding Target to BS node)
	{
	int $inputTargetGroups[]=`getAttr -mi ($deformObj+"Corrective.inputTarget[0].inputTargetGroup")`;
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	for ($i=0;$i<size($existingTargets);$i++)
		{
		if ($existingTargets[$i]==$deltaShape)
			$existingTargetNr=$i;
		}
	if ($existingTargetNr!=-1 && $iv==1) // BSnode and BStarget Exists (Replacing target)
		{
		print ("// Replacing BlendShape Target\n");
		connectAttr -f ($deltaShape+".worldMesh[0]") ($deformObj+"Corrective.inputTarget[0].inputTargetGroup["+$inputTargetGroups[$existingTargetNr]+"].inputTargetItem[6000].inputGeomTarget");
		}
	else if ($iv<1 || $iv>1) // BSnode and `similar` target Exists (This must be a inbetween target)
		{
		print ("// connecting inbeween shape at: "+$iv+" for targetNr: "+$existingTargetNr+"\n");
		blendShape -e -inBetween -t $deformObj $inputTargetGroups[$existingTargetNr] $deltaShape $iv ($deformObj+"Corrective");
		//add a key, so this inbeween can be extracted
		setDrivenKeyframe -v $iv -dv `getAttr ($deltaShape+".driverValue")` -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg);
		}
	else
		{
		print ("// Creating New BlendShape\n");
		blendShape -e -t $deformObj `size($existingTargets)` $deltaShape 1 ($deformObj+"Corrective");
		}
	}
else
	{
	blendShape -n ($deformObj+"Corrective") -frontOfChain;
//	$tempString=`listConnections ($deformObj+"Corrective.outputGeometry[0]")`;
//	rename $tempString[0] ($deformObj+"PB");
	}
}

global proc asPopulateCorrectivePopupMenu (string $action)
{
string $popupMenu="as"+$action+"CorrectiveShapesPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
string $correctiveBS[]=`ls -r 1 -type blendShape "*Corrective"`;
int $menuExisted,$en;
float $keyXValues[],$keyYValues[];
string $label;
string $weights[],$tempString[],$menu2s[],$menu3s[],$menu4s[];
for ($i=0;$i<size($correctiveBS);$i++)
	{
	string $deformObj=`substitute "Corrective" $correctiveBS[$i] ""`;
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph")
		$sm=0;
	$lev1Menu=`menuItem -sm $sm -l $deformObj`;
	if ($action=="Graph")
		{
		menuItem -e -c ("select "+$correctiveBS[$i]+";GraphEditor;") $lev1Menu;
		continue;
		}
	$weights=`listAttr -m ($correctiveBS[$i]+".w")`;
	$weights=`sort $weights`;
	for ($y=0;$y<size($weights);$y++)
		{
		tokenize `substituteAllString $weights[$y] "__"  "|"` "|" $tempString;
		string $driverObj=$tempString[0];
		string $driverAttr=$tempString[1];
		string $posNeg=$tempString[2];
		setParent -menu $lev1Menu;

		//$menu2s
		$menu="asCorrectiveMenu_"+$action+$driverObj;
		if(`stringArrayCount $menu $menu2s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $driverObj $menu;
			$menu2s[size($menu2s)]=$menu;
			}

		//$menu3s
		$menu="asCorrectiveMenu_"+$action+$driverObj+"_"+$driverAttr;
		if(`stringArrayCount $menu $menu3s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $driverAttr $menu;
			$menu3s[size($menu3s)]=$menu;
			}

		//$menu4s
		$menu="asCorrectiveMenu_"+$action+$driverObj+"_"+$driverAttr+"_"+$posNeg;
		if(`stringArrayCount $menu $menu4s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $posNeg $menu;
			$menu4s[size($menu4s)]=$menu;
			}
		$sdk=`listConnections ($correctiveBS[$i]+"."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
		$keyXValues=`keyframe -q -fc $sdk`;
		$keyYValues=`keyframe -q -vc $sdk`;
		$haveKeyAtOne=0;
		for ($z=0;$z<size($keyYValues);$z++)
			if ($keyYValues[$z]==1)
				$haveKeyAtOne=1;
		if (!$haveKeyAtOne)
			warning "Found No keys at with \"Y\" value of 1, Unable to determine which shape is not a inbetween";
		float $smallestKeyXValue=99;
		for ($z=0;$z<size($keyXValues);$z++)
			if (abs($keyXValues[$z])<$smallestKeyXValue)
				$smallestKeyXValue=abs($keyXValues[$z]);
		for ($z=0;$z<size($keyXValues);$z++)
			{
			if (($keyXValues[$z]>=0 && $keyXValues[$z]==$smallestKeyXValue) || ($keyXValues[$z]<0 && $keyXValues[$z]==-1*$smallestKeyXValue))
				continue;
			setParent -menu $menu;
			float $roundFactor;
			if ($keyXValues[$z]>0) $roundFactor=0.5;
			else $roundFactor=-0.5;
			$keyXValues[$z]=(trunc($keyXValues[$z]*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
			$cmd="";
			if ($action=="Delete")
				$cmd="createNode -n DeleteCorrectiveShape transform;";
			if ($action=="ReCreate" || $action=="Delete")
				$cmd+="asReCreateCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" \""+$keyXValues[$z]+"\" ";
			if ($action=="Delete")
				$cmd+=";asConnectCorrectiveShape;";
			$en=1;
			$label=$keyXValues[$z];
			if ($action=="Delete")
				if ($keyYValues[$z]==1 && size($keyXValues)>2)
//				if (($keyXValues[$z]>0 && size($keyXValues)>2 && $z==size($keyXValues)-1)
//				 || ($keyXValues[$z]<0 && size($keyXValues)>2 && $z==0))
					$en=0;
//			if (($keyXValues[$z]>0 && $z<size($keyXValues)-1) || ($keyXValues[$z]<0 && $z>0))
			if ($keyYValues[$z]!=1)
				$label+=" (inbtw)";
			menuItem -en $en -l $label -c $cmd;
			}
		}
	}
}

global proc float asSetRotationFromAngle (string $driverObj, string $driverAttr, float $dv)
{
string $XYZ=`substitute "angle" $driverAttr ""`;
float $a=1-`abs($dv)`;
float $c=0.707;
float $b=0.707;
float $rads = ((`pow $b 2`) + (`pow $c 2`) - (`pow $a 2`)) /( 2*$b*$c);
float $deg=90-`acosd($rads)`;
if ($dv<0)
	$deg*=-1;
setAttr ("FK"+$driverObj+".rotate"+$XYZ) $deg;
return $deg;
}

global proc asReCreateCorrectiveShape (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $idv;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
//string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;
if (!`getAttr -settable ($driverObj+"."+$driverAttr)`)//blended (including blended angles
	{
	asSetBlendedAttribute $driverObj $driverAttr $dv 0;
	if (`gmatch $driverAttr "angle*"`)//single angles (not blended angles)
		$idv=`asSetRotationFromAngle $driverObj $driverAttr $dv`;
	}
else
	setAttr ($FKDriverObj+"."+$driverAttr) $dv;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr;
float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
		
if (`objExists $attrCode`)
	warning ("Object "+$attrCode+" already exists");
else
	{
	asCorrectiveDuplicate $attrCode $deformObj;
	addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
	addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;
	}
//asGoToBuildPose bodySetup;
//eval($restorePoseCmd);
autoKeyframe -state $autoKeyframe;
dgdirty -a;
}

global proc string asGetRestorePoseCmd ()
{
string $restorePoseCmd;
string $controlSetMembers[]=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	string $faceControlSetMembers[]=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $faceControlSetMembers`;
	}
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	string $attrs[]=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		$restorePoseCmd+="setAttr "+$controlSetMembers[$i]+"."+$attrs[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$attrs[$y])`+";";
	}

return $restorePoseCmd;
}

/*
global proc string asCorrectiveFloatToString (float $value)
{
string $valueString=`abs($value)`;
string $tempString[];
tokenize $valueString "." $tempString;
if (size($tempString[1])==0) $tempString[1]="000";
if (size($tempString[1])==1) $tempString[1]=$tempString[1]+"00";
if (size($tempString[1])==2) $tempString[1]=$tempString[1]+"0";
if (size($tempString[1])>3)
    $tempString[1]=`substring $tempString[1] 1 3`;
$minusPrefix="";
if ($value<0)
	$minusSuffix="_";
string $return=$tempString[0]+"_"+$tempString[1]+$minusSuffix;
return $return;
}
*/

/*
global proc string asGetBsTargetNameWithClosestValue (string $driverValue, string $weights[])
{
string $bsTargetName;
string $tempString[];
string $driverValueWithDot=`substitute "_" $driverValue "."`;
float $newDv=`substitute "_" $driverValueWithDot ""`;//removes _ suffix which indicates negative value
if (`gmatch $driverValue "*_"`)
	$newDv*=-1;
float $usingShapeFromValue;
float $diff=99999;
for ($i=0;$i<size($weights);$i++)
	{
	tokenize `substituteAllString $weights[$i] "__"  "|"` "|" $tempString;
	string $driverObj=$tempString[0];
	string $driverAttr=$tempString[1];
	string $driverValue=$tempString[2];
	string $driverValueWithDot=`substitute "_" $driverValue "."`;
	float $dv=`substitute "_" $driverValueWithDot ""`;//removes _ suffix which indicates negative value
	if (`gmatch $driverValue "*_"`)
		$dv*=-1;
	if ($newDv-$dv<$diff)
		{
		$usingShapeFromValue=$dv;
		$diff=$newDv-$dv;
		$bsTargetName=$driverObj+"__"+$driverAttr+"__"+$driverValue;
		}
	}
print ("// Shape driver value previously was:"+$usingShapeFromValue+", now using value:"+$newDv+"\n");
return $bsTargetName;
}
*/

global proc float asGetVersionFromHeader ()
{
float $version;
float $decimals;
string $versionString;
string $tempString[];
string $asScriptLocation=`asScriptLocation`;
string $file=$asScriptLocation+"/advancedSkeleton.mel";
int $lineNr;
if (`file -q -ex $file`)
	{
	int $fileId=`fopen $file "r"`;
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$lineNr++;
		$nextLine = `fgetline $fileId`;
		if (`gmatch $nextLine "*Version*"`)
			{
			tokenize $nextLine $tempString;
			tokenize $tempString[2] "[.]" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				$versionString+=$tempString[$i];
				if ($i==0)
					$versionString+=".";
				}
			$version=$versionString;
			}
		if($lineNr>10)
			break;
		}
	}
else
	warning "Unable to determine AdvancedSkeleton version number";
return $version;
}

global proc packUpBetaVersion ()
{
string $intallerPath="F:/temp/scriptsWIP/AS/Installer/";
string $installers[]=`getFileList -fld $intallerPath -fs "AdvancedSkeleton_*"`;
$installers=`sort $installers`;
string $latestInstaller=$installers[size($installers)-1];
float $lastReleaseTime=`getLastModifiedTime ($intallerPath+$latestInstaller)`;
packUpBetaFolder "" $latestInstaller;
}

global proc packUpBetaFolder (string $subfolder, string $latestInstaller)
{
string $intallerPath="F:/temp/scriptsWIP/AS/Installer/";
string $asScriptLocation=`asScriptLocation`;
string $betaPath="C:/Users/me_2/Google Drive/AdvancedSkeleton/beta/";
string $files[]=`getFileList -fld ($asScriptLocation+$subfolder)`;
$files=`sort $files`;
int $numCopiedFiles;
for ($i=0;$i<size($files);$i++)
    {
    if ($files[$i]==".mayaSwatches" || $files[$i]=="incrementalSave")
        continue;
    if (`filetest -d ($asScriptLocation+$subfolder+$files[$i])`)
        {
        packUpBetaFolder ($files[$i]+"/") $latestInstaller;
        continue;
        }
	$newFile=$asScriptLocation+$subfolder+$files[$i];
	$oldFile=$intallerPath+$latestInstaller+"/zipUp/"+$latestInstaller+"/Manual_Install/maya/2014/scripts/AdvancedSkeleton/"+$subfolder+$files[$i];
    $betaFile=$betaPath+$subfolder+$files[$i];
    float $newFileTime=`getLastModifiedTime $newFile`;
    float $oldFileTime=`getLastModifiedTime $oldFile`;
    float $betaFileTime=`getLastModifiedTime $betaFile`;

    if ($betaFileTime>=$newFileTime)
        continue;
    if ($newFileTime>$oldFileTime)
        {
        if (!`file -q -ex ($betaPath+$subfolder)`)
            sysFile -md ($betaPath+$subfolder);
        sysFile -cp $betaFile $newFile;
        $numCopiedFiles++;
        }
    }
if ($numCopiedFiles)
    print ("Copied "+$numCopiedFiles+" files (in AdvancedSkeleton/"+$subfolder+")\n");
}

global proc asCreateSubWrapExclusionBox ()
{
float $charHeight=`asgetCharHeight`;
for ($i=1;$i<99;$i++)
	if (!`objExists ("subWrapExlude"+$i)`)
		break;
string $box="subWrapExlude"+$i;
float $pos[];
if (`objExists Head`)
	$pos=`xform -q -ws -t Head`;
else
	$pos[1]=$charHeight;
polyCube -n $box -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
xform -ws -t 0 $pos[1] 0 $box;
parent $box Cages;
}

global proc asUpdateSubWrapExclusionBoxs ()
{
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
evalDeferred "progressBar -e -ep $gMainProgressBar";
int $numVtxs[];
float $mag;
float $temp[3],$bbMin[3],$bbMax[3];
string $msh,$skinCluster,$skinClusterSet;
string $boxes[]=`ls -type transform "subWrapExlude*"`;
string $subWraps[]=`ls -type wrap "subWrap*"`;
string $tempString[];
if (`objExists closestSampler`)
	delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
if (`objExists tempBox`)
	delete tempBox;
polyCube -n tempBox -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
createNode -n polySmoothProxyTempBox polySmoothProxy;
setAttr polySmoothProxyTempBox.exponentialLevel 3;
setAttr polySmoothProxyTempBox.continuity 0;
select -cl;
for ($z=0;$z<size($boxes);$z++)
	{
	if ($z>0)
		select -cl;
	makeIdentity -a 1 -t 1 -r 1 -s 1 $boxes[$z];
	$bbMin=`getAttr ($boxes[$z]+".boundingBox.boundingBoxMin")`;
	$bbMax=`getAttr ($boxes[$z]+".boundingBox.boundingBoxMax")`;
	connectAttr -f ($boxes[$z]+".outMesh") polySmoothProxyTempBox.inputPolymesh;
	connectAttr -f polySmoothProxyTempBox.output closestSampler.inMesh;
	for ($i=0;$i<size($subWraps);$i++)
		{
		$tempString=`listHistory -f 1 ($subWraps[$i]+".outputGeometry")`;
		for ($y=0;$y<size($tempString);$y++)
			if (`objectType $tempString[$y]`=="mesh")
				{
				$tempString2=`listRelatives -p $tempString[$y]`;
				$msh=$tempString2[0];
				}
		$numVtxs=`polyEvaluate -v $msh`;
		progressBar -e -st "Updating SubWrapExclusionBoxes" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
		for ($y=0;$y<$numVtxs[0];$y++)
			{
			if (`progressBar -q -ic $gMainProgressBar`)
				{warning "Aborted";if (`objExists tempBox`)delete tempBox;progressBar -e -ep $gMainProgressBar;break;}
			progressBar -e -s 1 $gMainProgressBar;
			$temp=`xform -q -ws -t ($msh+".vtx["+$y+"]")`;
			vector $pos=<<$temp[0],$temp[1],$temp[2]>>;
			//first do BoundingBox check, as this is faster
			if ($temp[0]<$bbMin[0] || $temp[0]>$bbMax[0] || $temp[1]<$bbMin[1] || $temp[1]>$bbMax[1] || $temp[2]<$bbMin[2] || $temp[2]>$bbMax[2])
				continue;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$temp=`getAttr closestSampler.position`;
			vector $closePoint=<<$temp[0],$temp[1],$temp[2]>>;
			$temp=`getAttr closestSampler.normal`;
			vector $closeNormal=<<$temp[0],$temp[1],$temp[2]>>;
			vector $dif=$closePoint-$pos;
			$mag=dot($dif,$closeNormal);
			if ($mag>=0)
				select -add ($msh+".vtx["+$y+"]");
			}
		$skinCluster="";
		$tempString=`listHistory -pdo 1 $msh`;
		for ($y=0;$y<size($tempString);$y++)
			if (`nodeType $tempString[$y]` == "skinCluster")
				$skinCluster=$tempString[$y];
		if ($skinCluster=="")
			asCopySkin;
		$tempString=`listHistory -pdo 1 $msh`;
		for ($y=0;$y<size($tempString);$y++)
			if (`nodeType $tempString[$y]` == "skinCluster")
				$skinCluster=$tempString[$y];
		$tempString=`listConnections ($subWraps[$i]+".message")`;
		string $wrapSet=$tempString[0];
		$tempString=`listConnections ($skinCluster+".message")`;
		$skinClusterSet=$tempString[0];
		sets -rm $wrapSet;
		InvertSelection;
		sets -rm $skinClusterSet;
		InvertSelection;
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempBox`)
	delete tempBox;
print ("// ExclutionBox Update complete\n");
}

global proc asWrapExlude ()
{
asWarningIfNotInBuildPose;
string $sel[]=`ls -sl`;
if (!size($sel))
	error "No vertices selected ";
if (!`gmatch $sel[0] "*[.]vtx[[]*"`)
	error "Selection must be  vertices";
string $tempString[]=`listHistory -pdo 1 $sel[0]`;
string $wrapDeformer,$skinCluster;
int $hadSkinCluster=0;
for ($y=0;$y<size($tempString);$y++)
	{
	if (`nodeType $tempString[$y]` == "wrap")
		$wrapDeformer=$tempString[$y];
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
	}
if ($wrapDeformer=="")
	error "No wrap deformer on selected object";

if ($skinCluster=="")
	{
	asCopySkin;
	$tempString=`ls -sl -o`;
	$tempString=`listRelatives -p $tempString[0]`;
	select $tempString[0];
	asSmoothSkin;
	select $sel;
	}
else
	$hadSkinCluster=1;
string $tempString[]=`listHistory -pdo 1 $sel[0]`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
$tempString=`listConnections ($wrapDeformer+".message")`;
string $wrapSet=$tempString[0];
$tempString=`listConnections ($skinCluster+".message")`;
string $skinClusterSet=$tempString[0];
sets -rm $wrapSet;
InvertSelection;
sets -rm $skinClusterSet;
if (!$hadSkinCluster)
	{
	$tempString=`ls -sl -o`;
	select $tempString[0];
	removeUnusedInfluences;
	}
select $sel;
print ("// Selected vertices are now deformed by "+$skinCluster+" instead of wrapDeformer\n");
}

global proc asCreateSkinSub ()
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "\"skinCage\" not found, You must create a skinCage first.";
if (`objExists skinSub`)
	error "\"skinSub\" already exists.";
if (!`objExists Cages`)
	{
	createNode -n Cages transform;
	parent Cages "Geometry";
	}

createNode -n subWrapPolySmoothProxy polySmoothProxy;
polyCube -n skinSub  -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
parent skinSub Cages;
connectAttr skinCageShape.outMesh subWrapPolySmoothProxy.inputPolymesh;
connectAttr subWrapPolySmoothProxy.output skinSub.inMesh;
select skinSub;
createDisplayLayer -name SkinSub -number 1 -nr;
setAttr SkinSub.shading 0;
setAttr SkinSub.displayType 2;
setAttr SkinCage.displayType 1;
select $sel;
}

global proc asDeleteSkinSub ()
{
if (`objExists skinSub`)
	delete skinSub;
if (`objExists SkinSub`)
	delete SkinSub;
}

global proc asWrapSkin ()
{
asWarningIfNotInBuildPose;
string $sel[]=`ls -sl`;
if (!`objExists skinSub`)
	error "\"skinSub\" not found, you must create SubWrap first";
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	{
	string $historyNodes[]=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]` == "wrap")
			error ($sel[$i]+" already have wrapDeformer");
	}

if (!`attributeExists wrapDeform Main`)
	{
	addAttr -k 1 -ln "wrapDeform" -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.wrapDeform;
	}
if (!`objExists wrapDeformReverse`)
	{
	createNode -n wrapDeformReverse reverse;
	connectAttr Main.wrapDeform wrapDeformReverse.inputX;
	}
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	select -add skinSub ;
	CreateWrap;
	}
string $wraps[]=`listConnections -type wrap skinSub.worldMesh`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
float $wrapValues[]={0,0,1,0,0};
string $wrap;

for ($i=0;$i<size($wraps);$i++)
	{
	$wrap=`rename $wraps[$i] ("subWrap"+($i+1))`;
	$tempString=`listConnections ($wrap+".outputGeometry")`;
	setAttr ($wrap+".nodeState") 1;
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (`attributeExists $wrapAttrs[$y] $tempString[0]`) //We could be reattaching, so reuse wrapInfo
			$wrapValues[$y]=`getAttr ($tempString[0]+"."+$wrapAttrs[$y])`;
		setAttr ($wrap+"."+$wrapAttrs[$y]) $wrapValues[$y];
		}
	setAttr skinSub.dropoff 4;
	setAttr skinSub.smoothness 0;
	setAttr skinSub.inflType 2;
	connectAttr wrapDeformReverse.output.outputX ($wrap+".nodeState");
	}
select -cl;
}

global proc asSkinSubAttach ()
{
asWarningIfNotInBuildPose;
if (!`objExists skinSub`) error "\"skinSub\" not found, you must create SubWrap first";
if (!`objExists skinCage`) error "\"skinCage\" not found, you must create SubWrap first";
if (!`attributeExists subWrapped skinCage`) error "No SubWraps have been detached";
int $numAttach;
string $msh;
string $tempString[];
$tempString[0]=`getAttr skinCage.subWrapped`;
tokenize $tempString[0] ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	$msh=$tempString[$i];
	if (!`objExists $msh`)
		continue;
	select $msh;
	asWrapSkin;
	$numAttach++;
	}
print ("//"+$numAttach+" SubWrap(s) attached");
}

global proc asSkinSubDetach ()
{
asWarningIfNotInBuildPose;
string $subWraps[]=`ls -type wrap "subWrap*"`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
string $tempString[],$tempString2[];
string $msh,$subWrappedString;
for ($i=0;$i<size($subWraps);$i++)
	{
	//store wrapInfo on the meshes they deform.
	$tempString=`listHistory -f 1 ($subWraps[$i]+".outputGeometry")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="mesh")
			{
			$tempString2=`listRelatives -p $tempString[$y]`;
			$msh=$tempString2[0];
			}
	$subWrappedString+=$msh+";";
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (!`attributeExists $wrapAttrs[$y] $msh`) addAttr -ln $wrapAttrs[$y] -at double $msh;
		setAttr ($msh+"."+$wrapAttrs[$y]) `getAttr ($subWraps[$i]+"."+$wrapAttrs[$y])`;
		}
	delete $subWraps;
	print ("//"+`size($subWraps)`+" SubWrap(s) detached");
	}
if (!`attributeExists subWrapped skinCage`)
	addAttr -ln "subWrapped" -dt "string" skinCage;
setAttr -type "string" skinCage.subWrapped $subWrappedString;
}

global proc asCreateSkeleton ()
{
asWarningIfNotInBuildPose;
asSetRefreshOptionVar;

if (`objExists "Skeleton"`)
	delete Skeleton;
createNode -n "Skeleton" transform;
parent "Skeleton" "Geometry";

float $charHeight=`asgetCharHeight`;

string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];
string $poly;
float $temp[],$temp2[];
int $sideFactor;
vector $childVec;
string $boneSkipJoints[]={"Back?_*","Root_M","Chest_M","Jaw_M","Head_*","Eye_*","*Hip_*","Neck_*",
	"*Elbow_*","*Finger[0-9]_*","*Wrist*","*Cup*","*Ankle*","*Toe*"};
string $asScriptLocation=`asScriptLocation`;
file -i ($asScriptLocation+"asGeometry.ma");

setAttr -type float3 "Skeleton_Geometry.s" ($charHeight/8) ($charHeight/8) ($charHeight/8);

if (`objExists Root_M`)
	{
	delete `pointConstraint Root_M Skeleton_Pelvis`;
	if (`objExists BackA_M`)
		delete `orientConstraint BackA_M Skeleton_Pelvis`;
	parent Skeleton_Pelvis Skeleton;
	parentConstraint -mo Root_M Skeleton_Pelvis;
	makeIdentity -a 1 -t 0 -r 0 -s 1 Skeleton_Pelvis;;
	scaleConstraint Root_M Skeleton_Pelvis;
	}
if (`objExists Head_M`)
	{
	parent Skeleton_Skull Skeleton;
	parentConstraint Head_M Skeleton_Skull;
	makeIdentity -a 1 -t 0 -r 0 -s 1 Skeleton_Skull;
	scaleConstraint Head_M Skeleton_Skull;
	}
if (`objExists Jaw_M`)
	{
	parent Skeleton_Jaw Skeleton;
	delete `parentConstraint Head_M Skeleton_Jaw`;
	parentConstraint -mo Jaw_M Skeleton_Jaw;
	makeIdentity -a 1 -t 0 -r 0 -s 1 Skeleton_Jaw;
	scaleConstraint Jaw_M Skeleton_Jaw;;
	}

for ($i=0;$i<size($deformJointsList);$i++)
	{
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	if (!size($children))
		continue;
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	$childJoint=$children[0];
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$children=`listRelatives -c -type joint $childJoint`;
		$childJoint=$children[0];
		}

	$temp=`xform -q -ws -t $deformJointsList[$i]`;
	$temp2=`xform -q -ws -t $childJoint`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
//	$lenght = $lenght*-1;

	if (`gmatch $deformJointsList[$i] "*Hip_*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Femur`;
		$poly=$tempString[0];
		parent $poly Skeleton;
		setAttr ($poly+".sx") $lenght;
		parentConstraint $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
		makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	if (`gmatch $deformJointsList[$i] "*Elbow_*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Forearm`;
		$poly=$tempString[0];
		parent $poly Skeleton;
		setAttr ($poly+".sx") $lenght;
		parentConstraint $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
		makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	if (`gmatch $deformJointsList[$i] "*Finger[0-9]_*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Digit`;
		$poly=$tempString[0];
		parent $poly Skeleton;
		setAttr ($poly+".sx") $lenght;
		parentConstraint $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
		makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	if (`gmatch $deformJointsList[$i] "*Ankle_*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Ankle`;
		$poly=$tempString[0];
		parent $poly Skeleton;
		$temp=`xform -q -ws -t $deformJointsList[$i]`;
		$temp2=`xform -q -ws -t $childJoint`;
		setAttr ($poly+".sx") $temp[1];
		setAttr ($poly+".sy") (($temp2[2]-$temp[2])*1.6);
		delete `parentConstraint $deformJointsList[$i] $poly`;
		setAttr ($poly+".ty") 0;
		parentConstraint -mo $deformJointsList[$i] $poly;
		
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
		makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	if (`gmatch $deformJointsList[$i] "*Toe*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_MiddleToe`;
		$poly=$tempString[0];
		parent $poly Skeleton;
		$tempString=`listRelatives -p -type joint $deformJointsList[$i]`;
		$temp=`xform -q -ws -t $tempString[0]`;
		setAttr ($poly+".sx") $temp[1];
		delete `parentConstraint $tempString[0] $poly`;
		setAttr ($poly+".ty") 0;
		parentConstraint -mo $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
		makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
		scaleConstraint $deformJointsList[$i] $poly;
		}

	if (`gmatch $deformJointsList[$i] "*Wrist*"`)
		{
		$children=`listRelatives -c -type joint $deformJointsList[$i]`;
		if (`stringArrayCount "Cup_R" $children`)
			{
			$tempString=`listRelatives -c -type joint Cup_R`;
			$children=`stringArrayCatenate $children $tempString`;
			}
		if (`stringArrayCount "Cup_L" $children`)
			{
			$tempString=`listRelatives -c -type joint Cup_L`;
			$children=`stringArrayCatenate $children $tempString`;
			}
		for ($y=0;$y<size($children);$y++)
			{
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone"+$y) Skeleton_Digit`;
			$poly=$tempString[0];
			parent $poly Skeleton;
			pointConstraint $deformJointsList[$i] $poly;
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $deformJointsList[$i] $children[$y] $poly;
			$temp=`xform -q -ws -t $deformJointsList[$i]`;
			$temp2=`xform -q -ws -t $children[$y]`;
			$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
			setAttr ($poly+".sx") ($lenght*1);
			makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
			scaleConstraint $deformJointsList[$i] $poly;
			}
		}
	int $skipMe=0;
	for ($y=0;$y<size($boneSkipJoints);$y++)
		if (`gmatch $deformJointsList[$i] $boneSkipJoints[$y]`)
			$skipMe=1;
	if (!$skipMe)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Bone") Skeleton_Bone`;
		$poly=$tempString[0];
		parent $poly Skeleton;
		setAttr ($poly+".sx") $lenght;
		parentConstraint $deformJointsList[$i] $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`&& `objExists ($deformJointsList[$i]+"_Bone")`)
			scale -r -1 -1 -1 ($deformJointsList[$i]+"_Bone");
		makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
		scaleConstraint $deformJointsList[$i] $poly;
		}



	}

//Spine
int $foundHeadToRoot=1;
string $parent="Head_M";
string $parents[];
string $headToRoots[]={$parent};
if (`objExists Head_M`)
	for ($i=0;$i<99;$i++)
		{
		$parents=`listRelatives -parent -type joint $parent`;
		if(size($parents)==0)
			break;
		$parent=$parents[0];
		$headToRoots[size($headToRoots)]=$parent;
		if ($parent=="Root_M")
			{
			$foundHeadToRoot=1;
			break;
			}
		}
//Neck
int $foundHeadToChest=1;
string $parent="Head_M";
string $parents[];
string $headToChests[]={$parent};
if (`objExists Head_M` && `objExists Chest_M`)
	for ($i=0;$i<99;$i++)
		{
		$parents=`listRelatives -parent -type joint $parent`;
		if(size($parents)==0)
			break;
		$parent=$parents[0];
		$headToChests[size($headToChests)]=$parent;
		if ($parent=="Chest_M")
			{
			$foundHeadToChest=1;
			break;
			}
		}

if (`objExists Root_M` && `objExists Neck_M` && `objExists Head_M` && $foundHeadToRoot)
	{
	parent Skeleton_Spine Skeleton;
	delete `pointConstraint Root_M Skeleton_Spine`;
	if(`objExists BackA_M`)
		delete `orientConstraint BackA_M Skeleton_Spine`;
	$temp=`xform -q -ws -t Root_M`;
	$temp2=`xform -q -ws -t Neck_M`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
	setAttr Skeleton_Spine.sx $lenght;
	select $headToRoots;
	select -add Skeleton_Spine;
	newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	}
if (`objExists Neck_M` && `objExists Head_M` && $foundHeadToChest)
	{
	parent Skeleton_Neck Skeleton;
	delete `parentConstraint Neck_M Skeleton_Neck`;
	$temp=`xform -q -ws -t Neck_M`;
	$temp2=`xform -q -ws -t Head_M`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
	setAttr Skeleton_Neck.sx ($lenght*1.1);
	select $headToChests;
	select -add Skeleton_Neck;
	newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	}
if (`objExists Root_M` && `objExists Chest_M`)
	{
	parent Skeleton_Ribs Skeleton;
	$temp=`xform -q -ws -t Root_M`;
	$temp2=`xform -q -ws -t Chest_M`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;
	setAttr Skeleton_Ribs.sx $lenght;
	//hacky way to see if it`s a quadped, in which case cons to parent of "Chest_M"
	$temp=`xform -q -ws -ro Chest_M`;
	$tempString=`listRelatives -type joint -p Chest_M`;
	if ($temp[1]<-45)
		parentConstraint $tempString[0] Skeleton_Ribs;
	else
		parentConstraint Chest_M Skeleton_Ribs;
	makeIdentity -a 1 -t 0 -r 0 -s 1 Skeleton_Ribs;
	scaleConstraint Chest_M Skeleton_Ribs;
	}


if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;

print ("Skeleton created\n");
select -cl;
}

global proc asWarpMannequin ()
{
string $sel[]=`ls -sl`;
string $bits[]=`listRelatives -type transform -c Mannequin`;
for ($i=0;$i<size($bits);$i++)
	{
	select $sel;
	select -add $bits[$i];
	transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;
	select $bits[$i];
	DeleteHistory;
	}
}

global proc asCreateMannequin ()
{
asWarningIfNotInBuildPose;
asSetRefreshOptionVar;

if (!`objExists "Mannequin"`)
	{
	createNode -n "Mannequin" transform;
	parent "Mannequin" "Geometry";
	}
float $charHeight=`asgetCharHeight`;

string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];
float $temp[],$temp2[],$temp3[];
int $sideFactor;
vector $childVec;
string $skipJoints[]={"Back?_*","Root_M","Chest_M","Jaw_M","Head_*","Eye_*"};
string $asScriptLocation=`asScriptLocation`;
file -i ($asScriptLocation+"asGeometry.ma");
//xform -os -s ($charHeight/9) ($charHeight/9) ($charHeight/9) Mannequin_Geometry;
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (`objExists ($deformJointsList[$i]+"_Ball")`)
		continue;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	if (!size($children))
		continue;
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	int $skipMe=0;

	$childJoint=$children[0];
	if ($deformJointsList[$i]=="Chest_M")
		if (`stringArrayCount "Neck_M" $children`)
			$childJoint="Neck_M";
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$children=`listRelatives -c -type joint $childJoint`;
		$childJoint=$children[0];
		}
	$temp=`xform -q -ws -t $deformJointsList[$i]`;
	$temp2=`xform -q -ws -t $childJoint`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;

	//spine
	if ($deformJointsList[$i]=="Root_M" || `gmatch $deformJointsList[$i] "Back?_*"` || `gmatch $deformJointsList[$i] "Chest*"` || `gmatch $deformJointsList[$i] "Head_*"`)
		{
		if (`gmatch $deformJointsList[$i] "Head_*"`)
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Head`;
		else
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Root`;
		$poly=$tempString[0];
		parentConstraint $deformJointsList[$i] $poly;
		parent $poly "Mannequin";
		xform -os -s ($lenght/1) ($charHeight/10) ($charHeight/10) $poly;
		makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
		scaleConstraint $deformJointsList[$i] $poly;
		}

	

	for ($y=0;$y<size($skipJoints);$y++)
		if (`gmatch $deformJointsList[$i] $skipJoints[$y]`)
			$skipMe=1;
	if ($skipMe) continue;

	if (`gmatch $deformJointsList[$i] "*Ankle*"` || `gmatch $deformJointsList[$i] "MiddleToe*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Foot`;
		$poly=$tempString[0];
		xform -ws -t $temp[0] 0 $temp[2] $poly;
		xform -os -s ($lenght/1) ($lenght/1) ($lenght/1) $poly;
		//take on -ws .ry
		$temp3=`xform -q -ws -ro $deformJointsList[$i]`;
		if (`gmatch $deformJointsList[$i] "*Ankle*"`)
			$temp3=`xform -q -ws -ro $childJoint`;
		xform -ws -ro 0 ($temp3[1]-90) 0 $poly;
		//move forward
		move -r -os -wd 0 0 ($lenght/4.0) $poly;
		parentConstraint -mo $deformJointsList[$i] $poly;
		parent $poly "Mannequin";
		makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	else
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Limb") Mannequin_Limb`;
		$poly=$tempString[0];
		xform -os -s ($lenght) ($lenght/2) ($lenght/2) $poly;
		if (`gmatch $deformJointsList[$i] "Wrist*"`)
			setAttr ($poly+".sz") (`getAttr ($poly+".sz")`*3);
		if (`gmatch $deformJointsList[$i] "*Finger*"`)
			xform -os -s $lenght ($charHeight/70) ($charHeight/70) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($lenght*1.1) ($charHeight/10) ($charHeight/10) $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`)
			setAttr ($poly+".sx") (`getAttr ($poly+".sx")`*-1);
		parentConstraint $deformJointsList[$i] $poly;
		parent $poly "Mannequin";
		makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
		scaleConstraint $deformJointsList[$i] $poly;
		}
	$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Sphere`;
	$poly=$tempString[0];
	xform -os -s ($lenght/2) ($lenght/2) ($lenght/2) $poly;
	if (`gmatch $deformJointsList[$i] "*Finger*"`)
		xform -os -s ($charHeight/50) ($charHeight/50) ($charHeight/50) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "Wrist*"`)
		xform -os -s ($charHeight/20) ($charHeight/20) ($charHeight/20) $poly;
	if (`gmatch $deformJointsList[$i] "Shoulder_*"` || `gmatch $deformJointsList[$i] "Hip_*"`)
		xform -os -s ($charHeight/7) ($charHeight/7) ($charHeight/7) $poly;

	parentConstraint $deformJointsList[$i] $poly;
	parent $poly "Mannequin";
	makeIdentity -a 1 -t 0 -r 0 -s 1 $poly;
	scaleConstraint $deformJointsList[$i] $poly;

	if (`optionVar -q asRefresh`)
		refresh;
	}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;

print ("Mannequin created\n");
select -cl;
}

global proc asDeleteMannequin ()
{
string $deleteObjs[]={"Mannequin_Geometry","Mannequin","woodSG","woodShader"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asDeleteSkeleton ()
{
string $deleteObjs[]={"Skeleton_Geometry","Skeleton"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asBulgeMirror (int $L2R)
{
string $side="_R";
string $oppositeSide="_L";
if ($L2R)
	{
	$side="_L";
	$oppositeSide="_R";
	}
string $trans[]=`listRelatives -type transform -ad FaceGroup`;
string $opposite;
string $userAttrs[];
float $value,$oppositeValue;
for ($i=0;$i<size($trans);$i++)
	{
	if (!`gmatch $trans[$i] ("*"+$side)`)
		continue;
	$opposite=`substitute $side $trans[$i] $oppositeSide`;
	if (!`objExists $opposite`)
		continue;
	$userAttrs=`listAttr -k -ud $trans[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		if (`attributeExists $userAttrs[$y] $opposite`)
			{
			$value=`getAttr ($trans[$i]+"."+$userAttrs[$y])`;
			if ($userAttrs[$y]=="divY")
				$value=$value*-1;
			$oppositeValue=`getAttr ($opposite+"."+$userAttrs[$y])`;
			if ($oppositeValue>($value+0.001) || $oppositeValue<($value-0.001))
				evalEcho ("setAttr "+$opposite+"."+$userAttrs[$y]+" "+$value);
			}
	}
}

global proc string asUniqueName (string $longName)
{
string $uniqueName;
string $tempString[];
int $numTok=`tokenize $longName "|" $tempString`;
string $shortName=$tempString[$numTok-1];
$tempString=`ls $shortName`;
string $tempNode;
if (size($tempString)>1)
	{
	$tempNode=`createNode transform`;
	createNode -n $shortName -p $tempNode transform;
	$uniqueName=`createNode -n $shortName -p $tempNode transform`;
	delete $tempNode;
	rename $longName $uniqueName;
	}
else
	$uniqueName=$shortName;
return $uniqueName;
}

global proc asImportFitSkeleton ()
{
string $asScriptLocation=`asScriptLocation`;
string $file=$asScriptLocation+"/FitSkeletons/"+`optionMenu -q -v asFitOptionMenu`;
if (`file -q -ex $file`)
	file -import -rpr "AdvancedSkeleton" -options "v=0" $file;
}

global proc addFitSkelAttrJoints (string $type)
{
string $sel[]=`ls -sl`;
string $plusMinus,$multDiv,$loc,$locShape;
string $tempString[],$multDivs[],$attrs[];
if (!size($sel))
	warning "Select 1 joint\n";
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -f -c $sel[$i]`;
	$childJoint="";
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="joint")
			$childJoint=$tempString[$y];
	if (`objectType $sel[$i]`!="joint" || $childJoint=="" || !size($tempString))
		continue;
	if (`attributeExists twistJoints $sel[$i]` || `attributeExists bendJoints $sel[$i]`)
		error ("FitSkeleton Attribute already added!\n");
	else
		{
		addAttr -k 1 -ln $type -at long -min 0 -max 10 -dv 2 $sel[$i];
		addAttr -k 1 -ln "bend" -at bool -dv 0 $sel[$i];
		}
	$plusMinus=`createNode -n ($sel[$i]+"_multDiv") plusMinusAverage`;
	connectAttr ($sel[$i]+"."+$type) ($plusMinus+".input1D[0]");
	setAttr ($plusMinus+".input1D[1]") 1;
	$multDiv=`createNode -n ($sel[$i]+"_multDiv") multiplyDivide`;
	setAttr ($multDiv+".operation") 2;
	connectAttr ($childJoint+".translate") ($multDiv+".input1");
	connectAttr ($plusMinus+".output1D") ($multDiv+".input2.input2X");
	connectAttr ($plusMinus+".output1D") ($multDiv+".input2.input2Y");
	connectAttr ($plusMinus+".output1D") ($multDiv+".input2.input2Z");
	for ($y=1;$y<11;$y++)
		{
		$tempString=`spaceLocator`;
		$loc=`rename $tempString[0] ($sel[$i]+"_"+$type+"Locator"+$y)`;
		$tempString=`listRelatives -s $loc`;
		$locShape=$tempString[0];
		$attrs=`listAttr -k $loc`;
		setAttr ($locShape+".overrideEnabled") 1;
		setAttr ($locShape+".overrideColor") 31;
		addAttr -k 0 -dv $y -min 0 -max 10 -ln twistPosition -at double $loc;
		parent $loc $sel[$i];
		xform -os -t 0 0 0 -ro 0 0 0 -s 0.5 0.5 0.5 $loc;
		$multDivs[$y]=`createNode -n ($sel[$i]+"_multDiv"+$y) multiplyDivide`;
		connectAttr ($multDiv+".output") ($multDivs[$y]+".input1");
		connectAttr ($loc+".twistPosition") ($multDivs[$y]+".input2.input2X");
		setAttr ($multDivs[$y]+".input2.input2Y") $y;
		setAttr ($multDivs[$y]+".input2.input2Z") $y;
		connectAttr ($multDivs[$y]+".output") ($loc+".translate");

		$multDivsVis[$y]=`createNode -n ($sel[$i]+"_multDivsVis") multiplyDivide`;
		connectAttr ($sel[$i]+"."+$type) ($multDivsVis[$y]+".input1.input1X");
		setAttr ($multDivsVis[$y]+".input2.input2X") ((1.00/(2*$y))+0.001);
		connectAttr ($multDivsVis[$y]+".outputX") ($loc+".visibility");
		for ($attr in $attrs)
			setAttr -l 1 -k 0 ($loc+"."+$attr);
		}
	}
select $sel;
}

global proc addFitSkelAttr (string $attr)
{
string $sel[]=`ls -sl`;
if (!size($sel))
	warning "Select 1 joint\n";
float $dv=1;
for ($i=0;$i<size($sel);$i++)
	{
	if (`objectType $sel[$i]`!="joint")
		continue;
	if (`attributeExists $attr $sel[$i]`)
		error ("FitSkeleton Attribute already added!\n");
	else
		{
		if($attr=="freeOrient")
			addAttr -k 1 -ln freeOrient -at long -min 1 -max 1 -dv $dv $sel[$i];
		if($attr=="attach")
			{
			if (size($sel)<2)
				error "Select both FitJoint AND Geometry to attach to";
			string $tempString[]=`listRelatives -s $sel[1]`;
			if (`objectType $tempString[0]`!="mesh")
				error "Geometry to attach to must be polygon object";
			addAttr -k 1 -ln "attach" -at "enum" -en `substituteAllString $sel[1] ":" "__"` $sel[$i];
			select $sel[$i];
			}
		}
	}
repeatLast -addCommand ("addFitSkelAttr "+$attr);
}

global proc addFitSkelGlobal ()
{
string $sel[]=`ls -sl`;
string $tempString[];
string $loc,$locShape;
if (!size($sel))
	warning "Select 1 joint\n";
for ($i=0;$i<size($sel);$i++)
	{
	if (`objectType $sel[$i]`!="joint")
		continue;
	if (`attributeExists "global" $sel[$i]`)
		error ("FitSkeleton Attribute already added!\n");
	else
		{
		addAttr -k 1 -ln "global" -at long -min 0 -max 10 -dv 10 $sel[$i];
		addAttr -k 0 -ln "globalConnect" -at long -min 0 -max 10 -dv 10 $sel[$i];
		connectAttr ($sel[$i]+".global") ($sel[$i]+".globalConnect");
		}
	$tempString=`spaceLocator`;
	$loc=`rename $tempString[0] ($sel[$i]+"_globalLocator")`;
	$tempString=`listRelatives -s $loc`;
	$locShape=$tempString[0];
	$attrs=`listAttr -k $loc`;
	setAttr ($locShape+".overrideEnabled") 1;
	setAttr ($locShape+".overrideColor") 6;
	parent $loc $sel[$i];
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $loc;
	for ($attr in $attrs)
		setAttr -l 1 -k 0 ($loc+"."+$attr);
	}
select $sel;
}

global proc removeFitSkelAttr (string $attr)
{
string $sel[]=`ls -sl`;
string $children[];
for ($obj in $sel)
	{
	if (`attributeExists $attr $obj`)
		deleteAttr ($obj+"."+$attr);
	if (`attributeExists "bend" $obj`)
		deleteAttr ($obj+".bend");
	$children=`listRelatives -c $obj`;
	for ($child in $children)
		if (`gmatch $child ("*_"+$attr+"Locator*")`)
			delete $child;

	if (`attributeExists ($attr+"Connect") $obj`)
		deleteAttr ($obj+"."+$attr+"Connect");
	}
}

global proc asLockAttr (string $object, int $trans, int $rot, int $scale, int $vis)
{
setAttr -l $trans -k (!$trans) ($object+".translateX");
setAttr -l $trans -k (!$trans) ($object+".translateY");
setAttr -l $trans -k (!$trans) ($object+".translateZ");
setAttr -l $rot -k (!$rot) ($object+".rotateX");
setAttr -l $rot -k (!$rot) ($object+".rotateY");
setAttr -l $rot -k (!$rot) ($object+".rotateZ");
setAttr -l $scale -k (!$scale) ($object+".scaleX");
setAttr -l $scale -k (!$scale) ($object+".scaleY");
setAttr -l $scale -k (!$scale) ($object+".scaleZ");
setAttr -l $vis -k (!$vis) ($object+".visibility");
}

global proc string asLabelCodeLookup (string $labelCode, int $labelToCode)
{

string $result;
int $codes[]={0,1,2,4,5,10,12,15,16,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18};
string $labels[]={"None","Root","Hip","Foot","Toe","Shoulder","Hand","PropA","PropB","PropC","Other","Chest","Mid","Ball","Heel","BigToe","PinkyToe","LegAim","Eye","Wheel","0","1","2","3"};

for ($i=0;$i<size($labels);$i++)
	{
	if ($labelToCode)
		if ($labels[$i]==$labelCode)
			return $codes[$i];
	if (!$labelToCode)
		if ($codes[$i]==$labelCode)
			return $labels[$i];
	}
return "";
}

global proc string asLabel (string $obj)
{
string $label;
if (size(`ls -ap $obj`)>1)
	error ("More than one object matches name: "+$obj+"\n");
if (!`objExists $obj`)
	return "AA";
if (!`attributeExists "type" $obj`)
	return "BB";
int $labelNum=`getAttr ($obj+".type")`;
if (!`getAttr ($obj+".drawLabel")`)
	return "";

$label=`asLabelCodeLookup $labelNum 0`;
if ($labelNum==18)
	{
	$label=`getAttr ($obj+".otherType")`;
	}

return $label;
}

global proc asFollow (string $driver, string $driven, string $target)
{
if (!`objExists $target`)
	return;
string $setRange=$driver+"SetRangeFollow";
if (!`attributeExists "follow" $driver`)
	{
	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 0 $driver;
	createNode -n $setRange setRange;
	setAttr ($setRange+".maxX") 1;
	setAttr ($setRange+".minY") 1;
	setAttr ($setRange+".oldMaxX") 10;
	setAttr ($setRange+".oldMaxY") 10;
	connectAttr ($driver+".follow") ($setRange+".value.valueX");
	connectAttr ($driver+".follow") ($setRange+".value.valueY");
	}
float $temp[]=`xform -q -ws -t $driven`;
createNode -n ($driven+"Static") transform;
asAlign ($driven+"Static") $driven 1 1 0 0;
parent ($driven+"Static") ("IKStatic");
string $tempString[]=`parentConstraint -mo ($driven+"Static") $target $driven`;
string $constraint=$tempString[0];
select $constraint;
connectAttr ($setRange+".outValue.outValueY") ($constraint+"."+$driven+"Static"+"W0");
connectAttr($setRange+".outValue.outValueX") ($constraint+"."+$target+"W1");
}

global proc int[] asLockXform (string $node, int $setLocks[])
{
int $locks[];
if (size($setLocks)==0)
	{
	$locks[0]=`getAttr -l ($node+".tx")`;
	$locks[1]=`getAttr -l ($node+".ty")`;
	$locks[2]=`getAttr -l ($node+".tz")`;
	$locks[3]=`getAttr -l ($node+".rx")`;
	$locks[4]=`getAttr -l ($node+".ry")`;
	$locks[5]=`getAttr -l ($node+".rz")`;
	$locks[6]=`getAttr -l ($node+".sx")`;
	$locks[7]=`getAttr -l ($node+".sy")`;
	$locks[8]=`getAttr -l ($node+".sz")`;
	}

setAttr -l $setLocks[0] ($node+".tx");
setAttr -l $setLocks[1] ($node+".ty");
setAttr -l $setLocks[2] ($node+".tz");
setAttr -l $setLocks[3] ($node+".rx");
setAttr -l $setLocks[4] ($node+".ry");
setAttr -l $setLocks[5] ($node+".rz");
setAttr -l $setLocks[6] ($node+".sx");
setAttr -l $setLocks[7] ($node+".sy");
setAttr -l $setLocks[8] ($node+".sz");

return $locks;
}

global proc string asResolveIKendJoint (string $IKstartJoint, string $jointLabel)
{
string $IKendJoint,$IKendJointLabel,$previousIKendJoint;
if (`gmatch $jointLabel "Shoulder*"`)
	$IKendJointLabel="Hand*";
if (`gmatch $jointLabel "Hip*"`)
	$IKendJointLabel="Foot*";
if (`gmatch $jointLabel "Root*"`)
	$IKendJointLabel="Chest*";
if (`gmatch $jointLabel "0*"`)
	$IKendJointLabel="[0-9]*";
string $children[]=`listRelatives -ad -type joint $IKstartJoint`;
string $childLabel;
int $labelNum,$previousLabelNum;
for ($x=size($children)-1;$x>-1;$x--)
	{
	$childLabel=`asLabel $children[$x]`;
	if (`gmatch $childLabel $IKendJointLabel`)
		{
		$IKendJoint=$children[$x];

		if (`gmatch $childLabel "[0-9]*"`)
			$labelNum=`match "[0-9]*" $childLabel`;
		if ($previousLabelNum>$labelNum)
			{
			$IKendJoint=$previousIKendJoint;
			break;
			}
		if (`gmatch $childLabel "[0-9]*"`)
			{
			$previousLabelNum=`match "[0-9]*" $childLabel`;
			$previousIKendJoint=$children[$x];
			}
		if (!`gmatch $jointLabel "0*"`)
			break;
		}
	}
return $IKendJoint;
}

global proc asSetRefreshOptionVar ()
{
if ((`getModifiers`/4) %  2)
	optionVar -iv asRefresh 1;
else
	optionVar -iv asRefresh 0;
}

global proc asAlign (string $object, string $alignToObject, int $translate, int $rotate, int $jointOrient, int $rotateOrder)
{
global string $gMainProgressBar;
string $parents[]=`listRelatives -p $object`;
string $orientConstraint[];
float $rotation[];
parent $object $alignToObject;
if ($translate)
	xform -os -t 0 0 0 $object;
if ($rotateOrder)
	setAttr ($object+".rotateOrder") `getAttr ($alignToObject+".rotateOrder")`;
if ($rotate)
	xform -os -ro 0 0 0 $object;
if (`objExists $parents[0]`)
	parent $object $parents[0];
else
	parent -w $object;
if ($jointOrient)
	{
	$orientConstraint=`orientConstraint $alignToObject $object`;
	$rotation=`xform -q -os -ro $object`;
	delete $orientConstraint[0];
	setAttr -type float3 ($object+".jointOrient") $rotation[0] $rotation[1] $rotation[2];
	setAttr -type float3 ($object+".rotate") 0 0 0;
	}

if (`optionVar -q asRefresh`)
	refresh;
if (`progressBar -q -st $gMainProgressBar`=="Creating AdvancedSkeleton")
	progressBar -e -s 1 $gMainProgressBar;
}

global proc asToggleFitSkeleton  ()
{
int $fitSkeletonVis=`getAttr FitSkeleton.visibility`;
setAttr -l 0 FitSkeleton.visibility;
setAttr -l 1 FitSkeleton.visibility (!$fitSkeletonVis);
setAttr MotionSystem.visibility $fitSkeletonVis;
setAttr DeformationSystem.visibility $fitSkeletonVis;
}

global proc string asRlaParent (string $joint)
{
string $rlaParent,$label;
string $joints[]=`listRelatives -p -f $joint`;
while ($joints[0]!="")
	{
	if (size(`ls -ap $joints[0]`)!=1)
		continue;
	$label=`asLabel $joints[0]`;
	if (!`gmatch $label "Twist*"`)
		{
		$rlaParent=$joints[0];
		break;
		}
	$joints=`listRelatives -p -f $joints[0]`;
	}

return $rlaParent;
}

global proc string asRlaChild (string $joint)
{
string $rlaChild,$label;
string $tempString[]=`listRelatives -ad -f -type joint $joint`;
for ($x=size($tempString)-1;$x>-1;$x--)
	{
	if (size(`ls -ap $tempString[$x]`)!=1)
		continue;
	$label=`asLabel $tempString[$x]`;
	if (!`gmatch $label "Twist*"`)
		{
		$rlaChild=$tempString[$x];
		break;
		}
	}
return $rlaChild;
}

global proc asSetSmoothBindOptions ()
{
optionVar
-iv "multipleBindPosesOpt" 0
-iv "bindMethod" 1
-iv "bindTo" 2
-iv "skinMethod" 1
-iv "removeUnusedInfluences" 0
-iv "colorizeSkeleton" 0
-fv "maxInfl" 3
-iv "normalizeWeights" 2
-iv "obeyMaxInfl" 0;
SmoothBindSkinOptions;
asWarningIfNotInBuildPose;
}

global proc addSelectorBipedToShelf ()
{
global string $gShelfTopLevel;
string $currentShelf = `tabLayout -query -selectTab $gShelfTopLevel`;
setParent $currentShelf;

string $cmd="source \""+`internalVar -usd`+"AdvancedSkeleton/Selector/biped.mel\";asSelectorbiped;";
string $image=`internalVar -usd`+"AdvancedSkeleton/Selector/biped/biped_background32.bmp";
shelfButton 
	-command $cmd
	-annotation "Selector:biped"
	-image1 $image;
}

global proc asReadIconsFile (string $iconsFile)
{
string $beforeObj[]=`ls -l -as`;
string $afterObj[];
int $fromBefore[];
//createNode -n "iconsGroup" transform;
//setAttr "iconsGroup.visibility" 0;
int $readLine;
$fileId=`fopen $iconsFile "r"`;
string $nextLine = `fgetline $fileId`;
string $previousLine;
while ( size( $nextLine ) > 0 )
	{
	if (!$readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
	if (`gmatch $nextLine "createNode nurbsCurve*"`)
		{
		$readLine=1;
		eval ($previousLine);
		$previousLine = $nextLine;
		$nextLine = `fgetline $fileId`;
		continue;
		}
	if ($readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
		else
			{
			$readLine=0;
			eval ($previousLine);
			}
	$previousLine=$nextLine;
	$nextLine = `fgetline $fileId`;
	}
fclose $fileId;
$afterObj=`ls -l -as`;
for ($i=0;$i<size($afterObj);$i++)
	for ($y=0;$y<size($beforeObj);$y++)
		if ($afterObj[$i]==$beforeObj[$y])
			$fromBefore[$i]=1;
for ($i=0;$i<size($afterObj);$i++)
	if (!$fromBefore[$i])
		parent $afterObj[$i] "iconsGroup";
}

global proc freezeSkinCluster (string $skinCluster)
{
if (!`objExists $skinCluster`)
	return;
int $numMatrix;
float $jointMatrix[];
string $tempString[]=`ls -showType $skinCluster`;

$numMatrix=`getAttr -s ($skinCluster+".bindPreMatrix")`;
for ($i=0;$i<$numMatrix;$i++)
	{
	$tempString=`listConnections -s 1 -d 1 ($skinCluster+".matrix["+$i+"]")`;
	if (!`objExists $tempString[0]`)
		continue;
	$jointMatrix=`getAttr ($tempString[0]+".worldInverseMatrix")`;
	setAttr ($skinCluster+".bindPreMatrix["+$i+"]") -type "matrix" $jointMatrix[0] $jointMatrix[1] $jointMatrix[2] $jointMatrix[3] $jointMatrix[4] $jointMatrix[5] $jointMatrix[6] $jointMatrix[7] $jointMatrix[8] $jointMatrix[9] $jointMatrix[10] $jointMatrix[11] $jointMatrix[12] $jointMatrix[13] $jointMatrix[14] $jointMatrix[15];
	}
}

global proc asMirrorByJointOrient (string $joint, string $side)
{
select -cl;
joint -n tempJoint;
parent tempJoint ($joint+"_R");
setAttr -type float3 tempJoint.translate 0 0 0;
setAttr -type float3 tempJoint.rotate 0 0 0;
setAttr -type float3 tempJoint.jointOrient 0 0 0;
mirrorJoint -mirrorYZ -mirrorBehavior;
$tempString=`listRelatives -p ($joint+$side)`;
parent ($joint+$side) tempJoint1;
setAttr -type float3 ($joint+$side+".rotate") 0 0 0;
setAttr -type float3 ($joint+$side+".jointOrient") 0 0 0;
parent ($joint+$side) $tempString[0];
delete tempJoint tempJoint1;
}

global proc freezeJointCluster (string $jointCluster)
{
if (!`objExists $jointCluster`)
	{
	warning ("Can not find jointCluster: \""+$jointCluster+"\" !\n");
	return;
	}
float $jointMatrix[]=`getAttr ($jointCluster+".bindPreMatrix")`;
string $tempString[];
$tempString=`listConnections -s 1 -d 1 ($jointCluster+".matrix")`;
$jointMatrix=`getAttr ($tempString[0]+".worldInverseMatrix")`;
setAttr ($jointCluster+".bindPreMatrix") -type "matrix" $jointMatrix[0] $jointMatrix[1] $jointMatrix[2] $jointMatrix[3] $jointMatrix[4] $jointMatrix[5] $jointMatrix[6] $jointMatrix[7] $jointMatrix[8] $jointMatrix[9] $jointMatrix[10] $jointMatrix[11] $jointMatrix[12] $jointMatrix[13] $jointMatrix[14] $jointMatrix[15];
}


//--************************Procs for Utilities*************************--//


global proc asResetGlobalRebuildChar ()
{
global string $asRebuildChar;
$asRebuildChar="";
}

global proc asAdvancedRebuild ()
{
global string $gMainProgressBar;
global string $asRebuildChar;
global int $asFitModeScriptJobNr1;
asWarningIfNotInBuildPose;

//AS 3.7 and below legacy
if (`objExists "Group"`)
	if (!`sets -im "AllSet" "Group"`)
		sets -add "AllSet" "Group";
string $allSet="AllSet";
string $controlSet="ControlSet";
string $allSetMembers[]=`sets -q $allSet`;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
//asGoToBuildPose;
int $asFitMode;
if ($asFitModeScriptJobNr1)
	if (`scriptJob -ex $asFitModeScriptJobNr1`)
		$asFitMode=1;
if ($asFitMode)
	evalEcho ("asFitMode");
string $asScriptLocation=`asScriptLocation`;
string $sourceAdvancedSkeleton=("source \""+$asScriptLocation+"advancedSkeleton.mel\"");
if (!`exists advancedSkeleton`)
	eval ($sourceAdvancedSkeleton);
$asRebuildChar="WWW";
evalDeferred ("asResetGlobalRebuildChar");
int $rebuildConnections=`checkBox -q -v RebuildCheckBox`;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$sources[],$destinations[],$sourcesNoPlug[],$destinationsNoPlug[];
string $fitSkeleton="FitSkeleton";
string $roots[];

if (!`objExists $fitSkeleton`)
	error "No skeleton to rebuild\n";
$roots=`listRelatives -type transform -c $fitSkeleton`;
if ($roots[0]=="FitSkeletonOffset");
	$roots=`listRelatives -type transform -c $roots[0]`;
float $temp[3]=`xform -q -ws -t $roots[0]`;
if ($temp[0]<-0.01 || $temp[0]>0.01)
	{
	warning ("1st Joint ("+$roots[0]+") must have translateX set to 0 !, (current worldSpaceTX value="+$temp[0]+")");
	select $roots[0];
	return;
	}
parent -w $roots;
if (`objExists "FitSkeletonOffset"`)
	delete "FitSkeletonOffset";

progressBar -e -st "Analyzing AdvancedSkeleton" -bp -ii 0 -min 0 -max (size($allSetMembers)*2) $gMainProgressBar;

//Pre Rebuild
float $mx[];
string $userAttrs[],$children[],$connections[],$connectionsObj[],$connectCmdsSource[],$connectCmdsDest[];
string $addAttrCmds[],$cmds[],$connectCmds[],$skinClusters[],$jointClusters[];
string $sn,$ln,$at,$k,$cb,$dv,$minMax,$skinCluster;
string $charSet,$objectType,$tr,$xyz,$runCmd;
int $childIsMember,$alreadyConnected;
int $locked;
int $e[2];
float $range[2];
float $vals[2];

if (`objExists FaceAllSet`)
	if (`sets -im "Sets" FaceAllSet`)
		sets -rm "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	if (`sets -im "Sets" FaceControlSet`)
		sets -rm "Sets" FaceControlSet;


//Pre Rebuild parentConstraints
string $constraintParent,$constraintChild;
string $parentConstraints[]=`ls -type parentConstraint`;
string $parentConstraintParents[],$parentConstraintChildren[];
string $constraintParent;
for ($i=$y=0;$i<size($parentConstraints);$i++)
	{
	if (`sets -im $allSet $parentConstraints[$i]` || `gmatch $parentConstraints[$i] "*_Box_*"`)
			continue;

	$tempString=`listConnections ($parentConstraints[$i]+".target[0].targetJointOrient")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintParent=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	$tempString=`listConnections ($parentConstraints[$i]+".constraintTranslate.constraintTranslateX")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintChild=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	if (!`objExists $constraintParent` || !`objExists $constraintChild`)
		continue;
	if (!`sets -im $allSet $constraintParent` && !`sets -im $allSet $constraintChild`)
		continue;

	$parentConstraintParents[$y]=$constraintParent;
	$parentConstraintChildren[$y]=$constraintChild;
	delete $parentConstraints[$i];
	$y++;
	}

//Pre Rebuild userDefinedAttr
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	$userAttrs=`listAttr -ud $allSetMembers[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		$tempString=`listAttr -sn ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		if (`gmatch $at "*Array"`)
			continue;
		$dv=`getAttr ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$k=`getAttr -k ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$cb=`getAttr -cb ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="string")
			continue;
		if (`gmatch $ln "*W[0-9]"`)
			continue;
		$minMax="";
		if (`attributeQuery -re -n $allSetMembers[$i] $ln`)
			{
			$range=`attributeQuery -r -n $allSetMembers[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	addAttr -k "+$k+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$allSetMembers[$i]+";";
		//Non-keyable
		if ($k=="0" && $cb)
			$addAttrCmds[size($addAttrCmds)]="if (`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	setAttr -cb 1 "+$allSetMembers[$i]+"."+$userAttrs[$y]+";";
		//Run
		if (`attributeExists run FitSkeleton`)
			{
			$runCmd=`getAttr FitSkeleton.run`;
			if ($runCmd!="")
				{
				$addAttrCmds[size($addAttrCmds)]="setAttr -type \"string\" FitSkeleton.run \""+`encodeString $runCmd`+"\";";
				}
			}
		}
	}


//Pre Rebuild Parenting
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`objectType $allSetMembers[$i]`=="objectSet")
		continue;
	$children=`listRelatives -c $allSetMembers[$i]`;
	for ($y=0;$y<size($children);$y++)
		{
		$tempString=`ls $children[$y]`;
		if (size($tempString)>1)
			error ("ObjectName not unique "+$children[$y]+"\n");
		$childIsMember=0;
		for ($z=0;$z<size($allSetMembers);$z++)
			if ($children[$y]==$allSetMembers[$z])
				$childIsMember=1;
		if (!$childIsMember)
			{
			$tempString=`ls -s $children[$y]`;
			if ($tempString[0]!="")
				$cmds[size($cmds)]="parent -r -s "+$children[$y]+" "+$allSetMembers[$i]+";";
			else if (`getAttr ($children[$y]+".inheritsTransform")` && !`gmatch $children[$y] "*_?_[0-9][0-9]"`)
				$cmds[size($cmds)]="parent "+$children[$y]+" "+$allSetMembers[$i]+";";
			else
				$cmds[size($cmds)]="parent -r "+$children[$y]+" "+$allSetMembers[$i]+";";
			}
		}
	if (!$rebuildConnections)
		continue;

	//Incoming connections
	$connections=`listConnections -p 1 -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		if ($connections[$y+1]=="Group.message")
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver" || $objectType== "displayLayerManager")
			continue;
		if ($connections[$y+1]=="time1.outTime")
			continue;
		$connectCmds[size($connectCmds)]="if (`getAttr -l "+$connections[$y]+"`)  setAttr -l 0 "+$connections[$y]+";connectAttr -f "+$connections[$y+1]+" "+$connections[$y]+";";
//		$connectCmds[size($connectCmds)]="if (`getAttr -l "+$connections[$y]+"`)  setAttr -l 0 "+$connections[$y]+";";
//		$connectCmds[size($connectCmds)]="connectAttr -f "+$connections[$y+1]+" "+$connections[$y]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y+1];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y];
		}

	//Outgoing connections
	$connections=`listConnections -p 1 -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="materialInfo" || $objectType=="partition")
			continue;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
			continue;
//		if ($objectType=="skinCluster" || $objectType=="dagPose")
//			continue;
		if (`gmatch $connections[$y] "*instObjGroups*"` || `gmatch $connections[$y+1] "*instObjGroups*"`)
			continue;
		if ($objectType=="skinCluster")
			$skinClusters[size($skinClusters)]=$connectionsObj[$y+1];
		if ($objectType=="jointCluster")
			$jointClusters[size($jointClusters)]=$connectionsObj[$y+1];
		$connectCmds[size($connectCmds)]="connectAttr -f "+$connections[$y]+" "+$connections[$y+1]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y+1];
		}

	//transformLimits
	if (`objectType $allSetMembers[$i]`=="joint")
		{
		$tr="r";
		for ($y=0;$y<2;$y++)
			{
			if ($y==1)
				continue;
//				$tr="t";
			$xyz="x";
			for ($z=0;$z<3;$z++)
				{
				if ($z==1)
					$xyz="y";
				if ($z==2)
					$xyz="z";
				$e=`eval ("transformLimits -q -e"+$tr+$xyz+" "+$allSetMembers[$i])`;
				if ($e[0] || $e[1])
					{
					$vals=`eval ("transformLimits -q -"+$tr+$xyz+" "+$allSetMembers[$i])`;
					$cmds[size($cmds)]="transformLimits -"+$tr+$xyz+" "+$vals[0]+" "+$vals[1]+" -e"+$tr+$xyz+" "+$e[0]+" "+$e[1]+" "+$allSetMembers[$i]+";";
					}
				}
			}
		}
	}

//Pre Rebuild CurveShapes
string $controlSetMembers[]=`sets -q $controlSet`;
string $curveShape;
int $spans,$degree,$numCVs;
float $cvPos[3];
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listRelatives -s $controlSetMembers[$i]`;
	$curveShape=$tempString[0];
	if (!`objExists $curveShape`)
		continue;
	if (`objectType $curveShape`!="nurbsCurve")
		continue;
	$spans=`getAttr ($curveShape+".spans")`;
	$degree=`getAttr ($curveShape+".degree")`;
	$numCVs=$spans+$degree;
	for ($y=0;$y<$numCVs;$y++)
		{
		$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
		$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
		}
	}

//Pre Rebuild jointLayer
$tempString=`listAttr -s jointLayer`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections ("jointLayer."+$tempString[$i])`;
	if (size($tempString2))
		continue;
	$cmds[size($cmds)]="setAttr jointLayer."+$tempString[$i]+" "+`getAttr ("jointLayer."+$tempString[$i])`+";";
	}

//Pre Rebuild CharacterSet
$tempString=`ls -type character`;
if (size($tempString))
	{
	$charSet=$tempString[0];
	$sources=`listConnections -p 1 -s 1 -d 0 $charSet`;
	$sourcesNoPlug=`listConnections -p 0 -s 1 -d 0 $charSet`;
	for ($i=0;$i<size($sources);$i++)
		if (`sets -im $allSet $sourcesNoPlug[$i]`)
			{
			$destinations=`listConnections -p 1 -s 0 -d 1 $sources[$i]`;
			$destinationsNoPlug=`listConnections -p 0 -s 0 -d 1 $sources[$i]`;
			for ($y=0;$y<size($destinations);$y++)
				if ($destinationsNoPlug[$y]==$charSet)
					disconnectAttr $sources[$i] $destinations[$y];
			}
	}

//Pre Rebuild Disable expressions to avoid warnings
$tempString=`ls -type expression`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im $allSet $tempString[$i]`)
		setAttr ($tempString[$i]+".nodeState") 1;


//Rebuild
$allSetMembers[size($allSetMembers)]="Group";
$allSetMembers[size($allSetMembers)]="Sets";
$allSetMembers[size($allSetMembers)]="AllSet";
$allSetMembers[size($allSetMembers)]="ControlSet";
$allSetMembers[size($allSetMembers)]="DeformSet";

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
	else
		$allSetMembers[$i]="";

//unprefix CylShapes inorde to preserve these
$tempString=`ls -type nurbsSurface "*_CylShape*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		rename $tempString[$i] `substitute "prefix_" $tempString[$i] ""`;


progressBar -e -ep $gMainProgressBar;

select $roots;
advancedSkeleton();

//redo parentConstraints
for ($i=0;$i<size($parentConstraintParents);$i++)
	if (`objExists $parentConstraintParents[$i]` && `objExists $parentConstraintChildren[$i]`)
		parentConstraint -mo $parentConstraintParents[$i] $parentConstraintChildren[$i];


//Post Rebuild
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
for ($i=0;$i<size($connectCmds);$i++)
	{
	$alreadyConnected=0;
	if (`objExists $connectCmdsSource[$i]` && `objExists $connectCmdsDest[$i]`)
		if (`isConnected -iuc $connectCmdsSource[$i] $connectCmdsDest[$i]`)
			$alreadyConnected=1;
	if (!$alreadyConnected)
		if (catchQuiet (`eval ($connectCmds[$i])`)) warning ("Failed: "+$connectCmds[$i]+"\n");
	}
for ($cmd in $cmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

//reset bindPose
string $bindPose;
string $newSetMembers[]=`sets -q $allSet`;
for ($i=0;$i<size($newSetMembers);$i++)
	{
	if (`objectType $newSetMembers[$i]`=="joint")
		{
		select $newSetMembers[$i];
		$tempString=`dagPose -q -bp`;
		$bindPose=$tempString[0];
		if (`objExists $bindPose`)
			{
			$tempString=`listConnections ($newSetMembers[$i]+".bindPose")`;
			if ($tempString[0]==$bindPose)
				{
				select -add $bindPose;
				dagPose -rs;
				}
			}
		}
	}


for ($i=0;$i<size($allSetMembers);$i++)
	if (`gmatch $allSetMembers[$i] "*CurveInfo*"`)
		if (`objExists $allSetMembers[$i]`)
			delete $allSetMembers[$i];
for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		catchQuiet (`delete $allSetMembers[$i]`);

$skinClusters=`stringArrayRemoveDuplicates $skinClusters`;
$jointClusters=`stringArrayRemoveDuplicates $jointClusters`;
for ($i=0;$i<size($skinClusters);$i++)
	freezeSkinCluster $skinClusters[$i];
for ($i=0;$i<size($jointClusters);$i++)
	freezeJointCluster $jointClusters[$i];

if (`objExists FaceAllSet`)
	sets -add "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	sets -add "Sets" FaceControlSet;

if ($runCmd!="")
	evalEcho $runCmd;

eval ("dgdirty -a");
catch (`select $sel`);

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		delete $allSetMembers[$i];
}

global proc asLockSkeleton (int $onOff)
{
setAttr "jointLayer.displayType" (2*$onOff);
}

global proc asSelectDeformJoints ()
{
if (`objExists "DeformSet"`)
	select `sets -q "DeformSet"`;
}

global proc asCreatePartialJoints ()
{
asWarningIfNotInBuildPose;
string $dialog=`confirmDialog -t "Confirm"
	-m "Create Partial Joints for all deformJoints ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "DeformSet"`)
	return;

float $charHeight=`asgetCharHeight`;
int $sideFactor;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $children[],$partialJoints[],$zero[],$parents[],$buffer[],$tempString[];
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$children=`listRelatives -type joint -c $deformJointsList[$i]`;
	$parents=`listRelatives -type joint -p $deformJointsList[$i]`;
	if (!size($children) || !size($parents) || `gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	select $deformJointsList[$i];
	tokenize $deformJointsList[$i] "_" $buffer;
	$partialJoints[$i]=$buffer[0]+"50_"+$buffer[1];
	$partialJoints[$i]=$buffer[0]+"_"+$buffer[1]+"_50";
	$zero[$i]=$buffer[0]+"_"+$buffer[1]+"_00";
	if (`objExists $partialJoints[$i]`)
		error ("PartialJoints already exists");
	joint -n $partialJoints[$i];
	parent $partialJoints[$i] $parents[0];
	setAttr ($partialJoints[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $partialJoints[$i];
	sets -add "DeformSet" $partialJoints[$i];
	select $parents[0];
	createNode -n $zero[$i] transform;
	parent $zero[$i] $parents[0];
	setAttr -type float3 ($zero[$i]+".t") 0 0 0;
	setAttr -type float3 ($zero[$i]+".r") 0 0 0;
	setAttr ($zero[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $zero[$i];
	$tempString=`orientConstraint $zero[$i] $deformJointsList[$i] $partialJoints[$i]`;
	$tempString=`pointConstraint $deformJointsList[$i] $partialJoints[$i]`;
	setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
	}
select -cl;
for ($i=0;$i<size($deformJointsList);$i++)
	if (`gmatch $partialJoints[$i] "*_?_50"`)
		select -add $partialJoints[$i];
}

global proc asDeletePartialJoints ()
{
if (!`objExists "DeformSet"`)
	return;

string $DeformationSystemNodes[]=`listRelatives -ad "DeformationSystem"`;
for ($i=0;$i<size($DeformationSystemNodes);$i++)
	if (`attributeExists partialJoint $DeformationSystemNodes[$i]`)
		delete $DeformationSystemNodes[$i];
}

global proc asUpdateLabelHelp ()
{
string $labelType=`optionMenu -q -v asLabelType`;
string $help="";
if ($labelType=="Hand" || $labelType=="Shoulder")
	$help="Hand + Shoulder = Arm IK";
if ($labelType=="Hip" || $labelType=="Foot")
	$help="Hip + Foot = Leg IK";
if ($labelType=="LegAim")
	$help="LegAim + Hip + Foot = 3 bone Leg IK";
if ($labelType=="Heel" || $labelType=="Ball" || $labelType=="Toe")
	$help="Ball + Heel + Toe = FootRoll";
if ($labelType=="BigToe" || $labelType=="PinkyToe")
	$help="BigToe + PinkyToe = FootRock";
if ($labelType=="Root" || $labelType=="Chest" || $labelType=="Mid")
	$help="Root + Chest (+ Mid) = Spine IK";
if ($labelType=="Eye")
	$help="Look at.. aim system";
if ($labelType=="Wheel")
	$help="Wheel rolling system";
if ($labelType=="0" || $labelType=="1" || $labelType=="2" || $labelType=="3")
	$help="0,1,2, etc.. = Spline IK (tail)";


text -e -l $help asLabelHelp;
}

global proc asLabelJoint ()
{
string $labelType=`optionMenu -q -v asLabelType`;
string $sel[]=`ls -sl -type joint`;
int $labelCode;
for ($i=0;$i<size($sel);$i++)
	{
	setAttr ($sel[$i]+".drawLabel") 1;
	$labelCode=`asLabelCodeLookup $labelType 1`;
	setAttr ($sel[$i]+".type") $labelCode;
	if ($labelCode==18)
		setAttr -type "string" ($sel[$i]+".otherType") $labelType;
	}
}

global proc asHideMotionSystem (int $onOff)
{
setAttr "MotionSystem.visibility" (!$onOff);
}

global proc asHidePolyBoxes (int $onOff)
{
if (!`objExists "BoxesGeometry"`)
	error "BoxesGeometry does not exists !\n";
setAttr -l 0 "BoxesGeometry.visibility";
setAttr -l ($onOff) "BoxesGeometry.visibility" (!$onOff);
if (!$onOff)
	setAttr -l ($onOff) "BoxesGeometry.visibility";
}


global proc asDeleteSkinCage ()
{
string $deleteObjs[]={"skinCage","SkinSub","Cages","MeshGeometry","MeshCurves","NurbsGeometry","SkinCage","SkinCurves1","SkinCurves2","SkinCageCurvesSet"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asRebuildSkinCage ()
{
string $restoreShapesCmds[];
string $profileCurveShapes[]=`ls -type nurbsCurve "*ProfileShape*"`;
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($profileCurveShapes);$i++)
	{
	$form=`getAttr ($profileCurveShapes[$i]+".form")`;
	$spans=`getAttr ($profileCurveShapes[$i]+".spans")`;
	$degrees=`getAttr ($profileCurveShapes[$i]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($profileCurveShapes[$i]+".cv["+$y+"]")`;
		$restoreShapesCmds[size($restoreShapesCmds)]="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$profileCurveShapes[$i]+".cv["+$y+"];";
		}
	}

asDeleteSkinCage;
asCreateSkinCage;
for ($i=0;$i<size($restoreShapesCmds);$i++)
	print ($restoreShapesCmds[$i]+"\n");
for ($i=0;$i<size($restoreShapesCmds);$i++)
	catchQuiet (`eval $restoreShapesCmds[$i]`);
}

global proc asCreateSkinCage ()
{
asWarningIfNotInBuildPose;
softSelect -e -softSelectEnabled 0;
string $tempString[];

if (`objExists MeshGeometry`)
	{
	asRebuildSkinCage;
	return;
	}

createNode -n Cages transform;
parent Cages Geometry;
createNode -n MeshGeometry transform;
parent MeshGeometry Geometry;
setAttr "MeshGeometry.overrideEnabled" 1;
createNode -n MeshCurves transform;
parent MeshCurves Geometry;
createNode -n NurbsGeometry transform;
setAttr NurbsGeometry.v 0;
parent NurbsGeometry Geometry;
sets -em -name SkinCageCurvesSet;
sets -add "Sets" SkinCageCurvesSet;

select -cl;
createDisplayLayer -name "SkinCage" -number 1 -nr;
createDisplayLayer -name "SkinCurves1" -number 2 -nr;
createDisplayLayer -name "SkinCurves2" -number 3 -nr;
setAttr SkinCurves2.visibility 0; setAttr SkinCurves2.displayType 0; setAttr SkinCurves2.color 13;
setAttr SkinCurves1.visibility 1; setAttr SkinCurves1.displayType 0; setAttr SkinCurves1.color 14;
setAttr SkinCage.displayType 2;


//Build tubes
string $topNodes[]=`listRelatives -type joint -c DeformationSystem`;
	asAnalyzeChainJoints $topNodes[0];
$tempString=`listRelatives -type joint -c $topNodes[0]`;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "Back?_M"`)
		if (!`objExists ($tempString[$i]+"_middleCurve")`)
			asAnalyzeChainJoints $tempString[$i];

//pickup single brancers
string $children[];
$tempString=`asListAllDecents $topNodes[0]`;
for ($i=0;$i<size($tempString);$i++)
	{
	$children=`asListChildren $tempString[$i]`;
	if (size($children)>0)
		if (!`objExists ($tempString[$i]+"_middleCurve")`)
			asBuildChainCurves {$tempString[$i]};
	}

//Branch
asCreateBranchBoxes;
string $wrapCurves[]=`ls "*_wrapCurve_*"`;
if (size($wrapCurves))
	delete $wrapCurves;

//merge copies.
string $copies[]=`ls -as "*_copy"`;select $copies;
$tempString=`polyUnite -ch 0 -n skinCage $copies`;
setAttr ($tempString[0]+".keepBorder") 0;
polyMergeVertex -d 0.01 -am 1 -ch 1 skinCage;
select skinCage;
DeleteHistory;
parent skinCage Cages;
editDisplayLayerMembers -noRecurse SkinCage skinCage;
string $middleCurves[]=`ls -type transform "*_middleCurve"`;

//skinn
string $joint,$twistJoint;
select -cl;
for ($i=0;$i<size($middleCurves);$i++)
	{
	$joint=`substitute "_middleCurve" $middleCurves[$i] ""`;
	select -add $joint;
	//include twistJoints
	for ($y=1;$y<99;$y++)
		{
		tokenize $joint "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$y+"_"+$tempString[1];
		if (`objExists $twistJoint`)
			select -add ($twistJoint);
		else
			break;
		}
	//include nonListedParents
	$tempString=`listRelatives -type joint -p $joint`;
	if (size($tempString))
		if (!`objExists ($tempString[0]+"_middleCurve")`)
			if (!`gmatch $tempString[0] "*Part[0-9]*"`)
				select -add $tempString[0];
	//include 50`s
	if (`objExists ($joint+"_50")`)
		select -add ($joint+"_50");
	//deselect endJoints
	$tempString=`listRelatives -type joint -c $joint`;
	if (!`size($tempString)`)
		select -d $joint;
	}
select -add skinCage;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] skinClusterSkinCage;
select -r `listRelatives -c MeshGeometry`;
select `ls -sl -ni "*_poly"`;
select -add skinCage;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
string $cylinders[]=`ls -type transform "*_poly"`;
for ($i=0;$i<size($cylinders);$i++)
	{
	delete `listConnections ($cylinders[$i]+"Shape.inMesh")`;
	setAttr -l 1 ($cylinders[$i]+".v") 0;
	}

//wrap
string $cylinders[]=`ls -type transform "*_poly"`;
select -cl;
deformer -type wrap skinCage;
for ($i=0;$i<size($cylinders);$i++)
	{
	select -r skinCage;
	select -add $cylinders[$i];
	AddWrapInfluence;
	}
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] wrapSkinCage;

reorderDeformers "skinClusterSkinCage" "wrapSkinCage" "skinCage";

//polySmooth -n smoothSkinCage -mth 0 -dv 2 -c 1 -kb 0 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 skinCage;

//Profiles tweaks
asProfileTweaks;

select -cl;
}

global proc asProfileTweaks ()
{
float $charHeight=`asgetCharHeight`;
string $ankleProfileEnds[]=`ls -type nurbsCurve "*Ankle_*endProfileShape"`;
string $tempString[];
string $ankle,$heel,$transform;
int $numLetters;
int $cvs[];
float $pos[3],$existingPos[3],$transformPos[3],$offset[3];
float $averageZ;
for ($i=0;$i<size($ankleProfileEnds);$i++)
	{
	$ankle=`substitute "endProfileShape" $ankleProfileEnds[$i] ""`;
	$numLetters=size($ankle);
	$ankle=`substring $ankle 1 ($numLetters-3)`;
	$tempString=`listRelatives -p $ankleProfileEnds[$i]`;
	$transform=$tempString[0];
	$transformPos=`xform -q -ws -t $transform`;
	$tempString=`listRelatives -c -type joint $ankle`;
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "*Heel*"`)
			$heel=$tempString[$y];
	if ($heel=="")
		continue;
	$pos=`xform -q -ws -t $heel`;
	if (`gmatch $ankleProfileEnds[$i] "*_L_*"`)
		$cvs={0,1,4};
	else
		$cvs={2,3};
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -ws -t ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]")`;
		$offset[1]=($pos[1]-$transformPos[1])*0.2;
		$offset[2]=($pos[2]-$transformPos[2])*0.2;
		xform -ws -t $existingPos[0] ($pos[1]+$offset[1]) ($pos[2]+$offset[2]) ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		}
	}
string $toeProfileMiddle[]=`ls -type nurbsCurve "*MiddleToe*ProfileShape"`;
for ($i=0;$i<size($toeProfileMiddle);$i++)
	{
	$tempString=`listRelatives -p $toeProfileMiddle[$i]`;
	$transform=$tempString[0];
	$transformPos=`xform -q -ws -t $transform`;
	if (`gmatch $toeProfileMiddle[$i] "*_L_*"`)
		$cvs={0,1,4};
	else
		$cvs={2,3};
	$averageZ=0;
	for ($y=0;$y<4;$y++)
		{
		$existingPos=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv["+$y+"]")`;
		$averageZ+=$existingPos[2];
		}
	$averageZ=$averageZ/4.0;
	for ($y=0;$y<5;$y++)
		{
		$existingPos=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv["+$y+"]")`;
		xform -ws -t $existingPos[0] $existingPos[1] $averageZ ($toeProfileMiddle[$i]+".cv["+$y+"]");
		}
	for ($y=0;$y<size($cvs);$y++)
		{
		$offset[1]=($pos[1]-$transformPos[1])*0.2;
		$existingPos=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t $existingPos[0] (0+$offset[1]) $existingPos[2] ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]");
		}
	}
}

global proc asCreateSliders ()
{
asWarningIfNotInBuildPose;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";

if (`objExists closestSampler`)
	delete closestSampler;
if (!`objExists SlideSystem`)
	createNode -n SlideSystem -p MotionSystem transform;

int $sideFactor=1;
int $vtxNr[];
int $bendAxis;
string $tempString[],$branchVtxs[],$branchVtxSliderNrs[];
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*_L_*"`)
		$sideFactor=-1;
	else
		$sideFactor=1;

	$bendAxis=0;//all directions
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];

	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -type joint -p $parent`;
		$parent=$tempString[0];
		}
	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $firstPa=$tempString[0];

	if ($skinCurveSliderInfo[1]=="")
		{
		print ("// Skipping "+$sel[$i]+", as it`s not defining start or end or middle of deformation\n");
		continue;
		}
	string $stEnMid=$skinCurveSliderInfo[1];
	if (`objExists ($deformJoint+"_"+$stEnMid+"Slider0")` || `objExists ($deformJoint+"_"+$stEnMid+"Slider1")`)
		continue;

	createNode -n messureTemp transform;
	pointConstraint $sel[$i] messureTemp;
	parent messureTemp $firstPa;
	if ($skinCurveSliderInfo[1]=="end")
		parent messureTemp $deformJoint;
	float $xOffset=`getAttr messureTemp.tx`;
	delete messureTemp;

	//create the 50joint
	int $baseStrucExists=0;
	if (`objExists ($deformJoint+"_Slide50")`)
		$baseStrucExists=1;
	if (!$baseStrucExists)
		{
		select $deformJoint;
		joint -n ($deformJoint+"_Slide50");
		setAttr ($deformJoint+"_Slide50.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide50") $firstPa;
		createNode -n ($deformJoint+"_Slide00") transform;
		parent ($deformJoint+"_Slide00") $deformJoint;
		setAttr -type float3 ($deformJoint+"_Slide00.t") 0 0 0;
		setAttr -type float3 ($deformJoint+"_Slide00.r") 0 0 0;
		setAttr ($deformJoint+"_Slide00.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide00") $firstPa;
		$tempString=`orientConstraint ($deformJoint+"_Slide00") $deformJoint ($deformJoint+"_Slide50")`;
//		setAttr ($tempString[0]+".interpType") 2; //`shortest` seem to be stable
//	shortest works best on elbow that has twists
		$tempString=`pointConstraint $deformJoint ($deformJoint+"_Slide50")`;
		setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
		}

	//only 2 for elbow/knee, determine $bendAxis
	if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
		{
		float $jo[]=`getAttr ($deformJoint+".jointOrient")`; // check jointOrient to find bend axis
		if ($jo[1]>$jo[2]) $bendAxis=1;// .joY greater than .joZ, so not a Zbender
		if ($jo[2]>$jo[1]) $bendAxis=2;// .joZ greater than .joY, so not a Ybender
		}

	for ($y=0;$y<4;$y++)
		{
		//only 2 for elbow/knee, determine $bendAxis
		if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
			{
			if ($bendAxis==1) if ($y==0 || $y==2) continue;
			if ($bendAxis==2) if ($y==1 || $y==3) continue;
			}
		if ($skinCurveSliderInfo[1]=="start") select $firstPa;
		if ($skinCurveSliderInfo[1]=="middle") select ($deformJoint+"_Slide50");
		if ($skinCurveSliderInfo[1]=="end") select $deformJoint;
		joint -n ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		sets -add ("DeformSet") ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		float $posA[3]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		float $posB[3]=`xform -q -ws -t ($sel[$i]+".cv["+($y+1)+"]")`;
		float $pos[3]={(($posA[0]+$posB[0])/2.0), (($posA[1]+$posB[1])/2.0), (($posA[2]+$posB[2])/2.0)};
		xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_"+$stEnMid+"Slider"+$y);

		if (!$baseStrucExists)
			{
			// recylcle these between starters, enders, and middlers
			createNode -n ($deformJoint+"_SlideDist"+$y) distanceBetween	;
			createNode -n ($deformJoint+"_SlideStart"+$y) transform;
			createNode -n ($deformJoint+"_SlideEnd"+$y) transform;
//			connectAttr -f ($deformJoint+"_SlideStart"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point1");
			connectAttr -f ($deformJoint+"_SlideEnd"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point2");
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideStart"+$y);
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideEnd"+$y);
//			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
//			setAttr -type float3 ($deformJoint+"_SlideEnd"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
			parent ($deformJoint+"_SlideStart"+$y) $firstPa;
			parent ($deformJoint+"_SlideEnd"+$y) $firstPa;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideStart"+$y);
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideEnd"+$y);		
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_Slide50");
			setAttr ($deformJoint+"_SlideEnd"+$y+".tx") 0;
			float $temp[3]=`getAttr ($deformJoint+"_SlideEnd"+$y+".t")`;
			float $mag=`mag <<$temp[0],$temp[1],$temp[2]>>`*$sideFactor;
			$temp[0]=`getAttr ($deformJoint+".tx")`;
			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".t") ($temp[0]-$mag) 0 0;
			parent ($deformJoint+"_SlideStart"+$y) SlideSystem;
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo $firstPa ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo ($deformJoint+"_Slide50") ($deformJoint+"_SlideEnd"+$y);
			//behaviour
			createNode -n ($deformJoint+"_SlideDistNormalize"+$y) multiplyDivide;
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDist"+$y+".distance") ($deformJoint+"_SlideDistNormalize"+$y+".input1X");
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".input2X") `getAttr ($deformJoint+"_SlideDistNormalize"+$y+".input1X")`;
			}

		//they all share `_SlideMultiply` & `SlideReducer` & `_SlidePlusOffset`
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
		setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") 0.3;
		if ($skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") -0.3;
		//on opposide side, the start and end must move opposite direction
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") (`getAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X")`*$sideFactor);
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y) multiplyDivide;
		addAttr -k 1 -ln slide -at double -dv 1 ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		connectAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".slide") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input2X");
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input1X");
		createNode -n ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y) plusMinusAverage;
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[0]");
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			{
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y) plusMinusAverage;
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[0]");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[1]") 1;

			connectAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") $xOffset;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".tx");
			}
		if ($skinCurveSliderInfo[1]=="middle")
			{
			string $slideAxis="z";
			if ($bendAxis==2)
				$slideAxis="y";
			if (($bendAxis==0) && ($y==0 || $y==2))
				$slideAxis="y";
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y) reverse;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".inputX");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y) condition;
			if (`getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`>0)
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 4;
			else
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 2;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".firstTerm");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfFalseR");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y) multiplyDivide;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input2X") -1;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfTrueR");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".outColorR") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");

			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") `getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis);

			}

		//skinning
		skinCluster -e -lw false -wt 0 -ai ($deformJoint+"_"+$stEnMid+"Slider"+$y) skinClusterSkinCage;
		float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$y) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
		if ($bendAxis==0) //all directions
			{
			if ($y>0) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+($y-1)) 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
			if ($y==3) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider3") 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[0]+"]");
			}
		if (($bendAxis==1 && $y==3) || ($bendAxis==2 && $y==2)) //last loop for Z or Ybender
			{
			int $pickupVtx=2;
			int $sliderNr=1;
			if ($bendAxis==2) {$pickupVtx=1;$sliderNr=0;}
			float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			$pickupVtx=4;
			$sliderNr=3;
			if ($bendAxis==2) {$pickupVtx=3;$sliderNr=2;}
			float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			}
		}

	//branchVtx`s edgeloopCheck to see if there`s a extra vtx, if so.. this is a `brancher`
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	$branchVtxSliderNrs=`asGetBranchedVtx $tempString 1`;
	for ($y=0;$y<size($branchVtxs);$y++)
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$branchVtxSliderNrs[$y]) 1 skinClusterSkinCage $branchVtxs[$y];
	}

if (`objExists closestSampler`)
	delete closestSampler;
select $sel;
}

global proc string[] asGetBranchedVtx (string $inputVtxs[], int $vertsOrSliderNr)
{
string $return[],$branchVtxs[],$branchVtxSliderNrs[];
string $connectVtx0s[],$connectVtx1s[],$connectVtx2s[],$connectVtx3s[];
for ($y=0;$y<4;$y++)
	{
	select $inputVtxs[$y];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $inputVtxs[$y];
	$tempString=`ls -sl -fl`;
	if ($y==0) $connectVtx0s=$tempString;
	if ($y==1) $connectVtx1s=$tempString;
	if ($y==2) $connectVtx2s=$tempString;
	if ($y==3) $connectVtx3s=$tempString;
	}
for ($y=0;$y<size($connectVtx0s);$y++) {
	if (`stringArrayCount $connectVtx0s[$y] $connectVtx1s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=0;}
if (`stringArrayCount $connectVtx0s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=3;}}
for ($y=0;$y<size($connectVtx1s);$y++)
	if (`stringArrayCount $connectVtx1s[$y] $connectVtx2s`) {$branchVtxs[size($branchVtxs)]=$connectVtx1s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=1;}
for ($y=0;$y<size($connectVtx2s);$y++)
	if (`stringArrayCount $connectVtx2s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx2s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=2;}
if ($vertsOrSliderNr)
	$return=$branchVtxSliderNrs;
else
	$return=$branchVtxs;
return $return;
}

global proc asDeleteSliders ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
string $tempString[];
int $vtxNr[];
for ($i=0;$i<size($sel);$i++)
	{
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];
	int $haveSliderJoint[4];
	for ($y=0;$y<4;$y++)
		{
		//skinning
		float $pos[]=`xform -q -ws -t $sel[$i]`;
		createNode -n closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker1;
		float $pos[]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		createNode -n closestSamplerShrinker2 -p closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker2;
		float $pos[]=`xform -q -ws -t closestSamplerShrinker2`;
		scale -r 0.832 0.832 0.832 closestSamplerShrinker1;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		delete closestSamplerShrinker1;
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		}
	//$branchVtxs
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	for ($y=0;$y<size($branchVtxs);$y++)
		{
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage $branchVtxs[$y];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage $branchVtxs[$y];
		}
	//delete the joint
	for ($y=0;$y<4;$y++)
		if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
			delete ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y);

	//remove 50 system, if no longer required
	int $remove50=0;
	if (!`objExists ($skinCurveSliderInfo[0]+"_SlideDistNormalize1")`)
		{
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide50")`)
			delete ($skinCurveSliderInfo[0]+"_Slide50");
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide00")`)
			delete ($skinCurveSliderInfo[0]+"_Slide00");
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y)`)
				delete ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y);
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
select -cl;
}

global proc string asListParent (string $obj)
{
int $skip;
string $tempString[]=`listRelatives -type joint -p $obj`;
string $skips[]={"Scapula_","Cup_"};
$skip=0;
for ($y=0;$y<size($skips);$y++)
	if (`gmatch $tempString[0] ("*"+$skips[$y]+"*")`)
		$skip=1;
if ($skip)
	$tempString=`listRelatives -type joint -p $tempString[0]`;
return $tempString[0];
}

global proc string[] asListChildren (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -c $obj`;
string $tempString2[];
string $skips[]={"Scapula_","Slider[0-9]","Slide50","Cup_","ThumbFinger1_","PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	if ($obj=="Root_M" && `gmatch $tempString[$i] "Back?_M"`)
		return {$tempString[$i]};
	$skip=$skipChildrenToo=0;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempString[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skipChildrenToo=1;
	if (`attributeExists noMiddleCurve $tempString[$i]`)
		{
		$skip=1;
		$skipChildrenToo=1;
		}
	if ($skip)
		{
		if (!$skipChildrenToo)
			{
			$tempString2=`listRelatives -type joint -c $tempString[$i]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$skip=0;
				for ($y=0;$y<size($skips);$y++)
					if (`gmatch $tempString2[$z] ("*"+$skips[$y]+"*")`)
						$skip=1;
				if (!$skip)
					$result[size($result)]=$tempString2[$z];
				}
			}
		}
	else
		if ($tempString[$i]!="")
			$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc string[] asListAllDecents (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -ad $obj`;
string $tempStringFullPath[]=`listRelatives -type joint -ad -f $obj`;
string $skips[]={"Scapula_","Slider[0-9]","Slide50","Cup_","ThumbFinger1_","PinkyToe_","BigToe_","Jaw_","Eye_","_50","Float","Part[0-9]_"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempStringFullPath[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skip=1;
	if (!$skip)
		$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc asAnalyzeChainJoints (string $firstJoint)
{
string $kids[]=`asListChildren $firstJoint`;
string $chainJoints[],$tempString[];
clear $chainJoints;
float $pos[3];
while(size($kids)==1)
	{
	if (size($chainJoints)==0)
		$chainJoints[size($chainJoints)]=$firstJoint;
	if (!`gmatch $kids[0] "*Part[0-9]*"`)
		$chainJoints[size($chainJoints)]=$kids[0];
	$tempString=`asListChildren $kids[0]`;
	clear $kids;
	for ($y=0;$y<size($tempString);$y++)
			$kids[size($kids)]=$tempString[$y];
	}

if (size($kids)>1)
	for ($y=0;$y<size($kids);$y++)
		asAnalyzeChainJoints $kids[$y];

if (size($chainJoints))
	if (!`objExists ($chainJoints[0]+"_middleCurve")`)
		asBuildChainCurves $chainJoints;
}

global proc asBuildChainCurves (string $chainJoints[])
{
asSetRefreshOptionVar;
int $childIsTwistJoint;
int $firstChildMinusX[],$spineJoint[],$terminator[],$topJoint[],$downTwist[],$upTwist[];
float $twistAmount;
float $charHeight=`asgetCharHeight`;
string $curve,$startCurve,$endCurve,$twistCurve,$surface,$poly,$parent,$parentChainJoint,$childChainJoint,$twistJoint,$skinToJoint;
string $tempString[],$tempString2[],$children[],$siblings[],$curves[],$startCurves[],$middleCurves[],$endCurves[],$twistCurves[];
float $scale;
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (`gmatch $chainJoints[$i] "Head_M"` || `gmatch $chainJoints[$i] "Hair_M"` || `gmatch $chainJoints[$i] "Root_M"` || `gmatch $chainJoints[$i] "Back?_M"` || `gmatch $chainJoints[$i] "Chest_M"` || `gmatch $chainJoints[$i] "Tail*_M"`)
		$spineJoint[$i]=1;
	$tempString=`asListChildren $chainJoints[$i]`;
	if (size($tempString))
		if (`getAttr ($tempString[0]+".tx")`<0)
			$firstChildMinusX[$i]=1;
	if (size($tempString)==0)
		$terminator[$i]=1;
	if (`asListParent $chainJoints[$i]`=="")
		$topJoint[$i]=1;
	}

//Middlecurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$middleCurve=$chainJoints[$i]+"_middleCurve";
	$middleCurves[size($middleCurves)]=$middleCurve;
	asCreateMeshCurve $middleCurve;
	$profileCurve=`substitute "Curve" $middleCurve "Profile"`;
	$scale=$charHeight/40;
	if (`gmatch $chainJoints[$i] "Wrist_*"`)
		$scale=$charHeight/80;
	if (`gmatch $chainJoints[$i] "Elbow_*"`)
		$scale=$charHeight/60;
	if (`gmatch $chainJoints[$i] "*Finger*"`)
		$scale=$charHeight/140;
	if ($spineJoint[$i])
		$scale=$charHeight/15;
	xform -os -s $scale $scale $scale $profileCurve;

	asAlign $profileCurve $chainJoints[$i] 1 1 0 0;
	if ($terminator[$i])
		asAlign $profileCurve `asListParent $chainJoints[$i]` 0 1 0 0;
	parent $profileCurve MeshCurves;
	editDisplayLayerMembers -noRecurse SkinCurves1 $profileCurve;
	if (`optionVar -q asRefresh`)
		refresh;
	}

//Twistcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$childIsTwistJoint=1;
	$joint=$chainJoints[$i];
	while($childIsTwistJoint)
		{
		$childIsTwistJoint=0;
		$tempString=`asListChildren $joint`;
		$twistJoint=$tempString[0];
		$joint=$twistJoint;
		if (`gmatch $joint "*Part[0-9]_*"`)
			$childIsTwistJoint=1;
		else
			break;
		if ($childIsTwistJoint)
			{
			$downTwist[$i]=$downTwist[$i]+1;
			$twistCurve=$chainJoints[$i]+"_twistCurve"+$downTwist[$i];
			$twistCurves[size($twistCurves)]=$twistCurve;
			asCreateMeshCurve $twistCurve;
			$profileCurve=`substitute "Curve" $twistCurve "Profile"`;
			createNode -n ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") transform;
			parent ($chainJoints[$i]+"_twistProfile"+$downTwist[$i]) ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			parent ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") MeshCurves;
			editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
			asAlign ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") $twistJoint 1 1 0 0;
			$twistAmount=`getAttr ($twistJoint+".twistAmount")`*0.8;
			pointConstraint -mo -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			pointConstraint -mo -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			}
		}
	if ($i>0 && $downTwist[$i-1])
		$upTwist[$i]=$downTwist[$i-1];
	}

//Startcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		$startCurve=$chainJoints[$i]+"_startCurve";
		$startCurves[size($startCurves)]=$startCurve;
		asCreateMeshCurve $startCurve;
		$profileCurve=`substitute "Curve" $startCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_startCurveOffset") transform;
		parent ($chainJoints[$i]+"_startProfile") ($chainJoints[$i]+"_startCurveOffset");
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_startCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		//first startCurve
		if ($i==0)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_startProfile.tx") 0.482;
			else
				setAttr ($chainJoints[$i]+"_startProfile.tx") -0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		if ($i>0)
			{
			pointConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			}
		}
	}

//Endcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		$endCurve=$chainJoints[$i]+"_endCurve";
		$endCurves[size($endCurves)]=$endCurve;
		asCreateMeshCurve $endCurve;
		$profileCurve=`substitute "Curve" $endCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_endCurveOffset") transform;
		parent ($chainJoints[$i]+"_endProfile") ($chainJoints[$i]+"_endCurveOffset");
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_endCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		//last endCurve
		if ($i==size($chainJoints)-1)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_endProfile.tx") -0.482;
			else
				setAttr ($chainJoints[$i]+"_endProfile.tx") 0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		if ($i<size($chainJoints)-1)
			{
			pointConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			}
		}
	}

for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_startCurve";
	$curves[size($curves)]=$chainJoints[$i]+"_middleCurve";
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_endCurve";
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		$curves[size($curves)]=$chainJoints[$i]+"_twistCurve"+$y;


	//branch
	$children=`asListChildren $chainJoints[$i]`;
	$tempString[0]=`asListParent $chainJoints[$i]`;
	$parent=$tempString[0];
	if ($parent!="")
		$siblings=`asListChildren $parent`;
	if (!(size($children)>1 || size($siblings)>1))
		continue;
	}

$surface=$chainJoints[0]+"_surface";
$poly=$chainJoints[0]+"_poly";
if (size($chainJoints)==1)
		extrude -n $surface -ch 1 -rn false -po 0 -et 0 -upn 1 -length ($charHeight/-250) -rotation 0 -scale 1 -dl 3 $curves;
else
	loft -n $surface -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true $curves;
parent $surface NurbsGeometry;
nurbsToPoly -n $poly -mnd 1 -ch 1 -f 3 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0 -es 0 -ntr 0 -mrt 0 -uss 1 $surface;
polySoftEdge -angle 0 -ch 1 $poly;
if (`gmatch $chainJoints[0] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $poly;
polyMergeVertex -d 0.01 -am 1 -ch 1 $poly;
//displaySmoothness -polygonObject 3;
duplicate -n ($poly+"_copy") $poly;
parent $poly MeshGeometry;

//Create SkinCluster
select $chainJoints;
//include parentJoint
$tempString=`listRelatives -type joint -p $chainJoints[0]`;
if (size($tempString))
	select -add $tempString[0];
//deselect endJoints
for ($i=0;$i<size($chainJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
	if (!`size($tempString)`)
		select -d $chainJoints[$i];
	}
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -type joint -c $tempString[$i]`;
	if (size($tempString2))
		select -add $tempString[$i];
	}
//include twistJoints
for ($i=0;$i<size($chainJoints);$i++)
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		select -add ($tempString[0]+"Part"+$y+"_"+$tempString[1]);
		}
//include 50`s
for ($i=0;$i<size($chainJoints);$i++)
	if (`objExists ($chainJoints[$i]+"_50")`)
		select -add ($chainJoints[$i]+"_50");
select -add $poly;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

float $temp[3];
int $vertIndex;
if (`objExists closestSampler`)
	delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($poly+"Shape.outMesh") closestSampler.inMesh;
$tempString=`listConnections ($poly+"Shape.inMesh")`;
string $skinCluster=$tempString[0];

//Skinning cylinders
for ($i=0;$i<size($chainJoints);$i++)
	{
	//Middlecurves
	for ($y=0;$y<4;$y++)
		{
		$temp=`xform -q -ws -t ($chainJoints[$i]+"_middleCurve.cv["+$y+"]")`;
		setAttr closestSampler.inPositionX $temp[0];
		setAttr closestSampler.inPositionY $temp[1];
		setAttr closestSampler.inPositionZ $temp[2];
		$vertIndex=`getAttr closestSampler.closestVertexIndex`;
		$skinToJoint=$chainJoints[$i];
		$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
		if (!`size($tempString)`)
			{
			$tempString2=`listRelatives -type joint -p $chainJoints[$i]`;
			if (`size($tempString2)`)
				$skinToJoint=$tempString2[0];
			}

		skinPercent -tv $skinToJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		$tempString=`listRelatives -type joint -p $chainJoints[$i]`;
		if (!$spineJoint[$i])
			if (size($tempString))
				if ($skinToJoint==$chainJoints[$i])
					skinPercent -tv $tempString[0] 0.5 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		if (`objExists ($chainJoints[$i]+"_50")`)
			skinPercent -tv ($chainJoints[$i]+"_50") 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
		}

	//Twistcurves
	for ($z=1;$z<$downTwist[$i]+1;$z++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$z+"_"+$tempString[1];
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_twistCurve"+$z+".cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $twistJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}

		}

	//Startcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$topJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_startCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			if ($i>0)
				skinPercent -tv $chainJoints[$i-1] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			else
				{
				$tempString=`listRelatives -type joint -p $chainJoints[0]`;
				skinPercent -tv $tempString[0] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
				}
			}
		}
	//Endcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_endCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $chainJoints[$i] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}
		}
	}
if (size($children)==0)
	{
	$endJoint=$chainJoints[size($chainJoints)-1];
	polyPlane -n ($endJoint+"_cap_copy") -w 1 -h 1 -sx 1 -sy 1 -ax 1 0 0 -cuv 2 -ch 0;
	if (`gmatch $endJoint "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($endJoint+"_cap_copy");
	setAttr -type float3 ($endJoint+"_cap_copy.s") ($scale*2*(1/1.2)) ($scale*2*(1/1.2)) ($scale*2*(1/1.2));
	asAlign ($endJoint+"_cap_copy") $endJoint 1 1 0 0;
	asAlign ($endJoint+"_cap_copy") `asListParent $endJoint` 0 1 0 0;
	}
}

global proc asCreateMeshCurve (string $curve)
{
$tempString[0]=`curve -d 1 -p 0 -1 1 -p 0 1 1 -p 0 1 -1 -p 0 -1 -1 -p 0 -1 1`;
rename $tempString[0] $curve;
reverseCurve -ch 0 -rpo 1 $curve;
$profileCurve=`substitute "Curve" $curve "Profile"`;
duplicate -n $profileCurve $curve;
sets -add SkinCageCurvesSet $profileCurve;
scale -r 1.2 1.2 1.2 $profileCurve;
parent $curve $profileCurve;
connectAttr ($profileCurve+".worldSpace[0]") ($curve+".create");
setAttr ($curve+".v") 0;
}

global proc asCreateBranchBoxes ()
{
//Branch
int $nonTerminatingBranch,$cv,$vertIndex,$divisionsZ,$edge1,$edge2;
int $spineJoint[],$firstChildMinusX[];
int $numFaces[];
float $charHeight=`asgetCharHeight`;
float $size,$degrees,$endCurveShift;
float $temp[3];
float $tzs[],$sortedTzs[];
string $parentMesh;
string $faceNormalInfo[],$children[],$sortedChildren[];
string $joints[]=`asListAllDecents DeformationSystem`;
string $tempString[],$tempString2[];

spaceLocator -n spaceSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ("spaceSamplerShape.worldPosition[0]") closestSampler.inPosition;
createNode -n spaceSamplerOffset transform;
parent spaceSampler spaceSamplerOffset;

for ($i=0;$i<size($joints);$i++)
	{
	if (!`objExists ($joints[$i]+"_middleCurve")`)
		continue;
	if (`gmatch $joints[$i] "Root_M"` || `gmatch $joints[$i] "Back?_M"` || `gmatch $joints[$i] "Chest_M"` || `gmatch $joints[$i] "Tail*_M"`)
		$spineJoint[$i]=1;
	$nonTerminatingBranch=0;
	clear $children;
	clear $sortedChildren;
	clear $tzs;
	clear $sortedTzs;
	$tempString=`asListChildren $joints[$i]`;
	$rootToFeet=0;
	if (`asListParent $joints[$i]`=="")
		{
		$rootToFeet=1;
		clear $tempString;
		$tempString2=`listRelatives -type joint -c $joints[$i]`;
		for ($y=0;$y<size($tempString2);$y++)
			if (!`gmatch $tempString2[$y] "BackA_M"`)
				$tempString[size($tempString)]=$tempString2[$y];
		}	

	if (size($tempString)>1)
		{
		for ($y=0;$y<size($tempString);$y++)
			{
			$tempString2=`asListChildren $tempString[$y]`;
			if (size($tempString2)>0)
				if (`objExists ($tempString[$y]+"_middleCurve")`)
					{
					$nonTerminatingBranch=1;
					$children[size($children)]=$tempString[$y];
					}
			}
		}

	//sorting children
	for ($y=0;$y<size($children);$y++)
		{
		$tempReparent=0;
		$tempString=`listRelatives -p $children[$y]`;
		if ($tempString[0]!=$joints[$i])
			{
			$tempReparent=1;
			parent $children[$y] $joints[$i];
			}
		$tzs[$y]=`getAttr ($children[$y]+".tz")`;
		if ($tempReparent)
			parent $children[$y] $tempString[0];
		}
	$sortedTzs=`sort ($tzs)`;
	for ($y=size($sortedTzs);$y>-1;$y--)
		for ($z=0;$z<size($tzs);$z++)
			if ($tzs[$z]==$sortedTzs[$y])
				if (!`gmatch $children[$z] "Thumb*"`)
					$sortedChildren[size($sortedChildren)]=$children[$z];
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "Thumb*"`)
			{
			if (`getAttr ($joints[$i]+".tx")`>0)
				$sortedChildren=`stringArrayCatenate $sortedChildren {$children[$y]}`;
			else
				$sortedChildren=`stringArrayCatenate {$children[$y]} $sortedChildren`;
			}

	if ($nonTerminatingBranch)
		{
		$size=0.5;
		if (`objExists ($joints[$i]+"_middleCurve")`)
			$size=`getAttr ($joints[$i]+"_middleProfile.sx")`/1.2;
		$divisionsZ=(size($children)*2)-1;
		polyCube -n ($joints[$i]+"_branch") -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz $divisionsZ -ax 0 1 0 -cuv 4 -ch 1;
		parent ($joints[$i]+"_branch") $joints[$i];
		$numFaces=`polyEvaluate -f ($joints[$i]+"_branch")`;
		select -cl;
		for ($y=0;$y<$numFaces[0];$y++)
			{
			$faceNormalInfo=`polyInfo -fn ($joints[$i]+"_branch.f["+$y+"]")`;
			if (`gmatch $faceNormalInfo[0] "* -1.000000 0.000000 0.000000*"`)
				select -add ($joints[$i]+"_branch.f["+$y+"]");
			}
		delete;

		if (`gmatch $joints[$i] "*_L"` || $rootToFeet)
			setAttr -type float3 ($joints[$i]+"_branch.t") -0.5 0 0;
		else
			setAttr -type float3 ($joints[$i]+"_branch.t") 0.5 0 0;
		if (`objExists ($joints[$i]+"_endCurve")`)
			{
			$tempString=`listRelatives -p ($joints[$i]+"_endProfile")`;
			parent ($joints[$i]+"_endProfile") $joints[$i];
			$endCurveShift=`getAttr ($joints[$i]+"_endProfile.tx")`;
			parent ($joints[$i]+"_endProfile") $tempString[0];
			move -r -ls -wd $endCurveShift 0 0 ($joints[$i]+"_branch");
			}

		setAttr -type float3 ($joints[$i]+"_branch.r") 0 0 0;
		if (`gmatch $joints[$i] "*_L"` || $rootToFeet)
			setAttr ($joints[$i]+"_branch.rz") 180;
		if (`objExists ($joints[$i]+"_middleCurve")`)
			setAttr -type float3 ($joints[$i]+"_branch.s") 1 ($size*2) ($size*2);

		parent ($joints[$i]+"_branch") MeshGeometry;
		makeIdentity -a 1 -t 1 -r 1 -s 1 ($joints[$i]+"_branch");

		//wrap into place
		$tempString=`wire -dds 0 0.001 -gw false -en 1.0 -ce 0.0 -li 0.0 ($joints[$i]+"_branch")`;
		$wrap=$tempString[0];
		$unit=($size*-2)/($divisionsZ+0.0);
		$aimFactor=1;
		if (`gmatch $joints[$i] "*_L"` || $rootToFeet)
			$aimFactor=-1;
		for ($y=0;$y<size($sortedChildren[$y]);$y++)
			{
			duplicate -n ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]) ($joints[$i]+"_middleCurve");
			scale -r 1 1 (1/($divisionsZ+0.0)) ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]);
			parent ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]) $joints[$i];
			setAttr -type float3 ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]+".t") $aimFactor 0 $size;

			if (`objExists ($joints[$i]+"_endCurve")`)
				move -r -ls -wd $endCurveShift 0 0 ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]);

			move -r -ls -wd 0 0 ($unit/2.0) ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]);

			if ($y>0)
				move -r -ls -wd 0 0 ($unit*2*$y) ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]);
			select -r ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]);
			select -add ($joints[$i]+"_branch");
			AddWire;
			setAttr ($wrap+".dropoffDistance["+$y+"]") 0.001;
			if (`objExists ($sortedChildren[$y]+"_startCurve")`)
				$tempString=`pointConstraint ($sortedChildren[$y]+"_startCurve") ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y])`;
			else
				$tempString=`pointConstraint ($sortedChildren[$y]+"_middleCurve") ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y])`;

			delete $tempString[0];
			scaleConstraint ($sortedChildren[$y]+"_middleCurve") ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]);
			$tempString=`asListChildren $sortedChildren[$y]`;
			if (size($tempString)==1)
				$tempString=`aimConstraint -offset 0 0 0 -weight 1 -aimVector $aimFactor 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $joints[$i] -worldUpVector 0 1 0 $tempString[0] ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y])`;
			else
				$tempString=`orientConstraint $sortedChildren[$y] ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y])`;
			delete $tempString[0];

			//snap any degrees that might be still off
			parent ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]) $sortedChildren[$y];
			$degrees=`getAttr ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]+".rx")`;
			if ($degrees>-225 && $degrees<-135) $degrees=-180;
			if ($degrees>-135 && $degrees<-45) $degrees=-90;
			if ($degrees>-45 && $degrees<45) $degrees=0;
			if ($degrees>45 && $degrees<135) $degrees=90;
			if ($degrees>135 && $degrees<225) $degrees=180;
			setAttr ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]+".rx") $degrees;
			parent ($joints[$i]+"_wrapCurve_"+$sortedChildren[$y]) MeshCurves;


			//remove `inside` faces
			asAlign spaceSamplerOffset $sortedChildren[$y] 1 1 0 0;
			setAttr -type float3 spaceSampler.t 0 0 0;
			parent spaceSampler ($sortedChildren[$y]+"_middleCurve");
			$tempString=`asListChildren $sortedChildren[$y]`;
			parent spaceSampler spaceSamplerOffset;
			if (`objExists ($sortedChildren[$y]+"_startCurve")`)
				{
				if (`gmatch $sortedChildren[$y] "*_L"`)
					setAttr spaceSampler.tx ($charHeight/342.857143);
				else
					setAttr spaceSampler.tx ($charHeight/-342.857143);
				}
			if ($y==0)
				connectAttr -f ($joints[$i]+"_branchShape.outMesh") closestSampler.inMesh;
			$faceIndex=`getAttr closestSampler.closestFaceIndex`;
			select ($joints[$i]+"_branchShape.f["+$faceIndex+"]");
			delete;
			}

		for ($frontBack=1;$frontBack>-2;$frontBack=$frontBack-2)
			{
			//merge loose verts
			if ($divisionsZ>1)
				{
				asAlign spaceSamplerOffset $joints[$i] 1 1 0 0;
				setAttr -type float3 spaceSampler.t $endCurveShift ($size*$frontBack) $size;
				select -cl;
				string $longName[]=`ls -l $joints[$i]`;
				tokenize $longName[0] "|" $tempString;
				$parentMesh="Root_M_poly_copy";
				for ($y=size($tempString);$y>-1;$y--)
					if (`objExists ($tempString[$y]+"_poly_copy")`)
						{
						$parentMesh=($tempString[$y]+"_poly_copy");
						break;
						}
				for ($y=0;$y<($divisionsZ-1);$y++)
					{
					move -r -ls -wd 0 0 (($size*-2)/($divisionsZ+0.0)) spaceSampler;
					$vertIndex=`getAttr closestSampler.closestVertexIndex`;
					select -add ($joints[$i]+"_branchShape.vtx["+$vertIndex+"]");
					}
				polyMergeVertex -d 999 -am 1 -ch 1;
				$tempString=`ls -sl`;
				$temp=`xform -q -ws -t`;
				xform -ws -t $temp[0] $temp[1] $temp[2] spaceSamplerOffset;
				setAttr -type float3 spaceSampler.t 0 0 0;
				connectAttr -f ($parentMesh+"Shape.outMesh") closestSampler.inMesh;
				}

			//get edge1
			$offset=`getAttr ($joints[$i]+"_middleProfile.sx")`*(1/1.2);
			setAttr "spaceSampler.translateZ" $offset;
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			select ($parentMesh+".vtx["+$vertIndex+"]");
			setAttr "spaceSampler.translateZ" ($offset*-1);
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			select -add ($parentMesh+".vtx["+$vertIndex+"]");
			ConvertSelectionToContainedEdges;
			$tempString=`ls -sl`;
			tokenize $tempString[0] "[" $tempString;
			$edge1=`substitute "]" $tempString[1] ""`;
			//get edge2
			setAttr "spaceSampler.translateZ" $offset;
			parent spaceSampler $joints[$i];
			$tempString=`listRelatives -type joint -p $joints[$i]`;
			if ($tempString[0]!="")
				parent spaceSampler $tempString[0];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			for ($y=0;$y<999;$y++)
				{
				if (`getAttr closestSampler.closestVertexIndex`!=$vertIndex)
					break;
				$vertIndex=`getAttr closestSampler.closestVertexIndex`;
				move -r -ls -wd (($charHeight/1205.0)*($aimFactor*-1)) 0 0 spaceSampler;
				if ($y==998)
					error "No luck";
				}
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			parent spaceSampler spaceSamplerOffset;
			select ($parentMesh+".vtx["+$vertIndex+"]");
			$temp=`xform -q -ws -t`;
			xform -ws -t $temp[0] $temp[1] $temp[2] spaceSampler;
			setAttr "spaceSampler.translateZ" ($offset*-1);
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			setAttr "spaceSampler.translateX" 0;
			select -add ($parentMesh+".vtx["+$vertIndex+"]");

			ConvertSelectionToContainedEdges;
			$tempString=`ls -sl`;
			tokenize $tempString[0] "[" $tempString;
			$edge2=`substitute "]" $tempString[1] ""`;
			polySplit -ch 1 -s 1 -sma 0 -ep $edge1 0.5 -ep $edge2 0.5 ($parentMesh+"Shape");
			if (!`isConnected ($joints[$i]+"_branchShape.outMesh") closestSampler.inMesh`)
				connectAttr -f ($joints[$i]+"_branchShape.outMesh") closestSampler.inMesh;
			}

		select ($joints[$i]+"_branch");
		DeleteHistory;
		duplicate -n ($joints[$i]+"_branch_copy") ($joints[$i]+"_branch");
		parent -w ($joints[$i]+"_branch_copy");
		delete ($joints[$i]+"_branch");

		}
	}
delete spaceSamplerOffset closestSampler;
}

global proc asCopySkin ()
{
asWarningIfNotInBuildPose;
if (!`objExists skinCage`)
	return;
string $sel[]=`ls -sl`;
int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 skinCage`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r skinCage ;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc asWarningIfNotInBuildPose ()
{
string $deformJointsList[]=`sets -q "DeformSet"`;
string $checkAttr[]={"rx","ry","rz","sx","sy","sz"};
float $checkValues[]={0,0,0,1,1,1};
for ($i=0;$i<size($deformJointsList);$i++)
	for ($y=0;$y<size($checkAttr);$y++)
		{
		$value=`getAttr ($deformJointsList[$i]+"."+$checkAttr[$y])`;
		if ($value>($checkValues[$y]+0.01) || $value<($checkValues[$y]-0.01))
			{
			warning ("Not in Build Pose, "+$deformJointsList[$i]+"."+$checkAttr[$y]+" = "+$value+" (should be zero)");
			return;
			}
		}
}

global proc asSmoothSkin ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
float $pos[];
string $tempString[];
string $smoothJoints[];
if (`objExists Head_M`)
	{
	$tempString=`listRelatives -p Head_M`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]_*"`)
		{
		$smoothJoints[size($smoothJoints)]=$parent;
		$tempString=`listRelatives -p $parent`;
		$parent=$tempString[0];
		}
	}
string $lookforJoints[]={"Root_M","Hip_R","Hip_L"};
for ($i=0;$i<size($lookforJoints);$i++)
if (`objExists $lookforJoints[$i]`)
	$smoothJoints[size($smoothJoints)]=$lookforJoints[$i];
string $skinCluster;
setToolTo $gSelect;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]` == "skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		error "Found no skinCluster on selected object";
	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Finding Vtx for smoothing" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		for ($z=0;$z<size($smoothJoints);$z++)
			{
			if (`progressBar -q -ic $gMainProgressBar`)
				{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
			if ($z==0)
				progressBar -e -s 1 $gMainProgressBar;
			$tempString=`skinPercent -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
			if (`stringArrayCount $smoothJoints[$z] $tempString`)
				{
				select -add ($sel[$i]+".vtx["+$y+"]");
				//middleVtx to root
				if (`gmatch $smoothJoints[$z] "*Root_M*"` || `gmatch $smoothJoints[$z] "*Hip_*"`)
					{
					$pos=`xform -q -ws -t ($sel[$i]+".vtx["+$y+"]")`;
					if ($pos[0]>($charHeight/-5000.0) && $pos[0]<($charHeight/5000.0))
						skinPercent -tv $smoothJoints[$z] 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
					}
				}
			}
		if (size(`ls -sl`))
			weightHammerVerts;
	}
progressBar -e -ep $gMainProgressBar;
}

global proc asDeleteSkinCurves ()
{
if (!`objExists skinCageShape` || !`objExists skinClusterSkinCage`)
	return;
setAttr skinClusterSkinCage.envelope 0;
duplicate -n asTempMesh skinCageShape;
setAttr skinClusterSkinCage.envelope 1;
string $deleteObjs[]={"SkinCurves1","SkinCurves2","MeshGeometry","MeshCurves","NurbsGeometry"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
string $tempString[]=`listRelatives -s -type mesh skinCage`;
for ($mesh in $tempString)
	if ($mesh!="skinCageShape")
		{
		connectAttr asTempMesh.outMesh ($mesh+".inMesh");
		evalDeferred -lp ("delete asTempMesh");
		break;
		}
}

global proc asCreatePolyBoxes ()
{
asWarningIfNotInBuildPose;
asSetRefreshOptionVar;

string $dialog=`confirmDialog -t "Box Option"
	-m "Keep Constuction History on Polygon Boxes?" -b "Keep History"
	-b "Discard History" -db "Discard History"
	-b "Cancel" -ds "Cancel"`;

if ($dialog=="Cancel")
	return;

if (!`gmatch "Keep History" $dialog`)
	$history=0;
else if (!`gmatch "Discard History" $dialog`)
	$history=1;

if (!`objExists "BoxesGeometry"`)
	{
	createNode -n "BoxesGeometry" transform;
	parent "BoxesGeometry" "Geometry";
	}
float $charHeight=`asgetCharHeight`;

string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];
string $polyCube,$childJoint,$upLoc;
float $lenght;
float $y,$z;
float $temp[];
int $sideFactor;
vector $childVec;
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (`objExists ($deformJointsList[$i]+"_Box")`)
		continue;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	if (!size($children))
		continue;
	$childJoint=$children[0];
	$lenght=`getAttr ($childJoint+".translateX")`;
	$tempString=`polyCube -n ($deformJointsList[$i]+"_Box") -ch $history -sx 1 -sy 1 -sz 1 -w 1 -h 1 -d 1`;
	$polyCube=$tempString[0];
	xform -ws -piv -0.5 0 0 $polyCube;
	xform -os -s ($lenght) ($charHeight/20) ($charHeight/20) $polyCube;
	parentConstraint $deformJointsList[$i] $polyCube;
	setAttr ($deformJointsList[$i]+"_Box.translateX") ($lenght/2);
	parent $polyCube "BoxesGeometry";
	asLockAttr ($deformJointsList[$i]+"_Box") 1 1 0 0;

	if (`optionVar -q asRefresh`)
		refresh;
	}
select -cl;
}

global proc asDeletePolyBoxes ()
{
if (`objExists "BoxesGeometry"`)
	delete "BoxesGeometry";
}

global proc asMirrorPolyBoxes (int $L2R)
{
asWarningIfNotInBuildPose;
string $allCyls[]=`listRelatives -type transform -c "BoxesGeometry"`;
string $matchBox;
float $scale[3],$pos[3];
int $vs[];
for ($i=0;$i<size($allCyls);$i++)
	{
	if ($L2R)
		$matchBox=`substitute "_L_Box" $allCyls[$i] "_R_Box"`;
	else
		$matchBox=`substitute "_R_Box" $allCyls[$i] "_L_Box"`;

	if ($allCyls[$i]==$matchBox || `gmatch $allCyls[$i] "*_M_Box"`)
		continue;

	if (!`objExists $matchBox`)
		continue;

	$scale=`getAttr ($allCyls[$i]+".scale")`;
	setAttr -type float3 ($matchBox+".scale") (-1*$scale[0]) $scale[1] $scale[2];
	$vs=`polyEvaluate -v $allCyls[$i]`;
	for ($y=0;$y<$vs[0];$y++)
		{
		$pos=`xform -q -ws -t ($allCyls[$i]+".vtx["+$y+"]")`;
		xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($matchBox+".vtx["+$y+"]");
		}
	}
}

global proc asDeleteBoolean ()
{
string $all[]=`ls -type transform "*Bool_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
}

global proc asDeleteWarp ()
{
string $all[]=`ls -type transform "*Warp*_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
}

global proc asCreateWarp ()
{
global string $gMainProgressBar;
asWarningIfNotInBuildPose;
asSetRefreshOptionVar;
optionVar -iv asRefresh 1;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	}
int $sideFactor,$isEndJoint,$divisions;
int $tempInt[];
float $pos[],$facePos[];
string $sel[]=`ls -sl`;
string $boxes[]=`listRelatives -type transform -c "BoxesGeometry"`;
string $tempString[];
string $wrapBox,$SG;
string $multiSGs[];
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
createNode -n closestSampler closestPointOnMesh;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -ni -s $sel[$i]`;
	string $meshNode=$tempString[0];
	$tempString=`listConnections ($tempString[0]+".instObjGroups")`;
	if ($tempString[0]!="")
		$SG=$tempString[0];
	else
		{
		//faceAssigned shaders
		for ($y=0;$y<`getAttr -s ($meshNode+".instObjGroups.objectGroups")`;$y++)
			{
			if($y==0)
				{
				//temp copy of mesh, so we can freeze xforms
				$tempString=`duplicate -n tempMesh $sel[$i]`;
				setAttr -l 0 tempMesh.tx;setAttr -l 0 tempMesh.ty;setAttr -l 0 tempMesh.tz;
				setAttr -l 0 tempMesh.rx;setAttr -l 0 tempMesh.ry;setAttr -l 0 tempMesh.rz;
				setAttr -l 0 tempMesh.sx;setAttr -l 0 tempMesh.sy;setAttr -l 0 tempMesh.sz;
				setAttr -l 0 tempMesh.v 0;
				parent -w tempMesh;
				makeIdentity -a 1 -t 1 -r 1 -s 1 tempMesh;
				connectAttr -f tempMesh.outMesh closestSampler.inMesh;
				}
			$tempString=`listConnections -type shadingEngine ($meshNode+".instObjGroups.objectGroups["+$y+"].objectGrpColor")`;
			if ($tempString[0]!="")
				$multiSGs[size($multiSGs)]=$tempString[0];
			}
		}
	progressBar -e -st ("Creating Warps for:"+$sel[$i]) -bp -ii 1 -min 0 -max (size($boxes)) $gMainProgressBar;
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;return;}
		progressBar -e -s 1 $gMainProgressBar;
		if (`gmatch $boxes[$y] "*_L_*"`)
			$sideFactor=-1;
		else
			$sideFactor=1;
		tokenize $boxes[$y] "_" $tempString;
		$joint=$tempString[0]+"_"+$tempString[1];
		for ($z=1;$z<99;$z++)
			if (!`objExists ($tempString[0]+"Warp"+$z+"_"+$tempString[1])`)
				break;
		$warpBox=$tempString[0]+"Warp"+$z+"_"+$tempString[1];
		$isEndJoint=0;
		$tempString=`listRelatives -type joint -c $joint`;
		if (!size($tempString))
			$isEndJoint=1;
		else if (!`sets -im DeformSet $tempString[0]`)
			$isEndJoint=1;			
		duplicate -n $warpBox $boxes[$y];
		setAttr -k 1 -l 0 ($warpBox+".tx");setAttr -k 1 -l 0 ($warpBox+".ty");setAttr -k 1 -l 0 ($warpBox+".tz");
		setAttr -k 1 -l 0 ($warpBox+".rx");setAttr -k 1 -l 0 ($warpBox+".ry");setAttr -k 1 -l 0 ($warpBox+".rz");
		parent $warpBox	$joint;
		$divisions=2;
		if ($joint=="Head_M")
			$divisions=4;
		catch (`polySmooth -mth 0 -dv $divisions -bnr 1 -c 1 -kb 1 -ksb 1 -khe 1 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $warpBox`);
		scale -r -ocp 1 0.7 0.7 ($warpBox+".e[0:15]");
		scale -r -ocp 1 0.9 0.9 ($warpBox+".vtx[34:50]") ($warpBox+".vtx[52]") ($warpBox+".vtx[54]") ($warpBox+".vtx[56]") ($warpBox+".vtx[58]") ($warpBox+".vtx[60]") ($warpBox+".vtx[62]") ($warpBox+".vtx[64]") ($warpBox+".vtx[74:89]");
		select $sel[$i];
		select -add $warpBox;
		transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;
		select $warpBox;
		DeleteHistory;
		//round ends
		select ($warpBox+".vtx[25]") ($warpBox+".vtx[70:73]") ($warpBox+".vtx[94:97]");
		polyAverageVertex -i 10 -ch 0;polyAverageVertex -i 10 -ch 0;
		if (!`gmatch $warpBox "Ankle*"`)
			move -r -os -wd (`getAttr ($warpBox+".sz")`*-0.5*$sideFactor) 0 0 ;
		polyAverageVertex -i 10 -ch 0;
		select ($warpBox+".vtx[24]") ($warpBox+".vtx[66:69]") ($warpBox+".vtx[90:93]");
		polyAverageVertex -i 10 -ch 0;polyAverageVertex -i 10 -ch 0;
		if (!`gmatch $warpBox "Ankle*"` && !$isEndJoint)
			move -r -os -wd (`getAttr ($warpBox+".sz")`*0.5*$sideFactor) 0 0 ;
		polyAverageVertex -i 10 -ch 0;

		if (size($multiSGs))
			{
			$tempInt=`polyEvaluate -f $warpBox`;
			for ($z=0;$z<$tempInt[0];$z++)
				{
				if (`progressBar -q -ic $gMainProgressBar`)
					{progressBar -e -ep $gMainProgressBar;return;}
				$pos=`xform -q -ws -t ($warpBox+".f["+$z+"]")`;
				$facePos[0]=$facePos[1]=$facePos[2]=0;
				for ($a=0;$a<size($pos);$a=$a+3)
					{$facePos[0]+=$pos[$a];$facePos[1]+=$pos[$a+1];$facePos[2]+=$pos[$a+2];}
				$facePos[0]/=(size($pos)/3);$facePos[1]/=(size($pos)/3);$facePos[2]/=(size($pos)/3);
				setAttr closestSampler.inPosition $facePos[0] $facePos[1] $facePos[2];
				int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
				for ($a=0;$a<size($multiSGs);$a++)
					if (`sets -im $multiSGs[$a] ($sel[$i]+".f["+$closestFaceIndex+"]")`)
						sets -e -forceElement $multiSGs[$a] ($warpBox+".f["+$z+"]");
				}

			}
		else
			{
			$tempString=`listRelatives -ni -s $warpBox`;
			sets -e -forceElement $SG $tempString[0];
			}

		if (`optionVar -q asRefresh`)
			refresh;
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
progressBar -e -ep $gMainProgressBar;
}

global proc asCreateBoolean ()
{
global string $gMainProgressBar;
asWarningIfNotInBuildPose;
asSetRefreshOptionVar;
optionVar -iv asRefresh 1;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	}
string $dialog=`confirmDialog -t "Boolean"
	-m "Attempt to Boolean selected geometry with PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "BoxesGeometry"`)
	error "No BoxesGeometry in scene !";
string $boxes[]=`listRelatives -type transform -c "BoxesGeometry"`;

string $objs[]=`ls -sl`;
if (size($objs)<1)
	error "No Objects Selected !";
dgdirty -a;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Creating Booleans" -bp -ii 1 -min 0 -max (size($objs)) $gMainProgressBar;
int $vs[];
string $tempString[];
string $dupObj,$dupBox,$joint,$puppet;
for ($i=0;$i<size($objs);$i++)
{
for ($y=0;$y<size($boxes);$y++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;break;}
	tokenize $boxes[$y] "_" $tempString;
	$joint=$tempString[0]+"_"+$tempString[1];
	if (`objExists ($tempString[0]+"Bool"+"_"+$tempString[1])`)
		warning ("Object \""+$tempString[0]+"Bool"+"_"+$tempString[1]+"\" Already exists...\n");
	$bool=`createNode -n ($tempString[0]+"Bool"+"_"+$tempString[1]) transform`;
	delete $bool;
	$dupObj=$objs[$i]+"_"+$boxes[$y];
	duplicate -n $dupObj $objs[$i];
	$tempString=`listRelatives -p $dupObj`;
	if ($tempString[0]!="")
		parent -w $dupObj;
	setAttr ($dupObj+".visibility") 0;
	$dupBox=$objs[$i]+"_"+$boxes[$y]+"Box";
	duplicate -n $dupBox $boxes[$y];
	parent -w $dupBox;
	select -r $dupObj $dupBox;
	refresh;
	$tempString=`polyBoolOp -n $dupObj -op 3 -ch 0 $dupObj $dupBox`;
	if (`objExists $dupObj`) delete $dupObj;
	if (`objExists $dupBox`) delete $dupBox;
	rename $tempString[0] $bool;
	$vs=`polyEvaluate -v $bool`;
	if (!$vs[0])
		delete  $bool;
	else
		parent $bool $joint;
	}
}
progressBar -e -ep $gMainProgressBar;
}

global proc asCreateBevel ()
{
asSetRefreshOptionVar;

string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[];
string $bool;
int $face,$secondFace,$numFaces,$numTri,$highestNumTri,$secondHighestNumTri,$terminator;
int $tempInts[];
float $temp[];
float $area;
select -cl;
for ($i=0;$i<size($deformJointsList);$i++)
	{
	tokenize $deformJointsList[$i] "_" $tempString;
	$bool=$tempString[0]+"Bool_"+$tempString[1];
	if (!`objExists $bool`)
		continue;

	$terminator=1;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`sets -im DeformSet $tempString[$y]`)
			$terminator=0;

	$tempInts=`polyEvaluate -f $bool`;
	$numFaces=$tempInts[0];
	$face=$secondFace=0;
	$highestNumTri=$secondHighestNumTri=0;
	for ($y=0;$y<$numFaces;$y++)
		{
		select ($bool+".f["+$y+"]");
		$tempInts=`polyEvaluate -tc`;
		$numTri=$tempInts[0];
		if ($numTri>$highestNumTri)
			{
			$secondFace=$face;
			$secondHighestNumTri=$highestNumTri;
			$face=$y;
			$highestNumTri=$numTri;
			}
		else if ($numTri>$secondHighestNumTri)
			{
			$secondFace=$y;
			$secondHighestNumTri=$numTri;
			}
		}


	if ($highestNumTri<10)
		continue;

	asExtrudeFace $bool $face 0.25 0.92;
	asExtrudeFace $bool $face 0.12 0.72;
	asExtrudeFace $bool $face 0.08 0.1;

//print ($bool+":"+$face+":"+$secondFace+":"+$highestNumTri+":"+$secondHighestNumTri+":"+$area+":"+(sqrt($area)/4)+"\n");

	if ($terminator || $secondHighestNumTri<10)
		continue;

	asExtrudeFace $bool $secondFace 0.25 0.92;
	asExtrudeFace $bool $secondFace 0.12 0.72;
	asExtrudeFace $bool $secondFace 0.08 0.1;

	if (`optionVar -q asRefresh`)
		refresh;
	}
select -cl;
select `ls -type transform "*BoolBevel*"`;
}

global proc asExtrudeFace (string $bool, int $face, float $distanceFactor, float $scale)
{
string $sel[]=`ls -sl`;
string $tempString[];
tokenize $bool "_" $tempString;
string $boolBevel=$tempString[0]+"Bevel"+$face+"_"+$tempString[1];

if (`objExists $boolBevel`)
	$face=0;
else
	{
	duplicate -n $boolBevel $bool;
	select ($boolBevel+".f[0:999]");
	select -d ($boolBevel+".f["+$face+"]");
	delete;
	select $boolBevel;
	CenterPivot;
	}
float $temp[]=`polyEvaluate -wa $boolBevel`;
float $area=$temp[0];
//delete $tempString[0];

$tempString=`polyExtrudeFacet -constructionHistory 1 -keepFacesTogether 1 -divisions 1 -twist 0 -taper 1 -off 0 -smoothingAngle 180 ($boolBevel+".f[0]")`;
setAttr ($tempString[0]+".localTranslateZ") (sqrt($area)*$distanceFactor);
setAttr -type float3 ($tempString[0]+".localScale") $scale $scale $scale;
select $boolBevel;
DeleteHistory;
select $sel;
}

global proc asDeleteBevel ()
{
string $all[]=`ls -type transform "*BoolBevel*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
}

global proc asMirrorBevelScale (int $L2R)
{
string $bevels[]=`ls -type transform "*BoolBevel*"`;
string $matchBevel;
float $scale[3],$pos[3];
int $vs[];
for ($i=0;$i<size($bevels);$i++)
	{
	if ($L2R)
		$matchBevel=`substitute "_L" $bevels[$i] "_R"`;
	else
		$matchBevel=`substitute "_R" $bevels[$i] "_L"`;

	if ($bevels[$i]==$matchBevel || `gmatch $bevels[$i] "*_M"`)
		continue;

	if (`objExists $matchBevel`)
		print ("Mirror "+$bevels[$i]+" -> "+$matchBevel+"\n");
	else
		continue;

	$scale=`getAttr ($bevels[$i]+".s")`;
	setAttr -type float3 ($matchBevel+".s") $scale[0] $scale[1] $scale[2];
	}
}

global proc asCreateNurbsCylinders ()
{
asSetRefreshOptionVar;

string $dialog=`confirmDialog -t "Cylinders Option"
	-m "Keep Constuction History on Nurbs Cylinders?" -b "Keep History"
	-b "Discard History" -db "Discard History"
	-b "Cancel" -ds "Cancel"`;

if ($dialog=="Cancel")
	return;

if (!`gmatch "Keep History" $dialog`)
	$history=0;
else if (!`gmatch "Discard History" $dialog`)
	$history=1;

if (!`attributeExists cylVis Main`)
	{
	addAttr -ln cylVis -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.cylVis;
	}

string $shaders[]={"CylindersFK","CylindersIK","CylindersFKIK","CylindersCenter","CylindersAim"};
for ($i=0;$i<size($shaders);$i++)
	{
	if (`objExists $shaders[$i]`)
		delete $shaders[$i];
	if (`objExists ($shaders[$i]+"SG")`)
		delete ($shaders[$i]+"SG");

	shadingNode -n $shaders[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($shaders[$i]+"SG");
	connectAttr -f ($shaders[$i]+".outColor") ($shaders[$i]+"SG.surfaceShader");
	}
setAttr CylindersFK.transparency -type double3 1 1 1;
setAttr CylindersIK.color -type double3 1 0 0;
setAttr CylindersFKIK.color -type double3 0 0 1;
setAttr CylindersCenter.color -type double3 0.75 0.85 1;
setAttr CylindersAim.color -type double3 0 1 0;

float $charHeight=`asgetCharHeight`;

string $allSetMembers[]=`sets -q "AllSet"`;
string $tempString[],$children[];
string $cyl,$ctrlType,$fkJoint,$fkControl,$deformJoint,$childJoint,$upLoc;
float $lenght;
float $y,$z;
float $temp[];
int $sideFactor;
vector $childVec;
for ($i=0;$i<size($allSetMembers);$i++)
	{
	if (`gmatch $allSetMembers[$i] "FKX*"`)
		$ctrlType="FK";
	else if (`gmatch $allSetMembers[$i] "IK*"` && `sets -im ControlSet $allSetMembers[$i]` && !`gmatch $allSetMembers[$i] "IKExtra*"`)
		$ctrlType="IK";
	else if (`gmatch $allSetMembers[$i] "Pole*"` && `sets -im ControlSet $allSetMembers[$i]` && !`gmatch $allSetMembers[$i] "PoleExtra*"`)
		$ctrlType="IK";
	else if (`gmatch $allSetMembers[$i] "FKIK*"` && `sets -im ControlSet $allSetMembers[$i]`)
		$ctrlType="FKIK";
	else if (`gmatch $allSetMembers[$i] "Center*"` && `sets -im ControlSet $allSetMembers[$i]` && !`gmatch $allSetMembers[$i] "CenterExtra*"`)
		$ctrlType="Center";
	else if (`gmatch $allSetMembers[$i] "Main*"` && `sets -im ControlSet $allSetMembers[$i]`)
		$ctrlType="Center";
	else if (`gmatch $allSetMembers[$i] "Fingers*"` && `sets -im ControlSet $allSetMembers[$i]`)
		$ctrlType="Center";
	else if (`gmatch $allSetMembers[$i] "HipSwinger*"` && `sets -im ControlSet $allSetMembers[$i]` && !`gmatch $allSetMembers[$i] "HipSwingerExtra*"`)
		$ctrlType="Center";
	else if (`gmatch $allSetMembers[$i] "Aim*"` && `sets -im ControlSet $allSetMembers[$i]` && !`gmatch $allSetMembers[$i] "AimExtra*"`)
		$ctrlType="Aim";
	else
		continue;
	if ($ctrlType=="FK")
		{
		$fkJoint=$allSetMembers[$i];
		$fkControl=`substitute "FKX" $fkJoint "FK"`;
		$deformJoint=`substitute "FKX" $fkJoint ""`;
		if (!`objExists $deformJoint`)
			continue;
		if (`objExists ($fkJoint+"_Cyl")`)
			continue;
		if (`gmatch $fkJoint "*_L"`)
			$sideFactor=-1;
		else
			$sideFactor=1;
		$children=`listRelatives -c -type joint $fkJoint`;
		if (!size($children))
			$children=`listRelatives -c -type joint $deformJoint`;
		if (!size($children))
			continue;
		$childJoint=$children[0];
		$lenght=`getAttr ($childJoint+".translateX")`;
		}
	if ($ctrlType=="IK")
		{
		$fkJoint=$fkControl=$allSetMembers[$i];
		$lenght=$charHeight;
		$tempString=`sphere -n ($fkJoint+"_Cyl") -ch $history -p 0 0 0 -ax 1 0 0 -ssw 0 -esw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 2`;
		$cyl=$tempString[0];
		if (`gmatch $fkJoint "IKLeg_*"`)
			xform -os -s ($charHeight/200) ($charHeight/15) ($charHeight/15) $cyl;
		else
			{
			xform -os -s ($charHeight/200) ($charHeight/200) ($charHeight/15) $cyl;
			$tempString=`sphere -n ($fkJoint+"_Cyl1") -ch $history -p 0 0 0 -ax 1 0 0 -ssw 0 -esw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 2`;
			xform -os -s ($charHeight/200) ($charHeight/15) ($charHeight/200) ($fkJoint+"_Cyl1");
			rename ($fkJoint+"_Cyl1Shape") ($fkJoint+"_CylShape1");
			makeIdentity -a 1 -t 1 -r 1 -s 1 ($fkJoint+"_Cyl");
			makeIdentity -a 1 -t 1 -r 1 -s 1 ($fkJoint+"_Cyl1");
			parent -r -s ($fkJoint+"_CylShape1") $cyl;
			delete $tempString[0];select $cyl;
			}
		if (`gmatch $fkJoint "IKSpine[0-9]_*"`)
			xform -os -s ($charHeight/6) ($charHeight/6) ($charHeight/6) $cyl;
		if (`gmatch $fkJoint "Pole*"`)
			xform -os -s 0.5 0.5 0.5 $cyl;

		$size=`size($fkJoint)`;
		$IK=`substring $fkJoint 3 ($size-2)`;
		$orientTo=`substitute "IK" $fkJoint "IKEndJointOrientTo"`;
		if (`gmatch $fkJoint "*[0-9]_*"`)
			$orientTo=`substitute "[0-9]" $orientTo ""`;
		if (`objExists $orientTo`)
			asAlign $cyl $orientTo 0 1 0 0;			
		}

	else if ($ctrlType=="Center" || $ctrlType=="Aim" || $ctrlType=="FKIK")
		{
		$fkJoint=$fkControl=$allSetMembers[$i];
		circle -n tmpCircle -c 0 0 0 -nr 1 0 0 -sw 360 -r ($charHeight/200) -d 3 -ut 0 -tol 1e-006 -s 8 -ch 0;
		$tempString=`extrude -n ($fkJoint+"_Cyl") -ch 0 -rn false -po 0 -et 1 -ucp 1 -fpt 1 -upn 0 -rotation 0 -scale 1 -rsp 1 tmpCircle ($fkJoint+"Shape")`;
		$cyl=$tempString[0];if ($ctrlType=="FKIK");
		delete tmpCircle;
		}
	else
		{
		$tempString=`cylinder -n ($fkJoint+"_Cyl") -ch $history -p 0 0 0 -ax 1 0 0 -ssw 0 -esw 360 -r 0.5 -hr 2 -d 3 -ut 0 -tol 0.01 -s 1 -nsp 1`;
		$cyl=$tempString[0];
		}
	setAttr -l 1 ($cyl+"Shape.curvePrecision");
	setAttr -l 1 ($cyl+"Shape.curvePrecisionShaded");
	setAttr -l 1 ($cyl+"Shape.simplifyMode");
	setAttr -l 1 ($cyl+"Shape.simplifyU");
	setAttr -l 1 ($cyl+"Shape.simplifyV");
	setAttr -l 1 ($cyl+"Shape.divisionsU");
	setAttr -l 1 ($cyl+"Shape.divisionsV");
	if ($ctrlType=="FK")
		{
		xform -ws -piv -0.5 0 0 $cyl;
		xform -os -s ($lenght) ($charHeight/20) ($charHeight/20) $cyl;
		}
	if ($ctrlType=="IK")
		$tempString=`pointConstraint $fkJoint $cyl`;
	else if ($ctrlType=="Center" || $ctrlType=="Aim" || $ctrlType=="FKIK")
		$tempString=`pointConstraint -mo $fkJoint $cyl`;
	else 
		$tempString=`parentConstraint $fkJoint $cyl`;
	dgdirty ($fkJoint+"_Cyl");
	delete $tempString;
	if (`gmatch $fkJoint "IKLeg_*"`)
		setAttr ($fkJoint+"_Cyl.ty") 0;
	parent ($fkJoint+"_Cyl") $fkControl;
	if (`getAttr ($fkJoint+"_Cyl.sz")`<0)
		setAttr ($fkJoint+"_Cyl.sz") (`getAttr ($fkJoint+"_Cyl.sz")`*-1);

	makeIdentity -a 1 -t 1 -r 1 -s 1 ($fkJoint+"_Cyl");
	$tempString=`listRelatives -s ($fkJoint+"_Cyl")`;
	connectAttr Main.cylVis ($tempString[0]+".v");
	parent -r -s $tempString[0] $fkControl;
	delete ($fkJoint+"_Cyl");


	if ($ctrlType=="FK")
		sets -e -forceElement CylindersFKSG;
	if ($ctrlType=="IK")
		sets -e -forceElement CylindersIKSG;
	if ($ctrlType=="FKIK")
		sets -e -forceElement CylindersFKIKSG;
	if ($ctrlType=="Center")
		sets -e -forceElement CylindersCenterSG;
	if ($ctrlType=="Aim")
		sets -e -forceElement CylindersAimSG;

	if (`optionVar -q asRefresh`)
		refresh;
	}
select -cl;
}

global proc asDeleteNurbsCylinders ()
{
string $cylinders[]=`ls -type nurbsSurface "*_CylShape*"`;
if (size($cylinders))
	delete $cylinders;
}

global proc asMirrorNurbsCylinders (int $L2R)
{
string $cylinders[]=`ls -type nurbsSurface "*_CylShape*"`;
string $matchCyl;
float $scale[3],$pos[3];
int $vs[];
for ($i=0;$i<size($cylinders);$i++)
	{
	if ($L2R)
		$matchCyl=`substitute "_L_Cyl" $cylinders[$i] "_R_Cyl"`;
	else
		$matchCyl=`substitute "_R_Cyl" $cylinders[$i] "_L_Cyl"`;

	if ($cylinders[$i]==$matchCyl || `gmatch $cylinders[$i] "*_M_Cyl"`)
		continue;

	for ($y=0;$y<4;$y++)
		for ($z=0;$z<8;$z++)
			{
			$pos=`xform -q -ws -t ($cylinders[$i]+".cv["+$y+"]["+$z+"]")`;
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($matchCyl+".cv["+$y+"]["+$z+"]");
			}
	}
}

global proc asCreatecharacter () 
{
string $sel[]=`ls -sl`;
select -cl;

string $controlObjects[]=`sets -q "ControlSet"`;
string $chacterSetName=`textFieldGrp -q -tx "ASCharNodeName"`;

for ($i=0;$i<`size ($controlObjects)`;$i++)
	select -add $controlObjects[$i];
string $characterNode=`character -name $chacterSetName` ;
print ("Character \""+$characterNode+"\" was created\n");
}

global proc asKillcharacter () 
{
string $chacterSetName=`textFieldGrp -q -tx "ASCharNodeName"`;
if (!`objExists $chacterSetName`)
	{
	warning ("CharacterNode \""+$chacterSetName+"\" does not exists\n");
	return;
	}

string $schedule=`character -q -sc $chacterSetName`;
if ($schedule=="")
	delete $chacterSetName;
else
	{
	int $clipIndex;
	int $numData;
	string $Data[];
	string $flag="";
	string $clips[]=`clipSchedule -q -ci $schedule`;
	for ($i=0;$i<size ($clips);$i++)
		{
		clear $Data;
		$numData=`tokenize $clips[$i] "," $Data`;
		$clipIndex=$Data[1];
		$flag=$flag+" -ci "+$clipIndex;
		}
		
	if (`size ($clips)`<1)
		warning "Character has no clips\n";
	else
		{
		$bakeCmd="bakeClip"+$flag+" -name \"killingCharacter\" "+$chacterSetName; 
		eval ($bakeCmd);
		clip -e -active "killingCharacter" $chacterSetName;
		delete "killingCharacter" $chacterSetName;
		print "Character was killed\n";
		}
	}
}

global proc asScaleControlCurves ()
{
float $scale=`floatField -q -v ScaleCCFloatField`;
string $controlObjects[]=`sets -q "ControlSet"`;
string $controlCurves[];
string $tempString[];
for ($i=0;$i<size($controlObjects);$i++)
	{
	$tempString=`listRelatives -s $controlObjects[$i]`;
	if (!size($tempString))
		continue;
	select -cl;
	refresh;
	for ($y=0;$y<100;$y++)
		select -add ($tempString[0]+".cv["+$y+"]");
	scale -r $scale $scale $scale;
	}
select -cl;
}

global proc asMirrorControlCurves (int $L2R, string $set)
{
asWarningIfNotInBuildPose;
string $sel[]=`ls -sl`;
string $controlObjects[]=`sets -q $set`;
string $shapes[];
string $oppositeShape,$oppositeControlObject;
float $pos[];
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($controlObjects);$i++)
	{
	$shapes=`listRelatives -s $controlObjects[$i]`;
	if ($shapes[0]=="")
		continue;
	$objType=`objectType $shapes[0]`;
	if ($objType!="nurbsCurve")
		continue;

	if ($L2R)
		{
		if (!`gmatch $shapes[0] "*_L*"`)
			continue;
		}
	else
		{
		if (!`gmatch $shapes[0] "*_R*"`)
			continue;
		}

	if ($L2R)
		{
		$oppositeShape=`substitute "_L" $shapes[0] "_R"`;
		$oppositeControlObject=`substitute "_L" $controlObjects[$i] "_R"`;
		}
	else
		{
		$oppositeShape=`substitute "_R" $shapes[0] "_L"`;
		$oppositeControlObject=`substitute "_R" $controlObjects[$i] "_L"`;
		}

	if (!`objExists $oppositeShape`)
		continue;

	$form=`getAttr ($shapes[0]+".form")`;
	$spans=`getAttr ($shapes[0]+".spans")`;
	$degrees=`getAttr ($shapes[0]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;

	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($shapes[0]+".cv["+$y+"]")`;
		if ($y==0)	$z=2;
		if ($y==1)	$z=3;
		if ($y==2)	$z=0;
		if ($y==3)	$z=1;
		if ($y==4)	$z=2;
		if ($set=="SkinCageCurvesSet")
			{
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$z+"]");
			if ($y==2)
				xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv[4]");
			}
		else
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$y+"]");
		}

	//Mirror slideJoints
	if ($set=="SkinCageCurvesSet")
		{
		string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $controlObjects[$i]`;
		int $haveSliderJoint[4];
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
				$haveSliderJoint[$y]=1;
			else
				$haveSliderJoint[$y]=0;
		if ($haveSliderJoint[0] || $haveSliderJoint[1] || $haveSliderJoint[2] || $haveSliderJoint[3])
			{
			select $oppositeControlObject;
			asCreateSliders;
			//mirror .slide values
			for ($y=0;$y<4;$y++)
				{
				string $sliderJoint=$skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y;
				string $oppositeSliderJoint;
				if ($L2R) $oppositeSliderJoint=`substitute "_L" $sliderJoint "_R"`;
				else $oppositeSliderJoint=`substitute "_R" $sliderJoint "_L"`;
				if ($y==0) $oppositeSliderJoint=`substitute "0" $oppositeSliderJoint "2"`;
				if ($y==1) $oppositeSliderJoint=`substitute "1" $oppositeSliderJoint "3"`;
				if ($y==2) $oppositeSliderJoint=`substitute "2" $oppositeSliderJoint "0"`;
				if ($y==3) $oppositeSliderJoint=`substitute "3" $oppositeSliderJoint "1"`;
				if (`objExists $sliderJoint` && `objExists $oppositeSliderJoint`)
					setAttr ($oppositeSliderJoint+".slide") `getAttr ($sliderJoint+".slide")`;
				}
			}
		else // sliders might have been deleted, this should also mirror
			{
			string $oppositeSkinCurveSliderInfo[]=`asSkinCurveSliderInfo $oppositeControlObject`;
			int $oppositeHaveSliderJoint[4];
			for ($y=0;$y<4;$y++)
				if (`objExists ($oppositeSkinCurveSliderInfo[0]+"_"+$oppositeSkinCurveSliderInfo[1]+"Slider"+$y)`)
					$oppositeHaveSliderJoint[$y]=1;
			if ($oppositeHaveSliderJoint[0] || $oppositeHaveSliderJoint[1] || $oppositeHaveSliderJoint[2] || $oppositeHaveSliderJoint[3])
				{
				select $oppositeControlObject;
				asDeleteSliders;
				}
			}
		}
	}
select $sel;
}

global proc string[] asSkinCurveSliderInfo (string $skinCurve)
{
string $info[];//[0]=$deformJoint [1]=start/middle/end [2]=restoreWeightsToJoint
string $childJoint;
string $tempString[];
tokenize $skinCurve "_" $tempString;
string $deformJoint=$tempString[0]+"_"+$tempString[1];
$info[0]=$deformJoint;
if (`gmatch $skinCurve "*_middleProfile"`)
	$info[1]="middle";
if (`gmatch $skinCurve "*_startProfile"`)
	$info[1]="start";
if (`gmatch $skinCurve "*_endProfile"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile1"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile[2-9]"`)
	{
	//First some traversing to find the childJoint
	$tempString=`listRelatives -c -type joint $deformJoint`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
		if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
		}
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -c -type joint $childJoint`;
		$childJoint="";
		for ($i=0;$i<size($tempString);$i++)
			{
			if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
			if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
			}
		}
	//Then see if it`s the lastTwister
	int $stringLenght=`size $skinCurve`;
	int $twistNr=`substring $skinCurve $stringLenght $stringLenght`;
	string $nextTwistProfile=`substring $skinCurve 1 ($stringLenght-1)`+($twistNr+1);
	if (!`objExists $nextTwistProfile`)
		{
		$info[0]=$childJoint;
		$info[1]="start";
		}
	}
//[2]=restoreWeightsToJoint
if (`gmatch $skinCurve "*_twistProfile1"`)
	{
	tokenize $skinCurve "_" $tempString;
	string $twistJoint=$tempString[0]+"Part1_"+$tempString[1];
	if (`objExists $twistJoint`)
		$info[2]=$twistJoint;
	else
		$info[2]=$info[0];
	}
else
	{
	$tempString=`listRelatives -p $info[0]`;
	if (`gmatch $skinCurve "*_endProfile"`)
		$info[2]=$info[0];
	else
		$info[2]=$tempString[0];
	}
return $info;
}

global proc float snapAngle (float $value)
{
float $rad=`deg_to_rad $value`;
float $sin=`sin($rad)`;
float $result=0;
if (`abs $sin`>0.7071)
	$result=90;
return $result;
}

global proc asSetAllFK ()
{
string $controlSetMembers[]=`sets -q ControlSet`;
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".FKIKBlend") 0;
}

global proc asLimitElbowsKnees (string $armLeg, int $onOff)
{
string $side,$hip,$effector;
string $tempString[];
float $currentAngleY,$currentAngleZ;
int $abort;
for ($i=0;$i<3;$i++)
	{
	if ($i==1)
		$side="_R";
	if ($i==2)
		$side="_L";
	$controlCurve="FKIK"+$armLeg+$side;
	if (!`objExists $controlCurve`)
		continue;
	$startJoint=`getAttr ($controlCurve+".startJoint")`;
	$middleJoint=`getAttr ($controlCurve+".middleJoint")`;
	if ($armLeg=="Arm")
		$Axis="Y";
	else
		$Axis="Z";
	$axis=`tolower $Axis`;
	$currentAngle=`getAttr ($middleJoint+$side+".rotate"+$Axis)`;
	evalEcho ("transformLimits -r"+$axis+" "+$currentAngle+" 180 -er"+$axis+" "+$onOff+" "+$onOff+" "+$middleJoint+$side);
	evalEcho ("transformLimits -r"+$axis+" "+$currentAngle+" 180 -er"+$axis+" "+$onOff+" "+$onOff+" IKX"+$middleJoint+$side);
	evalEcho ("transformLimits -r"+$axis+" "+$currentAngle+" 180 -er"+$axis+" "+$onOff+" "+$onOff+" FK"+$middleJoint+$side);
	}
dgdirty -a;
}

global proc asCreateMoCap ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
if (`objExists "MoCap"`)
	error "MoCap skeleton already exists !";
if (!`objExists "Main"`)
	error "No AdvancedSKeleton In Scene!";
string $deformJoints[]=`listRelatives -type joint -ad "DeformationSystem"`;
string $keyDeformJoints[],$tempString[],$parent[],$names[],$extra[];
string $extr;
for ($a=$i=0;$a<size($deformJoints);$a++)
	{
	if (`gmatch $deformJoints[$a] "*_50"`)
		continue;
	if (`gmatch $deformJoints[$a] "*Slider[0-9]*"`)
		continue;
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $deformJoints[$a]`)
			continue;
	tokenize $deformJoints[$a] "_" $tempString;
	$extr="FKExtra"+$tempString[0]+"_"+$tempString[1];
	if (`gmatch $deformJoints[$a] "*Part[0-9]*"`)
		continue;
	$keyDeformJoints[$i]=$deformJoints[$a];
	$extra[$i]=$extr;
	$tempString[0]=$keyDeformJoints[$i];
	for ($y=0;$y<99;$y++)
		{
		$tempString=`listRelatives -p $tempString[0]`;
		if (!`gmatch $tempString[0] "*Part[0-9]*"`)
			{
			tokenize $tempString[0] "_" $tempString;
			$parent[$i]=$tempString[0]+"_MoCap_"+$tempString[1];
			break;
			}
		}
	tokenize $keyDeformJoints[$i] "_" $tempString;
	string $name=$tempString[0]+"_MoCap_"+$tempString[1];
	if (!`stringArrayCount $name $names`)
		{
		$names[$i]=$name;
		$i++;
		}
	}

string $topJoint;
for ($i=0;$i<size($names);$i++)
	{
	select -cl;
	joint -n $names[$i];
	if ($i==size($names)-1)
		{
		createNode -n "MoCap" transform;
		createNode -n "CenterOffset" transform;
		asAlign "CenterOffset" CenterExtra_M 1 0 0 0;
		parent "MoCap" "Group";
		parent "CenterOffset" "MoCap";
		parent $names[$i] "CenterOffset";
		connectAttr ($names[$i]+".translate") ("CenterExtra_M.translate");
		$topJoint=$names[$i];
		}
	asAlign $names[$i] $keyDeformJoints[$i] 1 1 1 0;
	setAttr ($names[$i]+".rotateOrder") 1;
	if (`objExists $extra[$i]`)
		setAttr ($extra[$i]+".rotateOrder") 1;
	}

for ($i=0;$i<size($names);$i++)
	{
	if (`objExists $parent[$i]`)
		parent $names[$i] $parent[$i];
	}
for ($i=0;$i<size($names);$i++)
	{
	if (`objExists ($names[$i]+"_blendColor")`)
		delete ($names[$i]+"_blendColor");
	createNode -n ($names[$i]+"_blendColor") blendColors;
	connectAttr ($names[$i]+".rotate") ($names[$i]+"_blendColor.color1");
	addAttr -k 1 -ln "blend" -at double -min 0 -max 1 -dv 1 $names[$i];
	connectAttr ($names[$i]+".blend") ($names[$i]+"_blendColor.blender");
	if (`objExists $extra[$i]`)
		connectAttr ($names[$i]+"_blendColor.output") ($extra[$i]+".rotate");
	}
setAttr "MoCap.translateZ" ($charHeight/-3);
orientConstraint -mo $topJoint "CenterExtra_M";
select $sel;
}


global proc float asGetSceneFps () 
{
float $fps;
string $fpsName=`currentUnit -q -time`;
if ($fpsName=="game") $fps=15;
if ($fpsName=="film") $fps=24;
if ($fpsName=="pal") $fps=25;
if ($fpsName=="ntsc") $fps=30;
if ($fpsName=="show") $fps=48;
if ($fpsName=="palf") $fps=50;
if ($fpsName=="ntscf") $fps=60;
if ($fpsName=="millisec") $fps=1000;
if ($fpsName=="sec") $fps=1;
if ($fpsName=="min") $fps=0.0166667;
if ($fpsName=="hour") $fps=0.000277778;
if (`gmatch $fpsName "*fps"`)
	$fps=`substitute "fps" $fpsName ""`;
return $fps;
}

global proc asReadBVH ()
{
global string $gMainProgressBar;
string $filename=`fileDialog -dm "*.bvh"`;
if (!`file -q -ex $filename`)
	return;

if (!`objExists bvhFile`)
	createNode -n bvhFile transform;

select -cl;
string $topNodesBefore[]=`ls -as`;

int $i=-1;
int $x,$lineNum,$frameNr,$motionBegin,$motionHasBegun;
int $jointNum,$chNum;
int $numChannels[];
float $offsetX,$offsetY,$offsetZ,$value;
float $rot[];
$fileId=`fopen $filename "r"`;
string $nextLine = `fgetline $fileId`;
while ( size( $nextLine ) > 0 )
	{
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionBegin)
		$lineNum++;
	$nextLine = `fgetline $fileId`;
	}
$motionBegin=0;
fclose $fileId;
$fileId=`fopen $filename "r"`;
$nextLine = `fgetline $fileId`;
string $joints[],$buffer[],$channels[],$localChannels[];
float $currentTime=`currentTime -q`;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
currentTime -e -20;

progressBar -e -st "AdvancedSkeleton" -bp -ii 1 -min 0 -max ($lineNum+1) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
while ( size( $nextLine ) > 0 )
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		fclose $fileId;
		}

	tokenize $nextLine $buffer;
	if (`gmatch $nextLine "*}*"`)
		pickWalk -d up;
	if (`gmatch $nextLine "*JOINT*"` || `gmatch $nextLine "*ROOT*"` || `gmatch $nextLine "*End Site*"`)
		{
		$i++;
		$joints[$i]=$buffer[1];
		if ($joints[$i]=="Site")
			$joints[$i]=$joints[$i]+$i;
		joint -n ("MoCap"+$joints[$i]);
		setAttr ("MoCap"+$joints[$i]+".rotateOrder") 2;
		if (`gmatch $nextLine "*JOINT*"`)
			setKeyframe ("MoCap"+$joints[$i]+".rotate");
		}
	if (`gmatch $nextLine "*OFFSET*"`)
		{
		$offsetX=$buffer[1];
		$offsetY=$buffer[2];
		$offsetZ=$buffer[3];
		setAttr -type float3 ("MoCap"+$joints[$i]+".translate") $offsetX $offsetY $offsetZ;
		}
	if (`gmatch $nextLine "*CHANNELS*"`)
		{
		$numChannels[$i]=$buffer[1];
		for ($x=2;$x<size($buffer);$x++)
			$channels[$i]=$channels[$i]+`asReWord $buffer[$x]`+";";
		}

	if ($motionBegin)
		$motionHasBegun=1;
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionHasBegun)
		{
		progressBar -e -s 1 $gMainProgressBar;
		$jointNum=0;
		tokenize $channels[$jointNum] ";" $localChannels;
		$chNum=-1;
		for ($y=0;$y<size($buffer);$y++)
			{
			$chNum++;
			if ($chNum>$numChannels[$jointNum]-1)
				{
				$jointNum++;
				if (`gmatch $joints[$jointNum] "Site*"`)
					$jointNum++;
				tokenize $channels[$jointNum] ";" $localChannels;
				$chNum=0;
				}
			$value=$buffer[$y];
//			currentTime -e ($frameNr+1);
			if (`gmatch $localChannels[$chNum] "*rotate*"`)
				{
				if ($localChannels[$chNum]=="rotateX")
					$rot[0]=$value;
				if ($localChannels[$chNum]=="rotateY")
					$rot[1]=$value;
				if ($localChannels[$chNum]=="rotateZ")
					$rot[2]=$value;
				if ($chNum==2 || $chNum==5)
					{
					asSetMoCapRot ("MoCap"+$joints[$jointNum]) $rot;
					setKeyframe -t $frameNr ("MoCap"+$joints[$jointNum]+".rotate");
					}
				}
			else
				setKeyframe -v $value -t $frameNr ("MoCap"+$joints[$jointNum]+"."+$localChannels[$chNum]);
			}
		$frameNr++;
		}
	$nextLine = `fgetline $fileId`;
	}
progressBar -e -ep $gMainProgressBar;
currentTime -e $currentTime;
autoKeyframe -state $autoKeyframe;
fclose $fileId;

string $topNodesAfter[]=`ls -as`;
string $moCapTopNode;
for ($i=0;$i<size($topNodesAfter);$i++)
	{
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		{
		$moCapTopNode=$topNodesAfter[$i];
		parent $moCapTopNode bvhFile;
		}
	}

//clean statics
string $bhvJoints[]=`listRelatives -ad -type joint bvhFile`;
select $bhvJoints;
delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1;

//Scale to match Root height
string $tempString[]=`listConnections -scn 1 ($moCapTopNode+".ty")`;
if ($tempString[0]!="")
	{
	$tyAnimCurve=$tempString[0];
	string $tempString[]=`listRelatives -c -type joint DeformationSystem`;
	string $root=$tempString[0];
	float $rootHeigh=`getAttr ($root+".ty")`;
	float $keyValues[]=`keyframe -in 0 -q -vc $tyAnimCurve`;
	float $scaleFactor=$rootHeigh/$keyValues[0];
	setAttr -type float3 bvhFile.s $scaleFactor $scaleFactor $scaleFactor;
/*
	$tempString=`listConnections -scn 1 ($moCapTopNode+".tx")`;
	$txAnimCurve=$tempString[0];
	$tempString=`listConnections -scn 1 ($moCapTopNode+".tz")`;
	$tzAnimCurve=$tempString[0];
	selectKey -add -k -t "0:99999" $txAnimCurve $tyAnimCurve $tzAnimCurve;
	scaleKey -iub false -ts 1 -tp 69 -fs 1 -fp 69 -vs $scaleFactor -vp 0 -animation keys ;
*/
	}
//Scale keys to match frameRate
float $bvhFps=`floatField -q -v asBVHfps`;
float $sceneFps=`asGetSceneFps`;
float $scaleTime=$sceneFps/$bvhFps;
string $animCurves[];
select -cl;
for ($i=0;$i<size($bhvJoints);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -scn 1 -type animCurve $bhvJoints[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		selectKey -add -k -t "0:99999" $animCurves[$y];
	}
scaleKey -iub false -ts $scaleTime -tp 0 -fs $scaleTime -fp 0 -vs 1 -vp 0 -animation keys ;

playbackOptions -min 0 -ast 0 -max ($frameNr*$scaleTime) -aet ($frameNr*$scaleTime);
currentTime 0;

select -cl;
}

global proc asDeleteMocap ()
{
if (`objExists MoCap`)
	delete MoCap;
delete `ls -type blendColors "*_MoCap_*_blendColor"`;
}

global proc asDeleteBHV ()
{
if (`objExists bvhFile`)
	delete bvhFile;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asAutoMapMocap ()
{
float $charHeight=`asgetCharHeight`;
string $tempString[]=`listRelatives -c -type joint bvhFile`;
string $bvhTopJoint=$tempString[0];
string $tempString[]=`listRelatives -c -type joint CenterOffset`;
string $moCapTopJoint=$tempString[0];
$tempString=`pointConstraint $bvhTopJoint $moCapTopJoint`;
setAttr ($tempString[0]+".offsetZ") ($charHeight/3);

catch (`orientConstraint -mo $bvhTopJoint $moCapTopJoint`);

catch (`orientConstraint -mo MoCapRightUpLeg Hip_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftUpLeg Hip_MoCap_L`);
catch (`orientConstraint -mo MoCapRightLeg Knee_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftLeg Knee_MoCap_L`);
catch (`orientConstraint -mo MoCapRightFoot Ankle_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftFoot Ankle_MoCap_L`);
catch (`orientConstraint -mo MoCapRightToeBase MiddleToe1_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftToeBase MiddleToe1_MoCap_L`);

catch (`orientConstraint -mo MoCapSpine BackB_MoCap_M`);
catch (`orientConstraint -mo MoCapSpine1 Chest_MoCap_M`);
catch (`orientConstraint -mo MoCapRightShoulder Scapula_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftShoulder Scapula_MoCap_L`);
catch (`orientConstraint -mo MoCapRightArm Shoulder_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftArm Shoulder_MoCap_L`);
catch (`orientConstraint -mo MoCapRightForeArm Elbow_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftForeArm Elbow_MoCap_L`);
catch (`orientConstraint -mo MoCapRightHand Wrist_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftHand Wrist_MoCap_L`);

catch (`orientConstraint -mo MoCapRThumb ThumbFinger2_MoCap_R`);
catch (`orientConstraint -mo MoCapLThumb ThumbFinger2_MoCap_L`);

catch (`orientConstraint -mo MoCapNeck1 Neck_MoCap_M`);
catch (`orientConstraint -mo MoCapHead Head_MoCap_M`);
}

global proc asDeleteMocapMap ()
{
delete `listRelatives -ad -type constraint MoCap`;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asSetMoCapRot (string $obj, float $rot[])
{
setAttr -type float3 ($obj+".rotate") 0 0 0;
float $rotX=$rot[0];
float $rotY=$rot[1];
float $rotZ=$rot[2];
rotate -r -os 0 0 $rotZ $obj;
rotate -r -os $rotX 0 0 $obj;
rotate -r -os 0 $rotY 0 $obj;
}

global proc string asReWord (string $bvhWord)
{
if ($bvhWord=="Xposition")
	return "translateX";
if ($bvhWord=="Yposition")
	return "translateY";
if ($bvhWord=="Zposition")
	return "translateZ";
if ($bvhWord=="Xrotation")
	return "rotateX";
if ($bvhWord=="Yrotation")
	return "rotateY";
if ($bvhWord=="Zrotation")
	return "rotateZ";
return "";
}

global proc asBakeAnimation ()
{
if (!`objExists "DeformationSystem"`)
	return;
select -cl;
string $allDecendents[]=`listRelatives -ad "DeformationSystem"`;
for ($i=0;$i<size($allDecendents);$i++)
	{
	if (`objectType -i joint $allDecendents[$i]`)
		select -add $allDecendents[$i];
	}
BakeSimulationOptions;
}

global proc string asRotOrderString (int $rotOrder)
{
string $rotOrderString;
if ($rotOrder==0)
	$rotOrderString="xyz";
if ($rotOrder==1)
	$rotOrderString="yzx";
if ($rotOrder==2)
	$rotOrderString="zxy";
if ($rotOrder==3)
	$rotOrderString="xzy";
if ($rotOrder==4)
	$rotOrderString="yxz";
if ($rotOrder==5)
	$rotOrderString="zyx";
return $rotOrderString;
}

global proc asSDKMode ()
{
int $onOff;

if (!`objExists FitSkeleton`)
	return;

string $fitSkeletonJoints[]=`listRelatives -type joint -ad FitSkeleton`;
string $animCurves[],$tempString[];
string $FKOffset,$side,$attribute;
int $animCurveNr;
for ($i=0;$i<size($fitSkeletonJoints);$i++)
	{
	$animCurves=`listConnections -scn 1 -type animCurve $fitSkeletonJoints[$i]`;
	if (size($animCurves))
		{
		if (`objExists ("FKOffset"+$fitSkeletonJoints[$i]+"_R")`)
			$side="_R";
		else if (`objExists ("FKOffset"+$fitSkeletonJoints[$i]+"_M")`)
			$side="_M";
		else
			error ("Could not find: FKOffset"+$fitSkeletonJoints[$i]+"_R");
		$FKOffset="FKOffset"+$fitSkeletonJoints[$i]+$side;
		}
	for ($y=0;$y<size($animCurves);$y++)
		{
		tokenize $animCurves[$y] "_" $tempString;
		$attribute=$tempString[size($tempString)-1];
		$tempString=`listConnections -p 1 ($animCurves[$y]+$side+".output")`;
		if ($animCurveNr==0)
			{
			if (size($tempString))
				$onOff=1;
			else
				$onOff=0;
			if ($onOff)
				headsUpDisplay -s 2 -b 0 -bs "medium" -l "SDKMode" -lfs "large" HUDSDKMode;
			else
				headsUpDisplay -rem HUDSDKMode;
			}

		$animCurveNr++;
		if ($onOff)
			{
			disconnectAttr ($animCurves[$y]+$side+".output") ($FKOffset+"."+$attribute);
			connectAttr ($fitSkeletonJoints[$i]+"."+$attribute) ($FKOffset+"."+$attribute);
			}
		else
			if (!`isConnected ($animCurves[$y]+$side+".output") ($FKOffset+"."+$attribute)`)
				connectAttr -f ($animCurves[$y]+$side+".output") ($FKOffset+"."+$attribute);
		}
	}
}

global proc asFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr2[];

int $onOff=1;
if ($asFitModeScriptJobNr1)
	$onOff=0;
asByPassSDK $onOff;
select -cl;
if ($onOff)
	{
	$asFitModeScriptJobNr1=`scriptJob -cu 1 -e "SelectionChanged" "asFitModeUpdateScriptJob"`;
	headsUpDisplay -s 1 -b 0 -bs "medium" -l "FitMode" -lfs "large" HUDFitMode;
	}
else
	{
	if (`scriptJob -ex $asFitModeScriptJobNr1`)
		{
		scriptJob -kill $asFitModeScriptJobNr1;
		$asFitModeScriptJobNr1=0;
		}
	asFitModeUpdateScriptJob;
	if (`headsUpDisplay -ex HUDFitMode`)
		headsUpDisplay -rem HUDFitMode;
	}
}

global proc asFitModeUpdateScriptJob ()
{
global int $asFitModeScriptJobNr2[];
global string $asFitModeOffRLA[];
for ($i=0;$i<size($asFitModeOffRLA);$i++)
	if (`objExists $asFitModeOffRLA[$i]`)
		setAttr ($asFitModeOffRLA[$i]+".displayLocalAxis") 0;

clear $asFitModeOffRLA;
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
string $sel[]=`ls -sl -type joint`;
string $tempString[];
string $rlaParent,$rlaChild;
float $pos[];
string $aimParents;
for ($i=0;$i<size($sel);$i++)
	{
	//Parent
	if (size(`ls -ap $sel[$i]`)>1)
		continue;
	$rlaParent=`asRlaParent $sel[$i]`;
	if (!`objExists $rlaParent`)
		continue;
	if (`objectType $rlaParent`!="joint")
		continue;
	$pos=`getAttr ($sel[$i]+".translate")`;
	if ($pos[1]>0.01 || $pos[1]<-0.01 || $pos[2]>0.01 || $pos[2]<-0.01)
		continue;

	if (!`getAttr ($rlaParent+".displayLocalAxis")`)
		$asFitModeOffRLA[$i]=$rlaParent;
	setAttr ($rlaParent+".displayLocalAxis") 1;

	if ($aimParents!="")
		$aimParents+="@";
	$aimParents+=$sel[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	//Child
	$rlaChild=`asRlaChild $sel[$i]`;
	if (size(`ls -ap $rlaChild`)!=1)
		continue;
	$pos=`getAttr ($rlaChild+".translate")`;
	if ($pos[1]>0.01 || $pos[1]<-0.01 || $pos[2]>0.01 || $pos[2]<-0.01)
		continue;
	$aimParents+="@"+$rlaChild;
	}
if ($aimParents!="")
	{	
	$asFitModeScriptJobNr2[0]=`scriptJob -cu 1 -ac ($sel[0]+".t") ("asFitModeAimParent (\""+$aimParents+"\")")`;
	$asFitModeScriptJobNr2[1]=`scriptJob -cu 1 -ac ($sel[0]+".r") ("asFitModeUpdateSDK (\""+$sel[0]+"\")")`;
	}
}

global proc jointVisMaya2014 (int $onOff)
{
if (!`objExists Main`)
	return;
string $joints[]=`listRelatives -type joint -ad Main`;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asFitModeUpdateSDK (string $joint)
{
//might have existing SDK connection
string $tempString[],$tempString2[],$reconnectSources[],$reconnectDests[];
$tempString=`listConnections -type animCurve $joint`;
for ($i=0;$i<size($tempString);$i++)
	{
	//find which key index we are currently at
	$valuesAtAllInds=`keyframe -q -fc $tempString[$i]`;
	for ($index=0;$index<size($valuesAtAllInds);$index++)
		if ($valuesAtAllInds[$index]==`getAttr ($tempString[$i]+".input")`)
			break;
    $tempString2=`listConnections -p 1 -d 1 -s 0 $tempString[$i]`;
    keyframe -e -iub true -a -o over -index $index -vc `getAttr $tempString2[0]` $tempString[$i];
	}
}

global proc asFitModeAimParent (string $jointsString)
{
string $sel[]=`ls -sl`;
float $valuesAtAllInds[];
string $generatedTransform1,$generatedTransform2;
string $joints[],$generatedTransforms[],$tempString[],$tempString2[],$reconnectSources[],$reconnectDests[],$sdkUpdates[];
tokenize $jointsString "@" $joints;
for ($joint in $joints)
	{
	if (size(`ls -ap $joint`)!=1)
		return;
	string $label=`asLabel $joint`;
	if (`gmatch $label "Twist*"`)
		return;
	string $tempString[]=`listRelatives -f -p $joint`;
	string $parent=$tempString[0];
	int $operatingOnSelected;
	for ($obj in $sel)
		if ($obj==$joint)
			$operatingOnSelected=1;
	int $hasTwistParent;
	string $rlaParent=`asRlaParent $joint`;
	string $rlaParentFirstChild;
	if (`objExists $rlaParent`)
		if ($rlaParent!=$parent)
			{
			$hasTwistParent=1;
			$tempString=`listRelatives -f -c $rlaParent`;
			$rlaParentFirstChild=$tempString[0];
			}
	if (!`objExists $parent` || !`objExists $rlaParent`)
		return;
	
	float $pos[];
	if ($operatingOnSelected)
		$pos=`getAttr ($joint+".translate")`;
	else
		$pos=`getAttr ($rlaParentFirstChild+".translate")`;
	if (!($pos[1]>0.01 || $pos[1]<-0.01 || $pos[2]>0.01 || $pos[2]<-0.01))
		return;
	$tempString=`parent -w $joint`;
	string $otherChildren[]=`listRelatives -f -c -type joint $parent`;
	$joint=$tempString[0];
	$tempString=`listRelatives -p $joint`;
	if (size($tempString))
		$generatedTransform1=$tempString[0];
	string $upVec=`createNode joint`;
	parent -r $upVec $rlaParent;
	setAttr ($upVec+".translate") 0 3 0;
	parent -w $upVec;
	$tempString=`listRelatives -p $upVec`;
	if (size($tempString))
		$generatedTransform2=$tempString[0];
	if (size($otherChildren))
		$otherChildren=`parent -w $otherChildren`;
	for ($i=0;$i<size($otherChildren);$i++)
		{
		$tempString=`listRelatives -p $otherChildren[$i]`;
		if (size($tempString))
			$generatedTransforms[$i]=$tempString[0];
		}

	//might have existing SDK connection
	$tempString=`listConnections -type animCurve $rlaParent`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2=`listConnections -p 1 $tempString[$i]`;
		$reconnectSources[size($reconnectSources)]=$tempString[$i];
		$reconnectDests[size($reconnectDests)]=$tempString2[0];
		disconnectAttr ($tempString[$i]+".output") $tempString2[0];
		}

	$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $upVec $joint $rlaParent`;

	for ($i=0;$i<size($reconnectSources);$i++)
		{
		//find which key index we are currently at
		$valuesAtAllInds=`keyframe -q -fc $reconnectSources[$i]`;
		for ($index=0;$index<size($valuesAtAllInds);$index++)
			if ($valuesAtAllInds[$index]==`getAttr ($reconnectSources[$i]+".input")`)
				break;
		$sdkUpdates[size($sdkUpdates)]="keyframe -e -iub true -a -o over -index "+$index+" -vc "+`getAttr $reconnectDests[$i]`+" "+$reconnectSources[$i];
		}

	delete $tempString[0] $upVec;

	for ($i=0;$i<size($sdkUpdates);$i++)
		{
		connectAttr -f ($reconnectSources[$i]+".output") $reconnectDests[$i];
		eval($sdkUpdates[$i]+";\n");
		}

	if (size($otherChildren))
		parent $otherChildren $parent;

	parent $joint $parent;
	if (`objExists $generatedTransform1`)
		delete $generatedTransform1;
	if (`objExists $generatedTransform2`)
		delete $generatedTransform2;
	if (size ($generatedTransforms))
		for ($obj in $generatedTransforms)
			if (`objExists $obj`)
				delete $obj;
	}
select $sel;
}

global proc asCreateNode (string $type, string $name, float $posX, float $posY, float $posZ,
						      float $rotX, float $rotY, float $rotZ, int $rotOrder, int $flip)
{
string $sel[]=`ls -sl`;
select -cl;
createNode -n $name $type;
string $tempString[]=`ls -showType $name`;
if ($tempString[1]=="locator")
	{
	rename $name ($name+"Shape");
	$tempString=`listRelatives -p ($name+"Shape")`;
	rename $tempString[0] $name;
	}
//string $rotOrderString=`asRotOrderString $rotOrder`;
//xform -roo $rotOrderString $name;
setAttr ($name+".rotateOrder") $rotOrder;
xform -ws -t $posX $posY $posZ -ro $rotX $rotY $rotZ $name;
if (size ($sel))
	{
	parent $name $sel[0];
	select $name;
	}

float $rot[];
if ($flip)
	{
	select -cl;
	joint -n tempJoint;
	setAttr tempJoint.rotateOrder $rotOrder;
	xform -ws -t $posX $posY $posZ -ro $rotX $rotY $rotZ tempJoint;
	mirrorJoint -mirrorYZ -mirrorBehavior;
	$rot=`xform -q -ws -ro tempJoint1`;
	xform -ws -ro $rot[0] $rot[1] $rot[2] $name;
	delete tempJoint tempJoint1;
	}
select $name;
}

global proc asByPassSDK (int $onOff)
{
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`)
	return;
string $joints[]=`listRelatives -type joint -ad FitSkeleton`;
string $connections1[],$connectionsUnitConv1[],$connections1Attr[],$connections2[],$tempString[];
string $newAnimCurve,$newAnimCurveName,$obj,$attr;
float $value,$time;
int $locked;
for ($joint in $joints)
	{
	if (`gmatch $joint "*:*"`)
		continue;
	$connections1=`listConnections -scn 1 -s 1 -d 0 $joint`;
	$connectionsUnitConv1=`listConnections -s 1 -d 0 $joint`;
	$connections1Attr=`listConnections -s 1 -d 0 -c 1 $joint`;
	for ($i=0;$i<size($connections1);$i++)
		{
		$locked=0;
		$node=$connections1[$i];
		if (!`objExists $node`)
			continue;
		if (`isAnimCurve $node`)
			{
			$connections2=`listConnections -s 1 -d 0 -p 1 ($node+".input")`;
			if (!size($connections2) ||  (!`attributeExists "output" $connections1[$i]`))
				continue;

			if ($onOff)
				{
				if (`isConnected ($connections1[$i]+".output") $connections1Attr[($i*2)]`)
					{
					tokenize $connections1Attr[($i*2)] "." $tempString;
					$obj=$tempString[0];
					$attr=$tempString[1];
					if (`getAttr -l ($obj+"."+$attr)`)
						{
						$locked=1;
						setAttr -l 0 ($obj+"."+$attr);
						}
					disconnectAttr ($connections1[$i]+".output") ($obj+"."+$attr);
					if ($locked)
						setAttr -l 1 ($obj+"."+$attr);
					if (!`attributeExists ("temp"+$attr) $obj`)
						addAttr -ln ("temp"+$attr) -at double $obj;
					connectAttr -f ($connections1[$i]+".output") ($obj+".temp"+$attr);
					}
				}
			else
				{
				tokenize $connections1Attr[($i*2)] "." $tempString;
				if (!`gmatch $tempString[1] "temp*"`)
					continue;
				$obj=$tempString[0];
				$attr=`substring $tempString[1] 5 99`;
				if (`getAttr -l ($obj+"."+$attr)`)
					{
					$locked=1;
					setAttr -l 0 ($obj+"."+$attr);
					}
				$value=`getAttr ($obj+"."+$attr)`;
				$time=`getAttr $connections2[0]`;
				if (!`setKeyframe -float $time -v $value $connections1[$i]`)
					keyframe -e -vc $value -f $time $connections1[$i];

				connectAttr ($connections1[$i]+".output") ($obj+"."+$attr);
				if (`attributeExists ("temp"+$attr) $obj`)
					deleteAttr ($obj+".temp"+$attr);
				if (`objectType $connectionsUnitConv1[$i]`=="unitConversion")
					delete $connectionsUnitConv1[$i];

				if ($locked)
					setAttr -l 1 ($obj+"."+$attr);
				}
			}
		}
	}
select $sel;
}

global proc asCopyKeys (string $sourceCurve, string $destinationCurve)
{
string $sourceType=`nodeType $sourceCurve`;
int $numKeys;

$numKeys=`keyframe -query -keyframeCount $destinationCurve`;
for ($i=0;$i<($numKeys-1);$i++)
	cutKey -in 0 $destinationCurve;
if ($numKeys)
	keyframe -index 0 -fc 999 $destinationCurve;

$numKeys=`keyframe -query -keyframeCount $sourceCurve`;
float $time[],$value[];
string $inTan[],$outTan[];
for ($i=0;$i<$numKeys;$i++)
	{
	if (`gmatch $destinationCurve "*_tmp"`)
		$time=`keyframe -in $i -q -fc $sourceCurve`;
	else
		$time=`keyframe -in $i -q -tc $sourceCurve`;
	$value=`keyframe -in $i -q -vc $sourceCurve`;
	$inTan=`keyTangent -in $i -q -itt $sourceCurve`;
	$outTan=`keyTangent -in $i -q -ott $sourceCurve`;
	if (`gmatch $destinationCurve "*_tmp"`)
		setKeyframe -time $time[0] -v $value[0] -itt $inTan[0] -ott $outTan[0] $destinationCurve;
	else
		setKeyframe -f $time[0] -v $value[0] -itt $inTan[0] -ott $outTan[0] $destinationCurve;
	}
cutKey -in $numKeys $destinationCurve;
}

global proc string[] asFitNodeInfo (string $node, string $info)
{
int $numMoreReturn;
string $return[],$moreReturn[],$buffer[];
string $connections[]=`listConnections -s 1 -d 0 $node`;
string $plugs[]=`listConnections -s 1 -d 0 -p 1 -c 1 $node`;
for ($i=0;$i<size($connections);$i++)
	{
	$isJoint=0;
	if ($plugs[$i*2]==($node+".inverseScale") || $plugs[$i*2]==($node+".drawOverride"))
		continue;
	if ($info=="name")
		$return[size($return)]=$connections[$i];
	else if ($info=="sourceNode")
		{
		tokenize $plugs[($i*2)+1] "." $buffer;
		$return[size($return)]=$buffer[0];
		}
	else if ($info=="sourceConnect")
		{
		tokenize $plugs[($i*2)+1] "." $buffer;
		$return[size($return)]=$buffer[1];
		}
	else if ($info=="destNode")
		{
		tokenize $plugs[($i*2)] "." $buffer;
		$return[size($return)]=$buffer[0];
		}
	else if ($info=="destConnect")
		{
		tokenize $plugs[$i*2] "." $buffer;
		$return[size($return)]=$buffer[1];
		}
	if (`objectType $connections[$i]`=="joint")
		continue;
	else
		{
		$moreReturn=`asFitNodeInfo $connections[$i] $info`;
		$numMoreReturn=`size($moreReturn)`;
		appendStringArray $return $moreReturn $numMoreReturn;
		}
	}
return $return;
}


global proc int asParentCount (string $node, string $parent)
{
int $count,$return;
string $longs[]=`ls -l $node`;
string $tempString[];
int $numTok=`tokenize $longs[0] "|" $tempString`;
for ($i=$numTok-1;$i>-1;$i--)
	{
	if ($tempString[$i]==$parent)
		{
		$return=$count;
		break;
		}
	else
		$count++;
	}
return $return;
}

global proc asSDK (string $driver, float $driveStart, float $driveEnd, string $driven, float $drivenStart, float $drivenEnd)
{
float $originalDriveValue=`getAttr $driver`;
setAttr $driver $driveStart;
setAttr $driven $drivenStart;
setDrivenKeyframe -cd $driver $driven;
setAttr $driver $driveEnd;
setAttr $driven $drivenEnd;
setDrivenKeyframe -cd $driver $driven;
setAttr $driver $originalDriveValue;
}

global proc asMacInit ()
{
string $dyld_library_path=`getenv "DYLD_LIBRARY_PATH"`;
if ($dyld_library_path=="")
     {
     print ("$dyld_library_path env variable not found, attempting to set it now\n");
     string $convertPath=`internalVar -usd`+"AdvancedSkeleton/convert";
     putenv "PATH" (`getenv "PATH"`+":"+$convertPath);
     putenv "DYLD_LIBRARY_PATH" $convertPath;
     }
}

global proc asfileBrowse (string $tool, string $action)
{
string $fc,$ft;
int $mode=0;
if ($action=="Open")
	{
	$fc="asOpen "+$tool;
	$ft="mel";
	}
if ($action=="SaveAs")
	{
	$fc="asSaveAs "+$tool;
	$ft="mel";
	$mode=1;
	}
if ($action=="Import")
	{
	$fc="as"+$tool+"BackgroundImport";
	$ft="*";
	}
if (`asMayaVersionAsFloat`>=2011)
	eval ($fc+" \""+`fileDialog -dm ("*."+$ft) -m $mode`+"\" "+"fileType");
else
	{
	if (`about -win`)
		fileBrowserDialog -m $mode -fc $fc -ft $ft -an $action;
	else
		fileBrowser $fc $action $ft $mode;
	}
}

global proc astoShelf (string $tool)
{
global string $gShelfTopLevel;
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
if ($projectName=="untitled")
	{
	warning "Can not put \"untitled\" on shelf, save your project first\n";
	return;
	}

string $cmd="source \""+$projectPath+$projectName+".mel\";as"+$tool+$projectName+";";
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
if (`about -mac`)
	$ext=".iff";
$icon=$projectPath+$projectName+"/"+$projectName+"_background32"+$ext;
string $setParent=`setParent -q`;
if (`tabLayout -exists $gShelfTopLevel`)
	{
	string $currentShelf=`tabLayout -query -selectTab $gShelfTopLevel`;
	setParent $currentShelf;
	shelfButton -c $cmd -ann ($tool+":"+$projectName) -label ($tool+":"+$projectName) -i1 $icon
		-st`shelfLayout -query -style $currentShelf`
		-width `shelfLayout -query -cellWidth $currentShelf`
		-height `shelfLayout -query -cellHeight $currentShelf`;
	}
setParent $setParent;
}

global proc string asUniqueFile (string $file)
{
// Copies given file to a random named file, to avoid fileNode cache
string $buffer[];
int $numTok=`tokenize $file "/" $buffer`;
string $path="";
if (`gmatch $file "/*"`)
	$path="/";
for ($i=0;$i<($numTok-1);$i++)
	$path+=$buffer[$i]+"/";
int $numTok=`tokenize $file "." $buffer`;
string $ext=$buffer[$numTok-1];
string $randNumber=`rand 42`;
string $uniqueFile=$path+"unique"+`substituteAllString $randNumber "." ""`+"."+$ext;
sysFile -cp $uniqueFile $file;
return $uniqueFile;
}

global proc string[] asGetControlSets ()
{
string $controlSets[];
string $sets[]=`ls -type objectSet`;
for ($i=0;$i<size($sets);$i++)
	{
	if (!`sets -q -r $sets[$i]` && !`sets -q -v $sets[$i]` && !`sets -q -eg $sets[$i]` && !`sets -q -fc $sets[$i]` && !`sets -q -ep $sets[$i]`)
		if (`gmatch $sets[$i] "*[c-C]ontrol[s-S]et*"`)
			$controlSets[size($controlSets)]=$sets[$i];
	}
return $controlSets;
}



//--------------   IO Procs   --------------//




global proc int asOpen (string $tool, string $fileName, string $fileType)
{
global int $asfileLoading;
string $sel[]=`ls -sl`;
select -cl;
string $projectName=`basename $fileName ".mel"`;
string $projectPath=`dirname $fileName`+"/";
string $asIconLocation=$projectPath+$projectName+"/";
int $anim;
string $bgExt=".tga";
if (`about -mac`)
	$bgExt=".iff";

if ($tool=="Poser")
	asPoserDesigner;

evalEcho ("source \""+$fileName+"\";\n"
	+"as"+$tool+$projectName);
window -e -i 1 ("as"+$tool+$projectName);

if ($tool=="Poser")
	{
	$asfileLoading=1;
	string $gridOrder[]=`gridLayout -q -go ("asPoser"+$projectName+"GridLayout")`;
	int $nc=`gridLayout -q -nc ("asPoser"+$projectName+"GridLayout")`;
	int $nr=`gridLayout -q -nr ("asPoser"+$projectName+"GridLayout")`;
	intField -e -v $nc asPoserNc;
	intField -e -v $nr asPoserNr;
	asPoserUpdateGrid;
	int $childNum,$lenght;
	string $uiName="asPoserDefault";
	string $loadData[];
	$loadData[0]=$uiName;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] ("asPoser"+$projectName+"ColumnLayout*")`)
			{
			$image=`iconTextButton -q -i ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$loadData[1]=$image;
//			$label=`iconTextButton -q -l ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$label=`text -q -l ("asPoser"+$projectName+"Text"+$childNum)`;
			$loadData[2]=$label;
			$cmd=`iconTextButton -q -c ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$cmd=`substitute ("asPoser"+$projectName)  ("\""+$cmd+"\"") $uiName`;
			$lenght=size($cmd);
			$loadData[3]=`substring $cmd 2 ($lenght-1)`;
			$loadData[4]=$childNum;
			$anim=0;
			if (!`gmatch $cmd "*asSetAttrs *"`)
				$anim=1;
			$loadData[5]=$anim;
			asNewPose $loadData $anim;
			}
		}
	}
if ($tool=="Selector")
	{
	asSelectorDesigner;
	$asfileLoading=1;
	
	window -e -w `window -q -w ("asSelector"+$projectName)` -h `window -q -h ("asSelector"+$projectName)` asSelectorDefault;
	asSelectorBackgroundImport ($asIconLocation+$projectName+"_background"+$bgExt) "image";
	
	int $width,$height,$msg0AsInt,$msg1AsInt;
	string $iol;
	string $buffer[],$msgs[];
	//restore controlSets
	string $controlSetsText,$controlSets[];
	if (`text -q -ex ("asSelector"+$projectName+"ControlSetsText")`)
		{
		$controlSetsText=`text -q -l ("asSelector"+$projectName+"ControlSetsText")`;
		$controlSets=`stringToStringArray $controlSetsText " "`;
		if (`menuItem -q -ex ControlSet`)
			menuItem -e -cb 0 ControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if (`menuItem -q -ex $controlSets[$i]`)
				menuItem -e -cb 1 $controlSets[$i];
		}

	string $ctls[]=`formLayout -q -ca ("asSelector"+$projectName+"FormLayout")`;
	int $mirrorButtons=`optionVar -q asSelectorMirrorButtons`;
	optionVar -iv asSelectorMirrorButtons 0;
	for ($ctl in $ctls)
		if (`iconTextButton -q -ex $ctl` && !`gmatch $ctl "*BGPicture"`)
			{
			tokenize $ctl ":" $buffer;
			$msg0AsInt=$msgs[0]=$buffer[size($buffer)-2];
			$msg1AsInt=$msgs[1]=$buffer[size($buffer)-1];
			$width=`iconTextButton -q -w $ctl`;
			$height=`iconTextButton -q -h $ctl`;
			$iol=`iconTextButton -q -iol $ctl`;
			$cmd=`iconTextButton -q -c $ctl`;
			$cmd=`substitute ("\""+$projectName+"\"") (""+$cmd) "\"Default\""`;
			$buttonName=`substitute $projectName $ctl ""`;
			$ann=`control -q -ann $ctl`;
			$msgs[2]=$iol;
			$msgs[3]=$cmd;
			$msgs[4]=$buttonName;
			$msgs[6]=$ann;
			renameUI $ctl ("deleteMeUI"+$ctl);
			asSelectorDpc "asSelectorBGImage"  "asSelectorBGImage" $msgs ($msg0AsInt+$width-4) ($msg1AsInt+$height-5) 2;
			}
	optionVar -iv asSelectorMirrorButtons $mirrorButtons;
	evalDeferred -lp asSelectorRefresh;
	}

//evalDeferred ("deleteUI as"+$tool+$projectName);
text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");
$asfileLoading=0;
select $sel;

return 1;
}

global proc int asSaveAs (string $tool, string $fileName, string $fileType)
{
string $sel[]=`ls -sl`;
string $projectName,$file;
string $buffer[];
int $numFileNameChar=size ($fileName);
tokenize $fileName "/" $buffer;
string $file=$buffer[size($buffer)-1];
int $numFileChar=size ($file);
tokenize $file "." $buffer;
$projectName=$buffer[0];
string $tempTrn=`createNode transform`;
$projectName=`createNode -p $tempTrn -n $projectName transform`;
delete $tempTrn;
tokenize $projectName "|" $buffer;
$projectName=$buffer[size($buffer)-1];
string $projectPath=`substring $fileName 1 ($numFileNameChar-$numFileChar)`;

string $previousProjectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $previousProjectName=`text -q -l ("as"+$tool+"ProjectName")`;

text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
asSave $tool;

select $sel;
return 1;
}

global proc asSave (string $tool)
{
if (`text -q -l ("as"+$tool+"ProjectName")`=="untitled")
	{
	asfileBrowse $tool "SaveAs";
	return;
	}
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
string $projectFile=$projectPath+$projectName+".mel";
string $asIconLocation=$projectPath+$projectName+"/";
string $ext=".xpm";
string $bgExt=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=$bgExt=".png";
if (`about -linux`)
	$ext=".xpm";
string $tmpDir=`internalVar -utd`;
string $tmpIconDir=$tmpDir+"AdvancedSkeleton/"+$tool+"/untitled/";
string $uiName="as"+$tool+$projectName;
string $bgc;
string $buffer[];
string $fDet="//This file has been generated by AdvancedSkeleton"+$tool+"//\n";
$fDet+="\n";
$fDet+="global proc "+$uiName+" ()\n";
$fDet+="{\n";
$fDet+="if (`window -q -ex "+$uiName+"`)\n";
$fDet+="\tdeleteUI "+$uiName+";\n";
$fDet+="\n";
$fDet+="string $asSelectorScriptLocation=`asSelectorScriptLocation`;\n";
$fDet+="string $asIconLocation=$asSelectorScriptLocation+\""+$projectName+"/\";\n";
$fDet+="window -mb 1 -t "+$projectName+" "+$uiName+";\n";
$fDet+="menu -l Edit;\n";
$fDet+="\tmenuItem -l Refresh -c \"asPopulateNameSpaceMenu "+$uiName+"\";\n";
$fDet+="\tmenuItem -l Filter -c \"asFilterNameSpaceMenuUI "+$uiName+"\";\n";
$fDet+="\tsetParent..;\n";
if ($tool=="Selector")
	{
	$fDet+="menu -l Display;\n";
	$fDet+="\tmenuItem -l Controls -c asControlsVisibilityToggle;\n";
	$fDet+="\tmenuItem -l \"Set HotKey\" -c asSetupControlVisibilityHotKeyDialog;\n";
	$fDet+="\tmenuItem -l Joints -c asJointsVisibilityToggle;\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Pose -aob 1;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"PosePaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Reset -c \"asGoToBuildPose "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l Mirror -c \"asMirror "+$uiName+"\";\n";
	$fDet+="\tmenuItem -optionBox 1 -c \"asMirrorOptions "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Anim;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 1\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"AnimPaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Clean -c \"asDeleteStaticChannels "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asAnimBake "+$uiName+"\";\n";
	$fDet+="menu -l Dynamics;\n";
	$fDet+="\tmenuItem -l Add -c \"asDynAdd "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l Bake -c \"asDynBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l UnBake -c \"asDynUnBake "+$uiName+"\";\n";
	}
$fDet+="\n";

//controlsets
string $controlSetsText;
string $menuItems[];
if (`menu -q -ex ("as"+$tool+"ControlSetsMenu")`)
	{
	$menuItems=`menu -q -ia ("as"+$tool+"ControlSetsMenu")`;
	for ($i=0;$i<size($menuItems);$i++)
		if (`menuItem -q -cb $menuItems[$i]`)
			$controlSetsText+=$menuItems[$i]+" ";
	}

//remove old files & copy files from `untitled`
string $fileList[];
if (`file -q -ex ($projectPath+$projectName)`)
	{
	$fileList=`getFileList -fld ($projectPath+$projectName+"/")`;
	for ($file in $fileList)
		sysFile -del ($projectPath+$projectName+"/"+$file);
	}
else
	sysFile -md ($projectPath+$projectName);
$fileList=`getFileList -fld $tmpIconDir`;
for ($file in $fileList)
	if (!`gmatch $file "*.tif"`)
		sysFile -cp ($projectPath+$projectName+"/"+`substitute ("untitled_") $file ($projectName+"_")`) ($tmpIconDir+$file);

window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");
string $asScriptLocation=`asScriptLocation`;
string $asToolProcedures=$asScriptLocation+"asToolProcedures.mel";
if (!`file -q -ex $asToolProcedures`)
	error ("Could not find file:\""+$asToolProcedures+"\"\n");

if ($tool=="Poser")
	{
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="optionMenu -cc \"asCharChange "+$uiName+"\" "+$uiName+"OptionMenu;\n";
	$fDet+="scrollLayout "+$uiName+"ScrollLayout;\n";
	int $cw=`gridLayout -q -cw asPoserDefaultGridLayout`;
	int $ch=`gridLayout -q -ch asPoserDefaultGridLayout`;
	int $nc=`intField -q -v asPoserNc`;
	int $nr=`intField -q -v asPoserNr`;
	$fDet+="gridLayout -cw "+$cw+" -ch "+$ch+" -nc "+$nc+" -nr "+$nr+" "+$uiName+"GridLayout;\n";


	$fDet+="formLayout -e\n";
	$fDet+="	-af "+$uiName+"OptionMenu \"top\" 0\n";
	$fDet+="	-ac "+$uiName+"ScrollLayout \"top\" 0 "+$uiName+"OptionMenu\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"bottom\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"left\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"right\" 0\n";
	$fDet+="	"+$uiName+"FormLayout;\n";
	$fDet+="\n";
	$fDet+="\n";

	string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
	int $childNum,$doConnectControl;
	string $cmd,$label,$ann,$animAnn;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] "asPoser*"`)
			{
			$iconTextButton=("asPoserDefaultIconTextButton"+$childNum);
			$floatSlider=("asPoserDefaultFloatSlider"+$childNum);
			$text=("asPoserDefaultText"+$childNum);
			$label=`text -q -l $text`;
			$doConnectControl=`floatSlider -q -m $floatSlider`;
			$ann=`floatSlider -q -ann $floatSlider`;
			$cmd=`iconTextButton -q -c $iconTextButton`;
			$cmd=`substitute  "asPoserDefault" $cmd $uiName`;
			$cmd=`substitute  "untitled_" $cmd ($projectName+"_")`;
			$cmd=`encodeString $cmd`;
			$bgc="";
			if (!`gmatch $cmd "asSetAttrs *"`)
				$bgc=" -bgc 1 0 0";
			$fDet+="string $cmd=\""+$cmd+"\";\n";
			$image=`iconTextButton -q -i $iconTextButton`;
			tokenize ("\""+$image+"\"") "/" $buffer;
			tokenize $buffer[size($buffer)-1] "." $buffer;
			$imageNr=`match "[0-9]+$" $buffer[0]`;
			$animAnn=`rowColumnLayout -q -ann ("asPoserDefaultRowColumnLayout"+$childNum)`;

			$fDet+="setParent "+$uiName+"GridLayout;\n";
			$fDet+="columnLayout "+$uiName+"ColumnLayout"+$childNum+";\n";
			$fDet+="rowColumnLayout -ann "+$animAnn+" -nc 2 -cw 1 100 -cw 2 15 "+$uiName+"RowColumnLayout"+$childNum+";\n";
			$fDet+="iconTextButton -w 100 -h 75 -i ($asIconLocation+\""+$projectName+"_"+$imageNr+$ext+"\") -c $cmd "+$uiName+"IconTextButton"+$childNum+";\n";
			float $min=`floatSlider -q -min $floatSlider`;
			float $max=`floatSlider -q -max $floatSlider`;
			$fDet+="floatSlider -ann \""+$ann+"\" -m "+$doConnectControl+" -min "+$min+" -max "+$max+" -w 10 -h 75 -hr 0 "+$uiName+"FloatSlider"+$childNum+";\n";
			$fDet+="text -h 15 -al \"center\" -fn \"smallBoldLabelFont\" -l \""+$label+"\""+$bgc+" "+$uiName+"Text"+$childNum+";\n";

			//place it
			$fDet+="gridLayout -e -pos "+$uiName+"ColumnLayout"+$childNum+" "+$childNum+" "+$uiName+"GridLayout;\n";

			//popups
			$fDet+="asPoserupdateGridBlock "+$uiName+" "+$childNum+";\n";

			$fDet+="\n";
			}
		}

	$fDet+="\n";
	$fDet+="asPopulateNameSpaceMenu as"+$tool+$projectName+";\n";
	$fDet+="asCharChange "+$uiName+";\n";
	$fDet+="evalDeferred \"showWindow;\";\n";
	$fDet+="}\n";
	}
if ($tool=="Selector")
	{
	int $pictureWidth=`text -q -l asSelectorBackgroundWidth`;
	int $pictureHeight=`text -q -l asSelectorBackgroundHeight`;
	string $buffer[];
	
	string $allCtls[]=`formLayout -q -ca asSelectorDefaultFormLayout`;
	string $ctlName[],$ctlType[],$ctlWidth[],$ctlHeight[],$ctlLeft[],$ctlTop[],$ctlImage[],$ctlCmd[],$ctlIol[],$ctlAnn[];
	string $ctlKeyCmd[],$ctlLinearKeyCmd[];
	string $ctlAlignFK2IKCmd[],$ctlAlignIK2FKCmd[],$ctlSwitchFK2IKCmd[],$ctlSwitchIK2FKCmd[];
	string $buffer[],$tempString[],$menuItems[];
	int $numTok;
	string $shortImageFileName,$oldProjectName;
	for ($a=$i=0;$a<size($allCtls);$a++)
		{
		if ($allCtls[$a]=="asSelectorColumnLayout" || $allCtls[$a]=="asSelectorSeparator" || $allCtls[$a]=="asSelectorBGImage")
			continue;
		$ctlName[$i]=`substitute "asSelector" $allCtls[$a] $uiName`;
		$ctlType[$i]=`objectTypeUI $allCtls[$a]`;
		$ctlWidth[$i]=`control -q -w $allCtls[$a]`;
		$ctlHeight[$i]=`control -q -h $allCtls[$a]`;
		$numTok=`tokenize $allCtls[$a] ":" $buffer`;
		$ctlLeft[$i]=$buffer[$numTok-2];
		$ctlTop[$i]=$buffer[$numTok-1];
		if ($ctlType[$i]=="iconTextButton")
			{
			$ctlImage[$i]=`eval ($ctlType[$i]+" -q -i \""+$allCtls[$a]+"\"")`;
			tokenize $ctlImage[$i] "/" $buffer;
			$shortImageFileName=$buffer[size($buffer)-1];
			tokenize $shortImageFileName "_" $buffer;
			$oldProjectName=$buffer[0];
			for ($b=1;$b<size($buffer)-3;$b++)
				$oldProjectName+="_"+$buffer[$b];
			$ctlImage[$i]=`substitute ($oldProjectName+"_") $shortImageFileName ($projectName+"_")`;
			$ctlCmd[$i]=`eval ($ctlType[$i]+" -q -c \""+$allCtls[$a]+"\"")`;
			$ctlCmd[$i]=`substitute "\"Default\"" $ctlCmd[$i] ("\""+$projectName+"\"")`;
			$ctlCmd[$i]="\""+`encodeString $ctlCmd[$i]`+"\"";
			$ctlAnn[$i]=`eval ($ctlType[$i]+" -q -ann \""+$allCtls[$a]+"\"")`;
			$ctlIol[$i]=`eval ($ctlType[$i]+" -q -iol \""+$allCtls[$a]+"\"")`;
			$tempString=`eval ($ctlType[$i]+" -q -pma \""+$allCtls[$a]+"\"")`;
			$menuItems=`popupMenu -q -ia $tempString[0]`;
			$ctlKeyCmd[$i]=`menuItem -q -c $menuItems[0]`;
			$ctlKeyCmd[$i]=`substitute "\"Default\"" $ctlKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlKeyCmd[$i]="\""+`encodeString $ctlKeyCmd[$i]`+"\"";
			$ctlLinearKeyCmd[$i]=`menuItem -q -c $menuItems[1]`;
			$ctlLinearKeyCmd[$i]=`substitute "\"Default\"" $ctlLinearKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlLinearKeyCmd[$i]="\""+`encodeString $ctlLinearKeyCmd[$i]`+"\"";
			if (size($menuItems)>6)
				{
				$subMenuItems=`menu -q -ia $menuItems[7]`;
				$ctlAlignFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlAlignFK2IKCmd[$i]=`substitute "\"Default\"" $ctlAlignFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignFK2IKCmd[$i]="\""+`encodeString $ctlAlignFK2IKCmd[$i]`+"\"";
				$ctlAlignIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlAlignIK2FKCmd[$i]=`substitute "\"Default\"" $ctlAlignIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignIK2FKCmd[$i]="\""+`encodeString $ctlAlignIK2FKCmd[$i]`+"\"";
				$subMenuItems=`menu -q -ia $menuItems[8]`;
				$ctlSwitchFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlSwitchFK2IKCmd[$i]=`substitute "\"Default\"" $ctlSwitchFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchFK2IKCmd[$i]="\""+`encodeString $ctlSwitchFK2IKCmd[$i]`+"\"";
				$ctlSwitchIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlSwitchIK2FKCmd[$i]=`substitute "\"Default\"" $ctlSwitchIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchIK2FKCmd[$i]="\""+`encodeString $ctlSwitchIK2FKCmd[$i]`+"\"";
				}
			}
		$i++;
		}

	$fDet+="columnLayout -adj 1;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="rowLayout -nc 4 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 80 -cw 4 60;\n";
	$fDet+="optionMenu -cc asSelChange "+$uiName+"OptionMenu;\n";
	$fDet+="button -l set -c \"asSetNameSpaceFromSelection "+$uiName+"\";\n";
	$fDet+="checkBox -v `optionVar -q asShowSelection` -onc \"asSelChangeToggle;optionVar -iv asShowSelection 1\" -ofc \"asSelChangeToggle;optionVar -iv asShowSelection 0\" -l Selection "+$uiName+"SelectionCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowKeyed` -onc \"asSelChangeToggle;optionVar -iv asShowKeyed 1\" -ofc \"asSelChangeToggle;optionVar -iv asShowKeyed 0\" -l Keyed "+$uiName+"KeyedCheckBox;\n";
	$fDet+="setParent..;\n";
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="\n";

	$fDet+="//Controls Begin//\n";
	if (`about -mac` || `about -linux`)
		$fDet+="iconTextButton -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	else
		$fDet+="image -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	for ($i=0;$i<size($ctlType);$i++)
		{
		$fDet+=$ctlType[$i]+" -w "+$ctlWidth[$i]+" -h "+$ctlHeight[$i];
		if ($ctlImage[$i]!="")
			$fDet+=" -i ($asIconLocation+\""+$ctlImage[$i]+"\")";
		if ($ctlImage[$i]!="")
			$fDet+=" -iol \""+$ctlIol[$i]+"\"";
		if ($ctlCmd[$i]!="")
			$fDet+=" -c "+$ctlCmd[$i];
		if ($ctlAnn[$i]!="")
			$fDet+=" -ann \""+$ctlAnn[$i]+"\"";
		$fDet+=" \""+$ctlName[$i]+"\";\n";
		$fDet+="popupMenu;\n";
		$fDet+="\tmenuItem -l Key -c "+$ctlKeyCmd[$i]+";\n";
		$fDet+="\tmenuItem -l LinearKey -c "+$ctlLinearKeyCmd[$i]+";\n";
		if ($ctlAlignFK2IKCmd[$i]!="")
			{
			$fDet+="\tmenuItem -d 1;\n";
			$fDet+="\tmenuItem -l Align -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlAlignFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlAlignIK2FKCmd[$i]+";\n";
			$fDet+="\t\tsetParent -menu ..;\n";
			$fDet+="\tmenuItem -l Switch -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlSwitchFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlSwitchIK2FKCmd[$i]+";\n";
			}
		}
	$fDet+="//Controls End//\n";
	$fDet+="\n";
	$fDet+="formLayout -e\n";
	for ($i=0;$i<size($ctlType);$i++)
		{
		$fDet+="\t-af \""+$ctlName[$i]+"\" left "+$ctlLeft[$i]+"\n";
		$fDet+="\t-af \""+$ctlName[$i]+"\" top "+$ctlTop[$i]+"\n";
		}
	$fDet+="\t"+$uiName+"FormLayout;\n";
	
	$fDet+="\n\n\n\n";
	
	$fDet+="asPopulateNameSpaceMenu \"asSelector"+$projectName+"\";\n";
	$fDet+="asShowSelJob;\n";
	$fDet+="asSelChange;\n";
	$fDet+="showWindow;\n";

	$fDet+="}\n";
	}

int $fileId2=`fopen $asToolProcedures "r"`;
string $nextLine = `fgetline $fileId2`;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId2`;
	$fDet+=$nextLine;
	}
fclose $fileId2;

int $fileId=`fopen $projectFile "w"`;
fprint $fileId $fDet;
fclose $fileId;
}

//--*******************************************************************--//
//hidden, undocumented obsolete & unsuported procedures:
//asCreateBevel()
//asCreateNurbsCylinders()
//asDeleteNurbsCylinders()
//asMirrorNurbsCylinders (1)
