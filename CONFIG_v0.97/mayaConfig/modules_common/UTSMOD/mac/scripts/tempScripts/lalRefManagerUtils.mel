//-----------------------------------------------------------------------------
//
//    Copyright   (c)   2007    Lucasfilm    Animation,    Ltd.
//    All   rights   reserved.    Used   under   authorization.
//    This material contains the confidential  and  proprietary
//    information   of    Lucasfilm    Animation,   Ltd.    and
//    may not be copied in whole or in part without the express
//    written   permission   of   Lucasfilm   Animation,   Ltd.
//    This  copyright  notice  does  not   imply   publication.
//
//  Author: Mark Therrell
//    Contributions from: Kiaran Ritchie
//-----------------------------------------------------------------------------

// REQUIRMENTS AND DEPENDENCIES:
// currently requires module "cwAssetTools/2.x" or higher
// required plugins in this module: lalCallBack.so, lalAsset.so
// mel dependencies:
//      lalRigReferences.mel
//      lalRigConvert.mel

// DESCRIPTION:
// Manage multiple lalRefSwitcher with an lalRefManager node.
// used for saving and restoring multiple lalRefSwitcher settings,
// switching between asset types and performing actions via scriptNode
// (like rig assembly), on the referenced files.

// example of an lalRefManager template:
// lalRefManager: cloneAlpha
// lalRefSwitchers: Body,Head,Hair,Helmet,BdyAc1,BdyAc2,BdyAc3,BdyAc4,BdyAc5

// creates interface for loader template creation and management.
// a loader template is made up of a manager, some number of switchers
// and enum attributes on the manager whose values execute corrisponding
// sctriptnodes via calback plugin functionality.
// these scriptNodes constitute a "recipe" used to set values on the lalRefSwitchers.


//-------------------------------------------------------------------
// Creates the main GUI for working with a refManager system.
//-------------------------------------------------------------------
global proc lalRefManUI()
{
	if(`window -exists "MLT" `)
		catchQuiet(`deleteUI MLT`);

	//creates a simple dialoge window//
	window -widthHeight 200 450 -t "RefManager" MLT;

		columnLayout -w 200 -h 50 instructions;

			text -h 12 -l "Manger name:";
			textField -w 200 -h 25 T1;
			string $rManagers[] = `ls -typ lalRefManager`;
			textField -e -tx $rManagers T1;

			text -h 12 -l "Enter switcher Name(s)";
			text -h 12 -l "comma seperated to create";

			textField -w 200 -h 25 T2;
			button -w 200 -h 20 -l "create Manager and switchers" -c "lalRefMan_GUI_makeTemplate(1)";

			separator -h 10 -w 200 -style "out";
			//checkBox -v 0 -label "loadAssets on creation" loadOpt;
			//separator -h 10 -w 200 -style "out";

			text -h 12 -l "uses manager named above";
			text -h 12 -l "uses switcher name(s) above.";
			button -w 200 -h 20 -l "add new switcher(s) to Manager" -c "lalRefMan_GUI_makeTemplate(0)";

			separator -h 10 -w 200 -style "out";
			text -h 12 -l "edit setting attribute";
			text -h 12 -l "on named manager.";
			text -h 12 -l "name Setting here :";
			textField -w 200 -h 25 T3;
			button -w 200 -h 20 -l "save new setting" -c "lalRefMan_GUI_editSetting(1)";
			separator -h 5 -w 200 -style "in";
			button -w 200 -h 20 -l "delete named setting" -c "lalRefMan_GUI_editSetting(2)";
			separator -h 5 -w 200 -style "in";
			separator -h 5 -w 200 -style "in";
			button -w 200 -h 20 -l "edit current setting" -c "lalRefMan_GUI_editSetting(3)";
			separator -h 20;
			separator -h 5 -w 200 -style "in";

			text -h 12 -l "create a new Action ";
			text -h 12 -l "for a selected loader.";
			text -h 12 -l "name Action here:";
			textField -w 200 -h 25 T4;
			button -w 200 -h 20 -l "new action" -c "lalRefMan_GUI_createNewAction()";
			separator -h 20;
			separator -h 5 -w 200 -style "in";

			text -h 12 -l "publish operations";
			text -h 12 -l "for named manager:";
			button -w 200 -h 20 -l "clean current edits" -c "lalRefMan_GUI_sBatchOp(\"cleanLoaderRefEdits\")";
			button -w 200 -h 20 -l "run current actions" -c "lalRefMan_GUI_sBatchOp(\"runActions\")";
			button -w 200 -h 20 -l "convert manager to rig" -c "lalRefMan_standardConvert(\"interfaceDefined\")";
			separator -h 5 -w 200 -style "in";


			showWindow MLT;
}

//-------------------------------------------------------------------
// Creates a ref manager and some # of switchers for it to control
// Mode = 0 : Create new manager
// Mode = 1 : Add new switchers to existing manager
//-------------------------------------------------------------------
global proc string[] lalRefMan_GUI_makeTemplate(int $mode)
{
	string $template[];
	string $loaderNames = `textField -q -tx T2`;
	string $loaders[]; tokenize $loaderNames "," $loaders;
	string $managerName = `textField -q -tx T1`;
	string $manager[];

	if($mode == 1)
	{
		$manager = lalRefMan_refManagerBase($managerName);
		setAttr ($manager[1] + ".resolution") 4;
		setAttr ($manager[1] + ".callbacks") 1;
		setAttr ($manager[1] + ".class") 1;
	}

	if($mode == 0)
		$manager = {"1",$managerName};

	if(size($loaders) != 0 && size($manager)> 0)
	{
		for($l in $loaders)
		{
			print "\n building loader :";
			string $newLoader = lalRefMan_makeLoaderForTemplate($manager[1], $l);
			setAttr ($newLoader + ".callbacks") 0;
			setAttr ($newLoader + ".activeShelf") 0;
			setAttr ($newLoader + ".namespaceType") 2;
			setAttr ($newLoader + ".useLatest") 1;
			setAttr ($newLoader + ".assetClass") 2;
			setAttr ($newLoader + ".assetResolution") 4;
			string $nameSpace = `toupper $newLoader`;
			setAttr -type "string" ($newLoader + ".assetNamespace") $nameSpace;
			setAttr ($newLoader + ".activeShelf") 0;
			setAttr ($newLoader + ".renderResolution") 3;
		}
	}
	return $template;
}

//-------------------------------------------------------------------
// Creates, deletes or modifies a setting on the managers setting (recipe) attribute.
// $mode = 1 : Add new recipe
// $mode = 2 : Delete a recipe
// $mode = 3 : Edit a recipe
// This affects the "setting" enum attr on the ref manager.
// This enum value corresponds with an attached scriptNode containing
// a script string with data that calls the "lalRefMan_assumeSetting" proc.
// This proc uses proc lalRefMan_editEnum sending it a code to add delete or edit
//-------------------------------------------------------------------
global proc lalRefMan_GUI_editSetting(int $mode)
{
	string $settingName = `textField -q -tx T3`;
	string $managerName = `textField -q -tx T1`;
	string $builtSettingName = (":" + $settingName);

	// using the manager defined in the above textfield query,
	// get the current actual enum value of the setting attribute
	// for the edit case 3.
	string $settingVal = `getAttr -as ($managerName +".setting")`;
	switch($mode)
	{
		case 1:
			lalRefMan_editEnum($managerName,"setting","add",$builtSettingName,"2");
		break;
		case 2:
			lalRefMan_editEnum($managerName,"setting","delete",$builtSettingName,"1");
		break;
		case 3:
			print ($settingVal + "\n");
			lalRefMan_editEnum($managerName,"setting","edit",$settingVal,"1");
		break;
	}
}

//-------------------------------------------------------------------
// Creates a new action based on settings from GUI
//-------------------------------------------------------------------
global proc lalRefMan_GUI_createNewAction()
{
	string $actionName = `textField -q -tx T4`;
	string $sel[] = `ls -sl`;

	if ($sel[0] == "")
		error "Nothing selected. Please select a refSwitcher that you wish to add an action to. Action aborted.";
	if (`nodeType $sel[0]` != "lalRefSwitcher")
		error "Please select the refSwitcher node that you wish to add an action to. Action aborted.";

	lalRefMan_addActionSN($sel[0],$actionName);
}



//-------------------------------------------------------------------
// Calls lalRefMan_sBatchOp to perform batch operations on a collection of switchers.
//-------------------------------------------------------------------
global proc lalRefMan_GUI_sBatchOp(string $mode)
{
	string $manager = `textField -q -tx T1`;

	if($manager=="")
		error "No manager specified. Action aborted.\n";

	lalRefMan_sBatchOp($manager, $mode);
}

//-------------------------------------------------------------------
// Create a switcher and associate it with a manager
// This is wrapper for proc "lalRigRefSwitcher" found in lalRigReferences.mel
//-------------------------------------------------------------------
global proc string lalRefMan_makeLoaderForTemplate(string $manager, string $name)
{
	string $newLoader = lalRigRefSwitcher($name, "");
	parent $newLoader $manager;
	addAttr -ln "manager" -at "message" ($manager+"|"+$newLoader) ;
	connectAttr ($manager+".loaders") (($manager+"|"+$newLoader)+".manager");

	return $newLoader;
}

//-------------------------------------------------------------------
// builds a node based on lalCallback plugin (required)
// that contains attributes for actuating callbacks.
// the main attribute on this node is an enum named "setting".
// there is a scriptnode corrisponding to each value by name and connected via
// message.
//-------------------------------------------------------------------
global proc string[] lalRefMan_refManagerBase(string $name)
{
	string $nodeCreated[];
	if(`pluginInfo -q -l lalCallback.so`)
	{

		string $node = `createNode -name $name lalRefManager`;
		lalRefMan_editEnum($node,"setting","newAttr","none", "0");
		lalRefMan_editEnum($node,"resolution","newAttr","none:proxy:lo:med:hi:","0");
		lalRefMan_editEnum($node,"class","newAttr","none:model:motionRig","0");
		lalRefMan_editEnum($node,"switcherCallBacks","newAttr","off:on","0");
		lalRefMan_editEnum($node,"switcherLoadState","newAttr","allOff:allOn:selOff:selOn","0");
		lalRefMan_editEnum($node,"lookLoadState","newAttr","allOff:allOn","0");

		addAttr -ln "loaders" -at "message" $node ;
		addAttr -ln "loadOrder" -dt "string" $node ;
		addAttr -ln "managerActions" -at "message" $node ;

		//lalRefMan_createCallbackSN($node,"setting","none");
		//lalRefMan_createCallbackSN($node,"resolution","res");
		//lalRefMan_createCallbackSN($node,"class","class");

		for($a in {"setting","resolution","class","switcherCallBacks","switcherLoadState","lookLoadState"})
			lalAttrCallback -ac $a "lalRefMan_managerCB" $node;
		
		$nodeCreated[0] = "1";
		$nodeCreated[1] = $name;
		
	} else 
	$nodeCreated[0] = "0";
	
	return $nodeCreated;
}

//-------------------------------------------------------------------
// Create a scriptNode and connect it to an attribute (usually an enum)
// this scriptNode will correspond to an enum value
// and be executed when the ref manager runs all actions
//-------------------------------------------------------------------
global proc string[] lalRefMan_createCallbackSN(string $manager, string $cbAttr, string $enumVal)
{
	string $newSN[];
	string $SNName = ($enumVal+ "_SN");
	print (">>>> Creating " + $enumVal + "\n");

	int $scriptNodeExists;
	if (`objExists $SNName`)
		if (`nodeType $SNName` == "script")
			$scriptNodeExists = 1;

	if (!$scriptNodeExists)
	{
		$newSN[0] = `scriptNode -st 0 -n $SNName`;
		addAttr -multi -indexMatters false -ln "settConn" -at "message" $newSN[0];
	}else
		$newSN[0] = $SNName;

	//Remains backwards compatible with non multi-attr script nodes.
	//If settConn is not a multi (old method)
	if (`addAttr -q -m ($newSN[0] + ".settConn")`) //check if multi attr
		connectAttr -na ($manager+"."+$cbAttr) ($newSN[0]+".settConn");
	else if (!`isConnected ($manager+"."+$cbAttr) ($newSN[0]+".settConn")`)
		connectAttr -f ($manager+"."+$cbAttr) ($newSN[0]+".settConn");

	return $newSN;
}

//-------------------------------------------------------------------
// Creates an action scriptNode for a refSwitcher.
//-------------------------------------------------------------------
global proc lalRefMan_addActionSN(string $node, string $actionName)
{
	string $builtActionName = (":" + $actionName+"_Action");
	lalRefMan_editEnum($node,"action","add",$builtActionName, "1");
}

//-------------------------------------------------------------------
// This records the state of all the loaders that this manager controls at the time of new setting creation
// then writes out the state of those loaders to the new scriptnode being reated in the form of
// a string array "recipe" that is an argument to the "lalRefMan_assumeSetting" proc to actually restore the setting
//-------------------------------------------------------------------
global proc lalRefMan_recordLoaderSettings(string $manager, string $settingName, string $sNode)
{
	string $loaders[] = `listConnections -d on ($manager +".loaders")`;
	string $nameValIndex[];
	string $nameVal;
	string $valUnit[];
	string $settingData[];
	string $lookVal;

	for($l in $loaders)
	{
		clear $valUnit;
		$nameVal = `getAttr -as ($l +".assetName")`;
		if($nameVal=="") {$nameVal = "none";}
		// print ("NameValue for "+ $l +" is "+$nameVal + "\n") ;
		$lookVal = `getAttr -as ($l +".lookName")`;
		if($lookVal==""){$lookVal = "none";}
		$classVal = `getAttr -as ($l +".assetClass")`;
		$actionVal = `getAttr -as ($l +".action")`;
		$valUnit [0] = ("\n\n\""+$l+">"+$classVal+">"+$nameVal+">"+$lookVal+">"+$actionVal+"\"");
		appendStringArray($settingData, $valUnit, 1);
	}

	string $cmd = stringArrayToString($settingData, ",");
	string $sVal = "// " + $settingName +"\n\nstring $manager =" +
	" \""+$manager+"\";\n\nstring $nameAndVals[] = {"+
	$cmd +"\n\n};\nlalRefMan_assumeSetting($manager,$nameAndVals);";

	scriptNode -e -as $sVal $sNode;
}

//-------------------------------------------------------------------
// Record the file path
//-------------------------------------------------------------------
global proc lalRefMan_recordForwardReferencePath(string $sNode, string $mPath)
{
	string $getPathCmd = "string $mPath = `file -q -loc`;\n";
	string $selfSN = "string $sNode = \""+$sNode+"\";\n";
	string $refIf = "if(exists($sNode))\n{\n";
	string $getRefCmd = "string $selfFile = lalRefMan_recordForwardReferencePath($sNode,$mPath);\n}\n";
	string $emitPath = "string $selfPath = \"" + $mPath + "\";\n";
	string $findRefCmd = "string $RN[] = findRNodeFromMatchedPath($selfPath);\n";
	string $testCmd = "print (\">>>refNode: \"+$RN[0]+\"\\n\");\n";
	string $testCmd2 = "//createNode locator;\n";
	string $emitCmd = $getPathCmd+$selfSN+$refIf+$getRefCmd+$emitPath+$findRefCmd+$testCmd+$testCmd2;
	scriptNode -e -bs $emitCmd $sNode;
}

//-------------------------------------------------------------------
// used for archiving and transfering recipies and actions related to a manager
//example: lalRefMan_importExportSettings("manager",{"groupAllRecipies","groupPrefix",("copies" or "")})
//-------------------------------------------------------------------
global proc string[] lalRefMan_importExportSettings(string $manager, string $mode[])
{
	string $cVal[];
	
	if($mode[0] == "groupAllRecipies")
	{
		select -clear;
		string $rSet = `sets -n ($mode[1]+"_recipieBank")`;
		string $c_SN[] = `listConnections -d on ($manager+ ".setting")`;
		for($c in $c_SN)
		{
			if($mode[2] == "copies")
			{
				string $linkAttrName[]; tokenize $c "_" $linkAttrName;
				string $dup[] = `duplicate -n ($c+"_copy") $c`;
				sets -in $rSet $dup[0];
			} else
				sets -in $rSet $c;
		}
	}

	if($mode[0] == "groupAllActions")
	{
		select -clear;
		string $aSet = `sets -n ($mode[1]+"_actionBank")`;
		string $loadersUnSorted[] = `listConnections -d on ($manager + ".loaders")`;
		for($l in $loadersUnSorted)
		{
			string $actionSNodes[] = `listConnections -d on ($l + ".action")`;
			for ($a in $actionSNodes)
			{
				if($mode[2] == "copies")
				{
					// add the switcher name as a sufix to the copy
					// so that "importActions" will know which action 
					// belongs to which switcher
					string $dup[] = `duplicate -n ($a+"_"+$l) $a`;
					sets -in $aSet $dup[0];
				} else
					sets -in $aSet $a;
			}
		}
	}

	// given a manager with the same number and names of switchers 
	// that the recipies set came from connect to setting attr and add setting values
	if($mode[0] == "importRecipies")
	{
		string $rcpList[] = `sets -q $mode[1]`;
		for ($r in $rcpList)
		{
			$r = `rename $r (substitute("_copy",$r, ""))`;
			string $builtSettingName = (":" + (substitute("_SN",$r,"")));
			lalRefMan_editEnum($manager,"setting","add",$builtSettingName,"0");
			connectAttr ($manager+".setting") ($r+".settConn");
		}

	}

	// given a manager with the same number and names of switcher 
	// that the recipies set came from connect actions related to each switcher
	if($mode[0] == "importActions")
	{
		string $actList[] = `sets -q $mode[1]`;
		string $loadersUnSorted[] = `listConnections -d on ($manager +".loaders")`;
		for($a in $actList)
		{
			string $valList[]; tokenize $a "_" $valList;
			string $importLoaderName = $valList[((`size($valList)`) - 1)];
			for($l in $loadersUnSorted)
			{
				if(`gmatch $l $importLoaderName` == 1)
				{
					$a = `rename $a (substitute(("_"+$l),$a, ""))`;
					string $builtSettingName = (":" +(substitute("_SN",$a,"")));
					lalRefMan_editEnum($l,"action","add",$builtSettingName,"0");
					connectAttr ($l+".action") ($a+".acCon");
				}
			}

		}
	}
	
	return $cVal;
	
	//ex.
	//lalRefMan_importExportSettings("cloneTrooperAlpha",{"copyAllRecipies","CTA"});
	//lalRefMan_importExportSettings("cloneTrooperAlpha",{"opyAllActions","CTA"});

}

//-------------------------------------------------------------------
// Mechanism to create and edit an enum attribute with an associated scriptNode
// that restores the "state" of defined attributes.
// for use with "lalCallbackNode";
// enum setting acts as a callback that runs associated scriptNode
//-------------------------------------------------------------------
global proc lalRefMan_editEnum(string $node,string $attr,string $mode,string $enumName,string $hasSNode)
{
	string $newEnum = "";
	string $newEnumArry[];
	string $valUnit[];

	if($enumName== "")
		error "Empty string passed-in for enum name! Action aborted.\n";

	switch($mode)
	{
		///////////////
		case "delete":
		///////////////
		
			string $curEnum = (`addAttr -q -en ($node + "." + $attr)`);
			string $curEnumArry[]; tokenize $curEnum ":" $curEnumArry;
			string $enumNameArry[]; tokenize $enumName ":" $enumNameArry;

			for($val in $curEnumArry)
			{
				if(`gmatch $val $enumNameArry[0]` == 0)
				{
					$valUnit[0] = $val;
					appendStringArray($newEnumArry, $valUnit, 1);
				}
			}
			
			$newEnum = stringArrayToString($newEnumArry, ":");
			addAttr -e -en $newEnum ($node + "." + $attr);
			
			if($hasSNode == 1)
			{
				string $connected_SN[] = `connectionInfo -dfs ($node + "." + $attr)`;
				string $connectedArry[];
				
				for ($connected in $connected_SN)
				{
					tokenize $connected "." $connectedArry;
					if(`gmatch ($enumNameArry[0] + "_SN") $connectedArry[0]` == 1)
						delete $connectedArry[0];
				}
				
			}
			
		break;

		///////////////
		case "edit":
		///////////////
		
			string $curEnum = (`addAttr -q -en ($node + "." + $attr)`);
			string $curEnumArry[]; tokenize $curEnum ":" $curEnumArry;
			string $enumNameArry[]; tokenize $enumName "," $enumNameArry;
			print (">>>> Editing "+ $enumName + " enum.\n");
			int $snfound = 0;

			if($hasSNode == 1)
			{
				string $connected_SN[] = `listConnections -d on ($node + "." + $attr)`;
				
				for ($connected in $connected_SN)
				{
					print (($enumNameArry[0] + "_SN") + " --compare-- " + $connected + "\n");

					if(`gmatch ($enumNameArry[0] + "_SN") $connected` == 1)
					{
						$snfound = 1;
						delete $connected;
						string $sNode[] = lalRefMan_createCallbackSN($node, $attr, $enumNameArry[0]);
						lalRefMan_recordLoaderSettings($node, $enumNameArry[0], $sNode[0]);
					}
				}
			}
			
			if(!$snfound)
				warning "lalRefMan_editEnum : There is no scriptNode for this enum value to edit!";

			break;

		///////////////
		case "add":
		///////////////

			// create new enum value
			string $curEnum = (`addAttr -q -en ($node + "." + $attr)`);
			//print ("\n current enum "+$curEnum+" \n");
			//print ("\n new enum "+$enumName+" \n");
			addAttr -e -en ($curEnum + $enumName) ($node + "." + $attr);

			//create blank scriptNode corresponding to enum value
			if($hasSNode == 1)
			{
				string $enumNameArry[]; tokenize $enumName ":" $enumNameArry;
				lalRefMan_createCallbackSN($node,$attr,$enumNameArry[0]);
			}

			//create scriptNode corresponding to enum value,
			//record loader settings into scriptNode
			// (code "2" used in proc "lalRefMan_GUI_editSetting" above)
			if($hasSNode == 2)
			{
				string $enumNameArry[]; tokenize $enumName ":" $enumNameArry;
				string $sNode[] = lalRefMan_createCallbackSN($node,$attr,$enumNameArry[0]);
				lalRefMan_recordLoaderSettings($node, $enumNameArry[0], $sNode[0]);
			}

			break;

		///////////////
		case "rename":
		///////////////

			/*for($val in $curEnumArry)
			{
			if(`gmatch $val $enumNameArry[0]` == 1)
			{
			$valUnit[0] = $enumNameArry[1];
			appendStringArray($newEnumArry, $valUnit, 1);
			} else {
			$valUnit[0] = $val;
			appendStringArray($newEnumArry, $valUnit, 1);
			}
			}
			$newEnum = stringArrayToString($newEnumArry, ":");
			addAttr -e -en $newEnum ($node + "." + $attr);*/
			
		break;

		///////////////
		case "newAttr":
		///////////////
			addAttr	-ln $attr
					-keyable true
					-at "enum"
					-en $enumName
					$node;
		break;

		///////////////
		case "default":
		///////////////
			warning "Proc, \"lalRefMan_editEnum\" did not recieve a valid mode argument. Check your arguments and try again.\n";
		break;
	}
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//            BEGIN SECTION FOR MANAGER ATTRIBUTE CALLBACKS                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//-------------------------------------------------------------------
// Filters the callback from the refManager and performs appropriate function
//-------------------------------------------------------------------
global proc lalRefMan_managerCB(string $attr)
{
	string $objAttr[]; tokenize $attr "." $objAttr;
	string $cArry[];
	string $attrVal = `getAttr -as $attr`;
	int $attrNum = `getAttr $attr`;
	string $c;
	string $c_SN[] = `listConnections -d on $attr`;
	string $loaders[]; clear $loaders;
	$loaders = `listConnections -d on ($objAttr[0] +".loaders")`;

	switch($objAttr[1])
	{
		////////////////
		case "setting":
		////////////////

			if($attrVal == "none")
				warning "Use 'switcherLoadState' to turn all references off. \n";
				
			for ($c in $c_SN)
			{
				tokenize $c "_" $cArry;
				if(`gmatch $attrVal $cArry[0]` == 1)
					scriptNode -ea $c;
			}
			
		break;

		////////////////
		case "resolution":
		////////////////

			for($l in $loaders)
			{
				string $assetName = `getAttr -as ($l + ".assetName")`;
				if(size($assetName)!=0)
					if((`getAttr ($l +".assetResolution")`)!= $attrNum)
						setAttr ($l + ".assetResolution") $attrNum;
			}
			
		break;

		////////////////
		case "class":
		////////////////

			for($l in $loaders)
			{
				string $assetName = `getAttr -as ($l + ".assetName")`;
				if(size($assetName)!=0 )
				{
					string $loaderClass = `getAttr ($l +".assetClass")`;
					//if manager class gets set to none do nothing
					if($loaderClass != $attrNum && $attrNum !=0)
						setAttr ($l + ".assetClass") $attrNum;
				}
			}
		
		break;

		////////////////
		case "switcherCallBacks":
		////////////////

			if($attrVal== "off")
			{
				for($l in $loaders)
					setAttr ($l + ".callbacks") 0;
			} else 
				for($l in $loaders)
					setAttr ($l + ".callbacks") 1;
			
		break;

		////////////////
		case "switcherLoadState":
		////////////////

			switch($attrVal)
			{

				/////
				case "allOff":
				/////
					for($l in $loaders)
						setAttr ($l + ".remove") 1;
				break;
				
				/////
				case "allOn":
				/////
					setAttr ($objAttr[0] +".switcherCallBacks") 1;
					for($l in $loaders)
					{
						setAttr ($l + ".remove") 0;
						string $assetName = `getAttr -as ($l + ".assetName")`;
						
						if(size($assetName)!=0||$assetName !="none")
							setAttr -type "string" ($l + ".assetName") $assetName;
						else
							print ("refSwitcher "+ $l+" has no assetName entry \n");
					}
				break;

				/////
				case "selOff":
				/////
					warning ("Unloading references for selected switchers not implimented yet. \n");
				break;

				/////
				case "selOn":
				/////
					warning ("Loading references for selected switchers not implimented yet. \n");
				break;
				
			}

		////////////////
		case "lookLoadState":
		////////////////
		
			if ($attrVal == "allOff")
				for($l in $loaders)
					setAttr ($l + ".useLook") 0;
			
			if ($attrVal == "allOn")
				for($l in $loaders)
					setAttr ($l + ".useLook") 1;
		break;
	}
}


//-------------------------------------------------------------------
// **********
// wrapper for backwards compat with proc name "lalRefMan_assumeSetting"
//--------------------------------------------------------------
global proc assumeSetting(string $manager, string $nameAndVals[])
{
    lalRefMan_assumeSetting($manager,$nameAndVals);
}

//-------------------------------------------------------------------
// Iterates through all refSwitchers under the specified manager
// and sets each according to current recipe setting.
//-------------------------------------------------------------------
global proc lalRefMan_assumeSetting(string $manager, string $nameAndVals[])
{
	// hacky way of setting static enum attr by string.
	// create lookup that associates string to integer value.
	//string $assetClassLookup[] = {"none:0","motionRig:1","model:2"};

	// store current selection
	string $current[] = `ls -sl`;
	string $loadersUnSorted[] = `listConnections -d on ($manager +".loaders")`;
	string $loadOrderString = `getAttr ($manager + ".loadOrder")`;
	string $loadOrder[]; tokenize $loadOrderString "_" $loadOrder;

	// give warning if no load order defined
	if(size($loadOrder)<=1)
	{
		print ">>>>\n";
		print ">>>> Must define a load order string\n";
		print "     on the managers' .loadOrder attribute\n";
		print "     for the lalRefSwitchers under manager control\n";
		print "     to reference files from disk.\n";
		error "Assume Setting aborted. See script editor for details.";
	}

	string $nameValIndex[];
	// enforce a load order
	string $noOrder[] = stringArrayRemove($loadOrder, $loadersUnSorted);
	string $loaders[] = stringArrayCatenate($loadOrder, $noOrder);
	// print (" -> This is assumSetting proc\n");
	
	//Check to make sure setting not set to "none"
	if(`gmatch "none" $nameAndVals[2]`==1)
		return;

	for($n in $nameAndVals)
	{
		tokenize $n ">" $nameValIndex;
		for($l in $loaders)
		{
			string $currNameSetting = `getAttr -as ($l +".assetName")`;
			string $currLookSetting = `getAttr -as ($l +".lookName")`;
			string $currModelSetting = `getAttr -as ($l +".modelName")`;
			string $currRigSetting = `getAttr -as ($l +".rigName")`;
			string $currClassSetting = `getAttr -as ($l +".assetClass")`;

			string $lookLoadStateSetting = `getAttr -as ($manager+".lookLoadState")`;
			string $referenceNode[] = `listConnections -d on ($l +".reference")`;
			string $userEdits = `getAttr -as ($l +".userDefinedEdits")`;
			string $actionSNodes[] = `listConnections -d on ($l + ".action")`;
			string $definedAction = `getAttr -as ($l +".action")`;

			// if there is an empy string in assetName it needs to be replaced with "none"
			if($currNameSetting=="")
				setAttr -type "string" ($l +".assetName") "none";

			// if there is an empy string in lookName it needs to be replaced with "none"
			if($currNameSetting=="")
				setAttr -type "string" ($l +".lookName") "none";

			// need to unload a component because this setting does not include it. (empty index)
			if(`gmatch $l $nameValIndex[0]`==1 && $nameValIndex[2]=="none" && size($referenceNode)!=0)
			{
				setAttr -type "string" ($l +".assetName") "none";
				setAttr -type "string" ($l +".lookName") "none";
				lalRefMan_setEnumByString(($l +".action"),"none");
				lalRefMan_cleanRefs($referenceNode, "unload") ;
				lalRefMan_cleanRefs($referenceNode, "cleanEdits") ;
			}

			// the component has changed for this setting and it is not a "none" (empty) index
			if(`gmatch $l $nameValIndex[0]`==1 && $currNameSetting!=$nameValIndex[2] && $nameValIndex[2]!="none")
				setAttr -type "string" ($l +".assetName") $nameValIndex[2];

			//the asset class has changed for this setting
			if(`gmatch $l $nameValIndex[0]`==1 && $nameValIndex[1]!=$currClassSetting)
			{
				if($nameValIndex[1]=="model")
				{
					setAttr -type "string" ($l +".rigName") "none";
					setAttr ($l +".assetClass") 1;
				}

				if($nameValIndex[1]=="motionRig")
				{
					setAttr -type "string" ($l +".assetName") $nameValIndex[2];
					setAttr ($l +".assetClass") 2;
				}
			}

			// set the action attribute based on recipie defined action
			if(`gmatch $l $nameValIndex[0]`==1 && $definedAction!=$nameValIndex[4])
				lalRefMan_setEnumByString(($l +".action"),$nameValIndex[4]);

			// the look has changed, we need to do a new lookassign
			if(`gmatch $l $nameValIndex[0]`==1 && $currLookSetting!=$nameValIndex[3] && $nameValIndex[3]!="none")
			{
				setAttr -type "string" ($l +".lookName") $nameValIndex[3];
				//currently have to toggle the use look attr to do a refresh lookassign
				if($lookLoadStateSetting == "allOn")
				{
					setAttr($l +".useLook") 0; setAttr($l +".useLook") 1;
					//MLdeleteUnused();
				}
			}
		}
	}
	// restore current selection
	select -r $current;
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                BEGIN SECTION FOR HELPER UTILITY PROCS                     //
//                                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//-------------------------------------------------------------------
// Proc to set an enum attr via the string instead of the number
//-------------------------------------------------------------------
global proc lalRefMan_setEnumByString(string $attr, string $val)
{
	string $curEnum = (`addAttr -q -en $attr`);
	string $curEnumArry[]; tokenize $curEnum ":" $curEnumArry;
	for($i=0;$i<=(size($curEnumArry))-1; $i++)
		if($curEnumArry[$i] == $val)
			setAttr $attr $i;
}

//-------------------------------------------------------------------
// Proc to delete maya generated edits and edit generated nodes on referenced files
//-------------------------------------------------------------------
global proc lalRefMan_cleanRefs(string $rn[], string $mode)
{
	for($r in $rn)
	{
		if($mode == "cleanReload")
		{
			file -unloadReference $r;
			file -cleanReference $r;
			file -loadReference $r;
		}
		
		if($mode == "unload")
			file -unloadReference $r;
			
		if($mode == "cleanEdits")
			file -cleanReference $r;
			
		if($mode == "reload")
			file -loadReference $r;
			
		if($mode == "deleteFoster")
		{
			string $fos[]=`listConnections -s on ($r+".fosterParent")`;
			for($f in $fos)
				delete $f;
		}
	}
}

//-------------------------------------------------------------------
// Does a batch of operations on a collection of switchers under the
// specified manager. There are several valid operations specified
// by the $mode argument:
// $mode = "removeCallBacks"
// $mode = "runActions"
// $mode = "cleanLoaderRefEdits"
//-------------------------------------------------------------------
global proc lalRefMan_sBatchOp(string $manager, string $mode)
{
	string $loadersUnSorted[] = `listConnections -d on ($manager +".loaders")`;
	string $loadOrderString = `getAttr ($manager + ".loadOrder")`;
	string $loadOrder[]; tokenize $loadOrderString "_" $loadOrder;
	// inforce the load order (needed for cleaning)
	string $noOrder[] = stringArrayRemove($loadOrder, $loadersUnSorted);
	string $loaders[] = stringArrayCatenate($loadOrder, $noOrder);

	// iteration direction does not matter, load order does not matter
	if(($mode == "removeCallBacks")||($mode == "clean"))
	{
		for($l in $loadersUnSorted)
		{
			if($mode == "removeCallBacks")
				catch(`lalAttrCallback -da $l`);

			string $loaderChildren[] = `listRelatives -children $l`;
			
			if($mode == "clean" && size($loaderChildren)==0 )
				delete $l;
		}
	}

	if($mode == "runActions")
	{
		//iterate through loaders forwards
		for($i=0;$i<=(size($loaders) - 1); $i++)
		{
			string $definedAction = `getAttr -as ($loaders[$i] +".action")`;
			string $actionSNodes[] = `listConnections -d on ($loaders[$i] + ".action")`;
			// determine wheather reference is loaded or not
			string $loaderChildren[] = `listRelatives -children $loaders[$i]`;
			string $referenceNode[] = `listConnections -d on ($loaders[$i] + ".reference")`;

			for ($a in $actionSNodes)
				//matches current action attr val to attatched scriptnode and executes scriptNode
				if(`gmatch ($definedAction+"_SN") $a` == 1 && size($referenceNode)!=0 && size($loaderChildren)>0)
					scriptNode -ea $a;
		}
	}

	if(($mode=="cleanLoaderRefEdits")||($mode=="activeShelfOff")||($mode=="flatten"))
	{
		//iterate through loaders in reverse
		for($i=(size($loaders) - 1); $i>=0; $i--)
		{
			// print ($loaders[$i]+ "\n");
			// determine wheather reference is loaded or not
			string $loaderChildren[] = `listRelatives -children $loaders[$i]`;
			string $referenceNode[] = `listConnections -d on ($loaders[$i] + ".reference")`;
			string $assetIndicated = `getAttr -as ($loaders[$i] + ".assetName")`;

			if($mode == "cleanLoaderRefEdits"&& size($referenceNode)!=0)
			{
				lalRefMan_cleanRefs($referenceNode,"unload");
				lalRefMan_cleanRefs($referenceNode,"cleanEdits");
				if($assetIndicated!="none")
					lalRefMan_cleanRefs($referenceNode,"reload");
			}
			
			if($mode == "activeShelfOff")
				setAttr ($loaders[$i]+".activeShelf") 0;

			if($mode == "flatten" && size($referenceNode)!=0 && size($loaderChildren)>0)
			{
				for($lc in $loaderChildren)
				{
					if(`referenceQuery -inr $lc`)
					{
						string $rFile = `referenceQuery -f $referenceNode[0]`;
						file -ir $rFile;
					}
				}
			}
		}
	}
}

//-------------------------------------------------------------------
// batch operations on attributes of name and type on switchers associated with a manager
//-------------------------------------------------------------------
global proc sAttrBatchOp(string $manager, string $mode, string $attrName, string $attrType)
{
	string $loadersUnSorted[] = `listConnections -d on ($manager +".loaders")` ;

	for($l in $loadersUnSorted)
	{
		if($mode == "add")
			addAttr -at $attrType -ln $attrName $l;
			
		if($mode == "addEnumBool")
			lalRefMan_editEnum($l,$attrName,"newAttr","off:on:","0");
		
		if($mode == "delete")
			deleteAttr -at $attrName $l;
		
		if($mode == "makeKeyable")
			setAttr -k true ($l + "." + $attrName);
	}
}

//-------------------------------------------------------------------
// requires lalRigConvert.mel
//-------------------------------------------------------------------
global proc lalRefMan_standardConvert(string $mode)
{
	if($mode == "interfaceDefined")
	{
		string $managerName = `textField -q -tx T1`;
		select -r $managerName;
		lalRigRefManagerToRig();
	}
}

//-------------------------------------------------------------------
// aids in the creation of simple position and attatch scripts for components
//printKeyableSetAttr(`ls -sl`);
//-------------------------------------------------------------------
global proc lalRefMan_printKeyableSetAttr(string $obj[])
{
	for($o in $obj)
	{
		string $kAttrs[] = `listAttr -k $o`;
		for($a in $kAttrs)
		{
			float $val = `getAttr ($o+"." + $a)`;
			print ("setAttr " + $o+ "." + $a + " " + $val + ";\n");
		}
	}
}

//-------------------------------------------------------------------
// Helper proc
//-------------------------------------------------------------------
global proc string[] findRNodeFromMatchedPath(string $mPath)
{
	string $RN[];
	string $tmpRN[];
	string $rNodes[] = `ls -typ reference`;
	for($rn in $rNodes )
	{
		if($rn!="sharedReferenceNode")
		{
			string $file = `referenceQuery -f  $rn`;
			if($file == $mPath)
			{
				$tmpRN[0] = $rn;
				appendStringArray($RN, $tmpRN, 1);
			}
		}
	}
	return  $RN;
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                BEGIN SECTION FOR CODE SCRAPS                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//lalRefMan_sBatchOp("cloneTrooperAlpha","cleanLoaderRefEdits"); MLdeleteUnused;
//lalRefMan_sBatchOp("cloneTrooperAlpha","runActions");

//lalRefMan_sBatchOp("cloneTrooperAlpha", "flatten");
//lalRefMan_sBatchOp("cloneTrooperAlpha", "clean");
//removeNameSpace(":","allUnder");

//source "/lal/show/cw/home/gfx/bin/rigTools/dev/scripts/lalRigMessages.mel";
//lalRigDuplicateMsgNodes(lalRigImportAsset("clonePilotMatchstick","rig"),
//lalRigListChildMsgNodes("cloneTrooperAlpha",{"controls"}) );

// connect pauldron
//parentConstraint -mo -weight 1 Body1:IKSpine3 BdyAc6:MidSpineJt;
//scaleConstraint -mo -weight 1  Body1:IKSpine3 BdyAc6:MidSpineJt ;

//parentConstraint -mo -weight 1 Body1:tgtLeftShoulderAdj|Body1:LeftShoulder BdyAc6:LeftShoulderCtrlCons;
//scaleConstraint -mo -weight 1 Body1:tgtLeftShoulderAdj|Body1:LeftShoulder BdyAc6:LeftShoulderCtrlCons;


// lalRefMan_addActionSN("Head","HeadStandard");
// lalRefMan_addActionSN("BdyAc1","BackPack");

// editSAttrs("cloneTrooperAlpha","makeKeyable","action","");

// editSAttrs("cloneTrooperAlpha","addEnumBool","userDefinedEdits","enum");

// editSAttrs("cloneTrooperAlpha","delete","userDefinedEdits","enum");

               // this just sets the assetResolution to hi if changeis needed and res is off
               // this is temporary until a better way is devised

               //int $resNum = `getAttr ($l +".assetResolution")`;
               //if($currNameSetting != $nameValIndex[1] && $resNum==0)
               //{
               //    print ($manager +".resolution would be set to hi here");
               //    setAttr ($l +".assetResolution") 4;
               //}

               // int $isLoaded = `getAttr -s ($refNode[0] +".placeHolderList")`;

   //weight between constraints connected to head control
//setDrivenKeyframe -dv 0 -v 1 -cd Head1:Head.directionRelative($oc[0] + ".w1");
//setDrivenKeyframe  -dv 1 -v 0 -cd Head1:Head.directionRelative($oc[0] + ".w1");

//setDrivenKeyframe -dv 0 -v 0 -cd Head1:Head.directionRelative($oc[0] + ".w0");
//setDrivenKeyframe  -dv 1 -v 1 -cd Head1:Head.directionRelative($oc[0] + ".w0");


//listMatserCont("Body");

/* will need to check  duplicate controlNames on master asset.
rename everything not returned by the below (non master controls),
rename the below to the original; like "VisCon",
then remove the non master controls from the message master asset*/

// given a refSwitcher with a motion asset underneath,
// return the baseStructure controls for that rig

// isParentOf
// lalGetMsgNode(assetnode, name of messagecontrols);
//string $contList[] = {"VisCon","Direction","Offset","Start"};


/*  //returns only single control on defined slot of defined asset
type below $node[0]
   //$node[0] should be asset or switcher to start from
   if($mode == "findOnChildAsset")
   {
       string $childAssets[] = `listRelatives -ad -f -typ lalAsset
$node[0]`;
       for($a in $childAssets)
       {
           // $node[1] represents asset type like "Motion"
           if($node[1]==(`match ($node[1]+"$") $a`))
           {
               string $contMNode = lalGetMsgNode($a,"controls");
               for($c in $contList)
               {
                  $obj = lalGetMsgObjArray($contMNode, $c);
                  if($c==(`match ($c+"$") $obj[0]`)&& size($obj)==1)
                  {
                      appendStringArray($objArry, $obj, 1);
                  } else {print ("!!more than one control registered
on: " + $c);}
               }
           }
       }
   }*/

/*
string $manager = "cloneTrooperAlpha";
string $loaders[] = `listConnections -d on ($manager +".loaders")`;

for($l in $loaders)
{
catchQuiet(`lalAttrCallback -deleteCallback "activeShelf" $l`);
}

*/

                   /*string $lookName = `getAttr -as ($l + ".lookName")`;
                   string $lookVersion = `getAttr -as ($l + ".lookVersion")`;
                   if(size($assetName)!=0)
                   {
                       setAttr -type "string" ($l + ".assetName") $assetName;
                   } else {
                       print ("refSwitcher "+ $l+" has no assetName entry \n");
                   }*/



 /*// cloneTrooperEp2

string $manager = "cloneTrooperAlpha";

string $nameAndVals[] = {

"Head>motionRig>cloneHead>cloneTrooperHead>HeadStandard_Action",

"Body>motionRig>cloneBody>cloneEp2Body>none",

"Hair>model>cloneGenericHair>cloneGenericHair>none",

"Helmet>motionRig>cloneEp2Helmet>cloneEp2Helmet>Ep2TrooperHelmet_Action",

"BdyAc1>model>>>none",

"BdyAc2>model>>>none",

"BdyAc3>model>>>none",

"BdyAc4>model>>>none",

"BdyAc5>model>>>none",

"HlmtAc1>model>>>none",

"HlmtAc2>model>>>none",

"HlmtAc3>model>>>none",

"HlmtAc4>model>>>none",

"Gun1>model>>>none",

"Gun2>model>>>none",

"Gun3>model>>>none"
};

*/
//`gmatch $l $nameValIndex[0]`==1 &&

/*global proc serialClean()
{
    // a value of "null" requires lalRefMan_sBatchOp to sample
interface for manager
    print ">>>>> begin unload of refs\n";
    lalRefMan_sBatchOp("null","unload");
    print ">>>>> begin clean of ref edits\n";
    lalRefMan_sBatchOp("null","cleanEdits");
    print ">>>>> begin reload\n";
    lalRefMan_sBatchOp("null","reload");
    print ">>>>>cleaned ref edits\n";
}*/

